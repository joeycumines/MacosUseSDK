// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/macos_use.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 MacosUseSDK
//
// MacosUse service definition

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to open an application.
public struct Macosusesdk_V1_OpenApplicationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier (name, bundle ID, or path) of the application to open.
  /// Examples: "Calculator", "com.apple.calculator", "/Applications/Calculator.app"
  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from opening an application.
public struct Macosusesdk_V1_OpenApplicationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The application resource that was opened.
  public var application: Macosusesdk_V1_Application {
    get {return _application ?? Macosusesdk_V1_Application()}
    set {_application = newValue}
  }
  /// Returns true if `application` has been explicitly set.
  public var hasApplication: Bool {return self._application != nil}
  /// Clears the value of `application`. Subsequent reads from it will return its default value.
  public mutating func clearApplication() {self._application = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _application: Macosusesdk_V1_Application? = nil
}

/// Metadata for OpenApplication long-running operation.
public struct Macosusesdk_V1_OpenApplicationMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier being opened.
  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get an application.
public struct Macosusesdk_V1_GetApplicationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name of the application.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list applications.
public struct Macosusesdk_V1_ListApplicationsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum number of applications to return.
  public var pageSize: Int32 = 0

  /// Page token from a previous ListApplications call.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from listing applications.
public struct Macosusesdk_V1_ListApplicationsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The applications.
  public var applications: [Macosusesdk_V1_Application] = []

  /// Token to retrieve the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to delete an application.
public struct Macosusesdk_V1_DeleteApplicationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name of the application.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create an input.
public struct Macosusesdk_V1_CreateInputRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent resource. Either "applications/{application}" or "" for desktop inputs.
  public var parent: String = String()

  /// The input to create.
  public var input: Macosusesdk_V1_Input {
    get {return _input ?? Macosusesdk_V1_Input()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {self._input = nil}

  /// Optional input ID. If not provided, the server generates one.
  public var inputID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _input: Macosusesdk_V1_Input? = nil
}

/// Request to get an input.
public struct Macosusesdk_V1_GetInputRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name of the input.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list inputs.
public struct Macosusesdk_V1_ListInputsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent resource. Either "applications/{application}" or "" for desktop inputs.
  public var parent: String = String()

  /// Maximum number of inputs to return.
  public var pageSize: Int32 = 0

  /// Page token from a previous ListInputs call.
  public var pageToken: String = String()

  /// Filter inputs by state.
  public var stateFilter: Macosusesdk_V1_Input.State = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from listing inputs.
public struct Macosusesdk_V1_ListInputsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The inputs.
  public var inputs: [Macosusesdk_V1_Input] = []

  /// Token to retrieve the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to traverse accessibility tree.
public struct Macosusesdk_V1_TraverseAccessibilityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name of the application.
  public var name: String = String()

  /// Whether to return only visible elements.
  public var visibleOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from traversing accessibility tree.
public struct Macosusesdk_V1_TraverseAccessibilityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the application.
  public var appName: String = String()

  /// Elements found in the traversal.
  public var elements: [Macosusesdk_Type_Element] = []

  /// Statistics about the traversal.
  public var statistics: Macosusesdk_Type_TraversalStatistics {
    get {return _statistics ?? Macosusesdk_Type_TraversalStatistics()}
    set {_statistics = newValue}
  }
  /// Returns true if `statistics` has been explicitly set.
  public var hasStatistics: Bool {return self._statistics != nil}
  /// Clears the value of `statistics`. Subsequent reads from it will return its default value.
  public mutating func clearStatistics() {self._statistics = nil}

  /// Processing time in seconds.
  public var processingTime: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _statistics: Macosusesdk_Type_TraversalStatistics? = nil
}

/// Request to watch accessibility changes.
public struct Macosusesdk_V1_WatchAccessibilityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name of the application.
  public var name: String = String()

  /// Poll interval in seconds.
  public var pollInterval: Double = 0

  /// Whether to return only visible elements.
  public var visibleOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response streamed from watching accessibility.
public struct Macosusesdk_V1_WatchAccessibilityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Elements added since last update.
  public var added: [Macosusesdk_Type_Element] = []

  /// Elements removed since last update.
  public var removed: [Macosusesdk_Type_Element] = []

  /// Elements modified since last update.
  public var modified: [Macosusesdk_V1_ModifiedElement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An element that was modified.
public struct Macosusesdk_V1_ModifiedElement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The element before modification.
  public var before: Macosusesdk_Type_Element {
    get {return _before ?? Macosusesdk_Type_Element()}
    set {_before = newValue}
  }
  /// Returns true if `before` has been explicitly set.
  public var hasBefore: Bool {return self._before != nil}
  /// Clears the value of `before`. Subsequent reads from it will return its default value.
  public mutating func clearBefore() {self._before = nil}

  /// The element after modification.
  public var after: Macosusesdk_Type_Element {
    get {return _after ?? Macosusesdk_Type_Element()}
    set {_after = newValue}
  }
  /// Returns true if `after` has been explicitly set.
  public var hasAfter: Bool {return self._after != nil}
  /// Clears the value of `after`. Subsequent reads from it will return its default value.
  public mutating func clearAfter() {self._after = nil}

  /// List of changed attributes.
  public var changes: [Macosusesdk_V1_AttributeChange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _before: Macosusesdk_Type_Element? = nil
  fileprivate var _after: Macosusesdk_Type_Element? = nil
}

/// A change to an element attribute.
public struct Macosusesdk_V1_AttributeChange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the attribute.
  public var name: String = String()

  /// Old value.
  public var oldValue: String = String()

  /// New value.
  public var newValue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_OpenApplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenApplicationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_OpenApplicationRequest, rhs: Macosusesdk_V1_OpenApplicationRequest) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_OpenApplicationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenApplicationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._application {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_OpenApplicationResponse, rhs: Macosusesdk_V1_OpenApplicationResponse) -> Bool {
    if lhs._application != rhs._application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_OpenApplicationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenApplicationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_OpenApplicationMetadata, rhs: Macosusesdk_V1_OpenApplicationMetadata) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_GetApplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetApplicationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_GetApplicationRequest, rhs: Macosusesdk_V1_GetApplicationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ListApplicationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListApplicationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ListApplicationsRequest, rhs: Macosusesdk_V1_ListApplicationsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ListApplicationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListApplicationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}applications\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.applications) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.applications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.applications, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ListApplicationsResponse, rhs: Macosusesdk_V1_ListApplicationsResponse) -> Bool {
    if lhs.applications != rhs.applications {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_DeleteApplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteApplicationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_DeleteApplicationRequest, rhs: Macosusesdk_V1_DeleteApplicationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_CreateInputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInputRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}input\0\u{3}input_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inputID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.inputID.isEmpty {
      try visitor.visitSingularStringField(value: self.inputID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_CreateInputRequest, rhs: Macosusesdk_V1_CreateInputRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._input != rhs._input {return false}
    if lhs.inputID != rhs.inputID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_GetInputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInputRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_GetInputRequest, rhs: Macosusesdk_V1_GetInputRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ListInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInputsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}page_size\0\u{3}page_token\0\u{3}state_filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.stateFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.stateFilter != .unspecified {
      try visitor.visitSingularEnumField(value: self.stateFilter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ListInputsRequest, rhs: Macosusesdk_V1_ListInputsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.stateFilter != rhs.stateFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ListInputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInputsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}inputs\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ListInputsResponse, rhs: Macosusesdk_V1_ListInputsResponse) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_TraverseAccessibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraverseAccessibilityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}visible_only\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.visibleOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.visibleOnly != false {
      try visitor.visitSingularBoolField(value: self.visibleOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_TraverseAccessibilityRequest, rhs: Macosusesdk_V1_TraverseAccessibilityRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.visibleOnly != rhs.visibleOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_TraverseAccessibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraverseAccessibilityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}app_name\0\u{1}elements\0\u{1}statistics\0\u{3}processing_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._statistics) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.processingTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.appName.isEmpty {
      try visitor.visitSingularStringField(value: self.appName, fieldNumber: 1)
    }
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try { if let v = self._statistics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.processingTime.isEmpty {
      try visitor.visitSingularStringField(value: self.processingTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_TraverseAccessibilityResponse, rhs: Macosusesdk_V1_TraverseAccessibilityResponse) -> Bool {
    if lhs.appName != rhs.appName {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs._statistics != rhs._statistics {return false}
    if lhs.processingTime != rhs.processingTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WatchAccessibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchAccessibilityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}poll_interval\0\u{3}visible_only\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.pollInterval) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.visibleOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.pollInterval.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.pollInterval, fieldNumber: 2)
    }
    if self.visibleOnly != false {
      try visitor.visitSingularBoolField(value: self.visibleOnly, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WatchAccessibilityRequest, rhs: Macosusesdk_V1_WatchAccessibilityRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pollInterval != rhs.pollInterval {return false}
    if lhs.visibleOnly != rhs.visibleOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WatchAccessibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WatchAccessibilityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}added\0\u{1}removed\0\u{1}modified\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.added) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.removed) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.modified) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.added.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.added, fieldNumber: 1)
    }
    if !self.removed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removed, fieldNumber: 2)
    }
    if !self.modified.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modified, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WatchAccessibilityResponse, rhs: Macosusesdk_V1_WatchAccessibilityResponse) -> Bool {
    if lhs.added != rhs.added {return false}
    if lhs.removed != rhs.removed {return false}
    if lhs.modified != rhs.modified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ModifiedElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModifiedElement"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}before\0\u{1}after\0\u{1}changes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._before) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._after) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.changes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._before {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._after {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.changes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.changes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ModifiedElement, rhs: Macosusesdk_V1_ModifiedElement) -> Bool {
    if lhs._before != rhs._before {return false}
    if lhs._after != rhs._after {return false}
    if lhs.changes != rhs.changes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_AttributeChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeChange"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}old_value\0\u{3}new_value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.oldValue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.oldValue.isEmpty {
      try visitor.visitSingularStringField(value: self.oldValue, fieldNumber: 2)
    }
    if !self.newValue.isEmpty {
      try visitor.visitSingularStringField(value: self.newValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_AttributeChange, rhs: Macosusesdk_V1_AttributeChange) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.oldValue != rhs.oldValue {return false}
    if lhs.newValue != rhs.newValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
