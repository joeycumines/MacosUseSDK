// Copyright 2025 MacosUseSDK
//
// File dialog automation and file operations

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: macosusesdk/v1/file.proto

package macosusesdkv1

import (
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Request to automate an open file dialog.
type AutomateOpenFileDialogRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Application context.
	Application string `protobuf:"bytes,1,opt,name=application,proto3" json:"application,omitempty"`
	// File path to select (if known).
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// Default directory to navigate to.
	DefaultDirectory string `protobuf:"bytes,3,opt,name=default_directory,json=defaultDirectory,proto3" json:"default_directory,omitempty"`
	// File type filters (e.g., ["*.txt", "*.pdf"]).
	FileFilters []string `protobuf:"bytes,4,rep,name=file_filters,json=fileFilters,proto3" json:"file_filters,omitempty"`
	// Timeout for dialog to appear (seconds).
	Timeout float64 `protobuf:"fixed64,5,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Whether to allow multiple file selection.
	AllowMultiple bool `protobuf:"varint,6,opt,name=allow_multiple,json=allowMultiple,proto3" json:"allow_multiple,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutomateOpenFileDialogRequest) Reset() {
	*x = AutomateOpenFileDialogRequest{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomateOpenFileDialogRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomateOpenFileDialogRequest) ProtoMessage() {}

func (x *AutomateOpenFileDialogRequest) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomateOpenFileDialogRequest.ProtoReflect.Descriptor instead.
func (*AutomateOpenFileDialogRequest) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{0}
}

func (x *AutomateOpenFileDialogRequest) GetApplication() string {
	if x != nil {
		return x.Application
	}
	return ""
}

func (x *AutomateOpenFileDialogRequest) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *AutomateOpenFileDialogRequest) GetDefaultDirectory() string {
	if x != nil {
		return x.DefaultDirectory
	}
	return ""
}

func (x *AutomateOpenFileDialogRequest) GetFileFilters() []string {
	if x != nil {
		return x.FileFilters
	}
	return nil
}

func (x *AutomateOpenFileDialogRequest) GetTimeout() float64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *AutomateOpenFileDialogRequest) GetAllowMultiple() bool {
	if x != nil {
		return x.AllowMultiple
	}
	return false
}

// Response from automating an open file dialog.
type AutomateOpenFileDialogResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the operation succeeded.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Selected file path(s).
	SelectedPaths []string `protobuf:"bytes,2,rep,name=selected_paths,json=selectedPaths,proto3" json:"selected_paths,omitempty"`
	// Error message if failed.
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutomateOpenFileDialogResponse) Reset() {
	*x = AutomateOpenFileDialogResponse{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomateOpenFileDialogResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomateOpenFileDialogResponse) ProtoMessage() {}

func (x *AutomateOpenFileDialogResponse) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomateOpenFileDialogResponse.ProtoReflect.Descriptor instead.
func (*AutomateOpenFileDialogResponse) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{1}
}

func (x *AutomateOpenFileDialogResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AutomateOpenFileDialogResponse) GetSelectedPaths() []string {
	if x != nil {
		return x.SelectedPaths
	}
	return nil
}

func (x *AutomateOpenFileDialogResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Request to automate a save file dialog.
type AutomateSaveFileDialogRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Application context.
	Application string `protobuf:"bytes,1,opt,name=application,proto3" json:"application,omitempty"`
	// File path to save to.
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// Default directory to navigate to.
	DefaultDirectory string `protobuf:"bytes,3,opt,name=default_directory,json=defaultDirectory,proto3" json:"default_directory,omitempty"`
	// Default filename.
	DefaultFilename string `protobuf:"bytes,4,opt,name=default_filename,json=defaultFilename,proto3" json:"default_filename,omitempty"`
	// Timeout for dialog to appear (seconds).
	Timeout float64 `protobuf:"fixed64,5,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Whether to confirm overwrite.
	ConfirmOverwrite bool `protobuf:"varint,6,opt,name=confirm_overwrite,json=confirmOverwrite,proto3" json:"confirm_overwrite,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AutomateSaveFileDialogRequest) Reset() {
	*x = AutomateSaveFileDialogRequest{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomateSaveFileDialogRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomateSaveFileDialogRequest) ProtoMessage() {}

func (x *AutomateSaveFileDialogRequest) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomateSaveFileDialogRequest.ProtoReflect.Descriptor instead.
func (*AutomateSaveFileDialogRequest) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{2}
}

func (x *AutomateSaveFileDialogRequest) GetApplication() string {
	if x != nil {
		return x.Application
	}
	return ""
}

func (x *AutomateSaveFileDialogRequest) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *AutomateSaveFileDialogRequest) GetDefaultDirectory() string {
	if x != nil {
		return x.DefaultDirectory
	}
	return ""
}

func (x *AutomateSaveFileDialogRequest) GetDefaultFilename() string {
	if x != nil {
		return x.DefaultFilename
	}
	return ""
}

func (x *AutomateSaveFileDialogRequest) GetTimeout() float64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *AutomateSaveFileDialogRequest) GetConfirmOverwrite() bool {
	if x != nil {
		return x.ConfirmOverwrite
	}
	return false
}

// Response from automating a save file dialog.
type AutomateSaveFileDialogResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the operation succeeded.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Final save path.
	SavedPath string `protobuf:"bytes,2,opt,name=saved_path,json=savedPath,proto3" json:"saved_path,omitempty"`
	// Error message if failed.
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AutomateSaveFileDialogResponse) Reset() {
	*x = AutomateSaveFileDialogResponse{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AutomateSaveFileDialogResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomateSaveFileDialogResponse) ProtoMessage() {}

func (x *AutomateSaveFileDialogResponse) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomateSaveFileDialogResponse.ProtoReflect.Descriptor instead.
func (*AutomateSaveFileDialogResponse) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{3}
}

func (x *AutomateSaveFileDialogResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AutomateSaveFileDialogResponse) GetSavedPath() string {
	if x != nil {
		return x.SavedPath
	}
	return ""
}

func (x *AutomateSaveFileDialogResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Request to select a file programmatically.
type SelectFileRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Application context.
	Application string `protobuf:"bytes,1,opt,name=application,proto3" json:"application,omitempty"`
	// File path to select.
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// Whether to reveal Finder after selection.
	RevealFinder  bool `protobuf:"varint,3,opt,name=reveal_finder,json=revealFinder,proto3" json:"reveal_finder,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SelectFileRequest) Reset() {
	*x = SelectFileRequest{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SelectFileRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SelectFileRequest) ProtoMessage() {}

func (x *SelectFileRequest) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SelectFileRequest.ProtoReflect.Descriptor instead.
func (*SelectFileRequest) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{4}
}

func (x *SelectFileRequest) GetApplication() string {
	if x != nil {
		return x.Application
	}
	return ""
}

func (x *SelectFileRequest) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *SelectFileRequest) GetRevealFinder() bool {
	if x != nil {
		return x.RevealFinder
	}
	return false
}

// Response from selecting a file.
type SelectFileResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the operation succeeded.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Selected file path.
	SelectedPath string `protobuf:"bytes,2,opt,name=selected_path,json=selectedPath,proto3" json:"selected_path,omitempty"`
	// Error message if failed.
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SelectFileResponse) Reset() {
	*x = SelectFileResponse{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SelectFileResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SelectFileResponse) ProtoMessage() {}

func (x *SelectFileResponse) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SelectFileResponse.ProtoReflect.Descriptor instead.
func (*SelectFileResponse) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{5}
}

func (x *SelectFileResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SelectFileResponse) GetSelectedPath() string {
	if x != nil {
		return x.SelectedPath
	}
	return ""
}

func (x *SelectFileResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Request to select a directory.
type SelectDirectoryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Application context.
	Application string `protobuf:"bytes,1,opt,name=application,proto3" json:"application,omitempty"`
	// Directory path to select.
	DirectoryPath string `protobuf:"bytes,2,opt,name=directory_path,json=directoryPath,proto3" json:"directory_path,omitempty"`
	// Whether to create directory when it doesn't exist.
	CreateMissing bool `protobuf:"varint,3,opt,name=create_missing,json=createMissing,proto3" json:"create_missing,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SelectDirectoryRequest) Reset() {
	*x = SelectDirectoryRequest{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SelectDirectoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SelectDirectoryRequest) ProtoMessage() {}

func (x *SelectDirectoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SelectDirectoryRequest.ProtoReflect.Descriptor instead.
func (*SelectDirectoryRequest) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{6}
}

func (x *SelectDirectoryRequest) GetApplication() string {
	if x != nil {
		return x.Application
	}
	return ""
}

func (x *SelectDirectoryRequest) GetDirectoryPath() string {
	if x != nil {
		return x.DirectoryPath
	}
	return ""
}

func (x *SelectDirectoryRequest) GetCreateMissing() bool {
	if x != nil {
		return x.CreateMissing
	}
	return false
}

// Response from selecting a directory.
type SelectDirectoryResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the operation succeeded.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Selected directory path.
	SelectedPath string `protobuf:"bytes,2,opt,name=selected_path,json=selectedPath,proto3" json:"selected_path,omitempty"`
	// Whether the directory was created.
	Created bool `protobuf:"varint,3,opt,name=created,proto3" json:"created,omitempty"`
	// Error message if failed.
	Error         string `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SelectDirectoryResponse) Reset() {
	*x = SelectDirectoryResponse{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SelectDirectoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SelectDirectoryResponse) ProtoMessage() {}

func (x *SelectDirectoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SelectDirectoryResponse.ProtoReflect.Descriptor instead.
func (*SelectDirectoryResponse) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{7}
}

func (x *SelectDirectoryResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SelectDirectoryResponse) GetSelectedPath() string {
	if x != nil {
		return x.SelectedPath
	}
	return ""
}

func (x *SelectDirectoryResponse) GetCreated() bool {
	if x != nil {
		return x.Created
	}
	return false
}

func (x *SelectDirectoryResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// Request to drag and drop files.
type DragFilesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Application context.
	Application string `protobuf:"bytes,1,opt,name=application,proto3" json:"application,omitempty"`
	// File paths to drag.
	FilePaths []string `protobuf:"bytes,2,rep,name=file_paths,json=filePaths,proto3" json:"file_paths,omitempty"`
	// Target element ID to drop on.
	TargetElementId string `protobuf:"bytes,3,opt,name=target_element_id,json=targetElementId,proto3" json:"target_element_id,omitempty"`
	// Drag duration in seconds.
	Duration      float64 `protobuf:"fixed64,4,opt,name=duration,proto3" json:"duration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DragFilesRequest) Reset() {
	*x = DragFilesRequest{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DragFilesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DragFilesRequest) ProtoMessage() {}

func (x *DragFilesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DragFilesRequest.ProtoReflect.Descriptor instead.
func (*DragFilesRequest) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{8}
}

func (x *DragFilesRequest) GetApplication() string {
	if x != nil {
		return x.Application
	}
	return ""
}

func (x *DragFilesRequest) GetFilePaths() []string {
	if x != nil {
		return x.FilePaths
	}
	return nil
}

func (x *DragFilesRequest) GetTargetElementId() string {
	if x != nil {
		return x.TargetElementId
	}
	return ""
}

func (x *DragFilesRequest) GetDuration() float64 {
	if x != nil {
		return x.Duration
	}
	return 0
}

// Response from dragging files.
type DragFilesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the operation succeeded.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Number of files dropped.
	FilesDropped int32 `protobuf:"varint,2,opt,name=files_dropped,json=filesDropped,proto3" json:"files_dropped,omitempty"`
	// Error message if failed.
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DragFilesResponse) Reset() {
	*x = DragFilesResponse{}
	mi := &file_macosusesdk_v1_file_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DragFilesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DragFilesResponse) ProtoMessage() {}

func (x *DragFilesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_macosusesdk_v1_file_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DragFilesResponse.ProtoReflect.Descriptor instead.
func (*DragFilesResponse) Descriptor() ([]byte, []int) {
	return file_macosusesdk_v1_file_proto_rawDescGZIP(), []int{9}
}

func (x *DragFilesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *DragFilesResponse) GetFilesDropped() int32 {
	if x != nil {
		return x.FilesDropped
	}
	return 0
}

func (x *DragFilesResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

var File_macosusesdk_v1_file_proto protoreflect.FileDescriptor

const file_macosusesdk_v1_file_proto_rawDesc = "" +
	"\n" +
	"\x19macosusesdk/v1/file.proto\x12\x0emacosusesdk.v1\x1a\x1fgoogle/api/field_behavior.proto\x1a\x19google/api/resource.proto\"\xb2\x02\n" +
	"\x1dAutomateOpenFileDialogRequest\x12J\n" +
	"\vapplication\x18\x01 \x01(\tB(\xe0A\x02\xfaA\"\n" +
	" macos.googleapis.com/ApplicationR\vapplication\x12 \n" +
	"\tfile_path\x18\x02 \x01(\tB\x03\xe0A\x01R\bfilePath\x120\n" +
	"\x11default_directory\x18\x03 \x01(\tB\x03\xe0A\x01R\x10defaultDirectory\x12&\n" +
	"\ffile_filters\x18\x04 \x03(\tB\x03\xe0A\x01R\vfileFilters\x12\x1d\n" +
	"\atimeout\x18\x05 \x01(\x01B\x03\xe0A\x01R\atimeout\x12*\n" +
	"\x0eallow_multiple\x18\x06 \x01(\bB\x03\xe0A\x01R\rallowMultiple\"w\n" +
	"\x1eAutomateOpenFileDialogResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12%\n" +
	"\x0eselected_paths\x18\x02 \x03(\tR\rselectedPaths\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"\xc0\x02\n" +
	"\x1dAutomateSaveFileDialogRequest\x12J\n" +
	"\vapplication\x18\x01 \x01(\tB(\xe0A\x02\xfaA\"\n" +
	" macos.googleapis.com/ApplicationR\vapplication\x12 \n" +
	"\tfile_path\x18\x02 \x01(\tB\x03\xe0A\x02R\bfilePath\x120\n" +
	"\x11default_directory\x18\x03 \x01(\tB\x03\xe0A\x01R\x10defaultDirectory\x12.\n" +
	"\x10default_filename\x18\x04 \x01(\tB\x03\xe0A\x01R\x0fdefaultFilename\x12\x1d\n" +
	"\atimeout\x18\x05 \x01(\x01B\x03\xe0A\x01R\atimeout\x120\n" +
	"\x11confirm_overwrite\x18\x06 \x01(\bB\x03\xe0A\x01R\x10confirmOverwrite\"o\n" +
	"\x1eAutomateSaveFileDialogResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x1d\n" +
	"\n" +
	"saved_path\x18\x02 \x01(\tR\tsavedPath\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"\xab\x01\n" +
	"\x11SelectFileRequest\x12J\n" +
	"\vapplication\x18\x01 \x01(\tB(\xe0A\x02\xfaA\"\n" +
	" macos.googleapis.com/ApplicationR\vapplication\x12 \n" +
	"\tfile_path\x18\x02 \x01(\tB\x03\xe0A\x02R\bfilePath\x12(\n" +
	"\rreveal_finder\x18\x03 \x01(\bB\x03\xe0A\x01R\frevealFinder\"i\n" +
	"\x12SelectFileResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rselected_path\x18\x02 \x01(\tR\fselectedPath\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"\xbc\x01\n" +
	"\x16SelectDirectoryRequest\x12J\n" +
	"\vapplication\x18\x01 \x01(\tB(\xe0A\x02\xfaA\"\n" +
	" macos.googleapis.com/ApplicationR\vapplication\x12*\n" +
	"\x0edirectory_path\x18\x02 \x01(\tB\x03\xe0A\x02R\rdirectoryPath\x12*\n" +
	"\x0ecreate_missing\x18\x03 \x01(\bB\x03\xe0A\x01R\rcreateMissing\"\x88\x01\n" +
	"\x17SelectDirectoryResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rselected_path\x18\x02 \x01(\tR\fselectedPath\x12\x18\n" +
	"\acreated\x18\x03 \x01(\bR\acreated\x12\x14\n" +
	"\x05error\x18\x04 \x01(\tR\x05error\"\xd4\x01\n" +
	"\x10DragFilesRequest\x12J\n" +
	"\vapplication\x18\x01 \x01(\tB(\xe0A\x02\xfaA\"\n" +
	" macos.googleapis.com/ApplicationR\vapplication\x12\"\n" +
	"\n" +
	"file_paths\x18\x02 \x03(\tB\x03\xe0A\x02R\tfilePaths\x12/\n" +
	"\x11target_element_id\x18\x03 \x01(\tB\x03\xe0A\x02R\x0ftargetElementId\x12\x1f\n" +
	"\bduration\x18\x04 \x01(\x01B\x03\xe0A\x01R\bduration\"h\n" +
	"\x11DragFilesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rfiles_dropped\x18\x02 \x01(\x05R\ffilesDropped\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05errorB\xc0\x01\n" +
	"\x12com.macosusesdk.v1B\tFileProtoP\x01ZFgithub.com/joeycumines/MacosUseSDK/gen/go/macosusesdk/v1;macosusesdkv1\xa2\x02\x03MXX\xaa\x02\x0eMacosusesdk.V1\xca\x02\x0eMacosusesdk\\V1\xe2\x02\x1aMacosusesdk\\V1\\GPBMetadata\xea\x02\x0fMacosusesdk::V1b\x06proto3"

var (
	file_macosusesdk_v1_file_proto_rawDescOnce sync.Once
	file_macosusesdk_v1_file_proto_rawDescData []byte
)

func file_macosusesdk_v1_file_proto_rawDescGZIP() []byte {
	file_macosusesdk_v1_file_proto_rawDescOnce.Do(func() {
		file_macosusesdk_v1_file_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_macosusesdk_v1_file_proto_rawDesc), len(file_macosusesdk_v1_file_proto_rawDesc)))
	})
	return file_macosusesdk_v1_file_proto_rawDescData
}

var file_macosusesdk_v1_file_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_macosusesdk_v1_file_proto_goTypes = []any{
	(*AutomateOpenFileDialogRequest)(nil),  // 0: macosusesdk.v1.AutomateOpenFileDialogRequest
	(*AutomateOpenFileDialogResponse)(nil), // 1: macosusesdk.v1.AutomateOpenFileDialogResponse
	(*AutomateSaveFileDialogRequest)(nil),  // 2: macosusesdk.v1.AutomateSaveFileDialogRequest
	(*AutomateSaveFileDialogResponse)(nil), // 3: macosusesdk.v1.AutomateSaveFileDialogResponse
	(*SelectFileRequest)(nil),              // 4: macosusesdk.v1.SelectFileRequest
	(*SelectFileResponse)(nil),             // 5: macosusesdk.v1.SelectFileResponse
	(*SelectDirectoryRequest)(nil),         // 6: macosusesdk.v1.SelectDirectoryRequest
	(*SelectDirectoryResponse)(nil),        // 7: macosusesdk.v1.SelectDirectoryResponse
	(*DragFilesRequest)(nil),               // 8: macosusesdk.v1.DragFilesRequest
	(*DragFilesResponse)(nil),              // 9: macosusesdk.v1.DragFilesResponse
}
var file_macosusesdk_v1_file_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_macosusesdk_v1_file_proto_init() }
func file_macosusesdk_v1_file_proto_init() {
	if File_macosusesdk_v1_file_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_macosusesdk_v1_file_proto_rawDesc), len(file_macosusesdk_v1_file_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_macosusesdk_v1_file_proto_goTypes,
		DependencyIndexes: file_macosusesdk_v1_file_proto_depIdxs,
		MessageInfos:      file_macosusesdk_v1_file_proto_msgTypes,
	}.Build()
	File_macosusesdk_v1_file_proto = out.File
	file_macosusesdk_v1_file_proto_goTypes = nil
	file_macosusesdk_v1_file_proto_depIdxs = nil
}
