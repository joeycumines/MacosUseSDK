// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/macro.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 Joseph Cumines
//
// Macro resource for recordable action sequences

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// A resource representing a recorded sequence of actions.
/// Macros can be replayed to automate repetitive tasks.
public struct Macosusesdk_V1_Macro: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name in the format "macros/{macro}"
    /// where {macro} is a unique macro identifier.
    public var name: String = .init()

    /// Display name for the macro.
    public var displayName: String = .init()

    /// Description of what the macro does.
    public var description_p: String = .init()

    /// Sequence of actions in the macro.
    public var actions: [Macosusesdk_V1_MacroAction] = []

    /// Macro parameters (for parameterized macros).
    public var parameters: [Macosusesdk_V1_MacroParameter] = []

    /// When the macro was created.
    public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _createTime = newValue }
    }

    /// Returns true if `createTime` has been explicitly set.
    public var hasCreateTime: Bool { _createTime != nil }
    /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
    public mutating func clearCreateTime() { _createTime = nil }

    /// When the macro was last modified.
    public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _updateTime = newValue }
    }

    /// Returns true if `updateTime` has been explicitly set.
    public var hasUpdateTime: Bool { _updateTime != nil }
    /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateTime() { _updateTime = nil }

    /// Number of times the macro has been executed.
    public var executionCount: Int64 = 0

    /// Tags for categorization.
    public var tags: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp?
    fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// Log entry for macro execution.
public struct Macosusesdk_V1_ExecutionLogEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name.
    public var name: String = .init()

    /// When the action executed.
    public var executionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _executionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _executionTime = newValue }
    }

    /// Returns true if `executionTime` has been explicitly set.
    public var hasExecutionTime: Bool { _executionTime != nil }
    /// Clears the value of `executionTime`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionTime() { _executionTime = nil }

    /// Action index in macro.
    public var actionIndex: Int32 = 0

    /// Action description.
    public var description_p: String = .init()

    /// Whether action succeeded.
    public var success: Bool = false

    /// Error message if failed.
    public var error: String = .init()

    /// Duration in seconds.
    public var duration: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _executionTime: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// A single action within a macro.
public struct Macosusesdk_V1_MacroAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Action type.
    public var action: Macosusesdk_V1_MacroAction.OneOf_Action?

    /// Input action (click, type, etc.).
    public var input: Macosusesdk_V1_InputAction {
        get {
            if case let .input(v)? = action { return v }
            return Macosusesdk_V1_InputAction()
        }
        set { action = .input(newValue) }
    }

    /// Wait/delay action.
    public var wait: Macosusesdk_V1_WaitAction {
        get {
            if case let .wait(v)? = action { return v }
            return Macosusesdk_V1_WaitAction()
        }
        set { action = .wait(newValue) }
    }

    /// Conditional action (if-then).
    public var conditional: Macosusesdk_V1_ConditionalAction {
        get {
            if case let .conditional(v)? = action { return v }
            return Macosusesdk_V1_ConditionalAction()
        }
        set { action = .conditional(newValue) }
    }

    /// Loop action (repeat).
    public var loop: Macosusesdk_V1_LoopAction {
        get {
            if case let .loop(v)? = action { return v }
            return Macosusesdk_V1_LoopAction()
        }
        set { action = .loop(newValue) }
    }

    /// Variable assignment.
    public var assign: Macosusesdk_V1_AssignAction {
        get {
            if case let .assign(v)? = action { return v }
            return Macosusesdk_V1_AssignAction()
        }
        set { action = .assign(newValue) }
    }

    /// Custom method call.
    public var methodCall: Macosusesdk_V1_MethodCall {
        get {
            if case let .methodCall(v)? = action { return v }
            return Macosusesdk_V1_MethodCall()
        }
        set { action = .methodCall(newValue) }
    }

    /// Human-readable description of this action.
    public var description_p: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Action type.
    public enum OneOf_Action: Equatable, Sendable {
        /// Input action (click, type, etc.).
        case input(Macosusesdk_V1_InputAction)
        /// Wait/delay action.
        case wait(Macosusesdk_V1_WaitAction)
        /// Conditional action (if-then).
        case conditional(Macosusesdk_V1_ConditionalAction)
        /// Loop action (repeat).
        case loop(Macosusesdk_V1_LoopAction)
        /// Variable assignment.
        case assign(Macosusesdk_V1_AssignAction)
        /// Custom method call.
        case methodCall(Macosusesdk_V1_MethodCall)
    }

    public init() {}
}

/// Wait/delay action.
public struct Macosusesdk_V1_WaitAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Duration to wait in seconds.
    public var duration: Double = 0

    /// Optional condition to wait for.
    public var condition: Macosusesdk_V1_WaitCondition {
        get { _condition ?? Macosusesdk_V1_WaitCondition() }
        set { _condition = newValue }
    }

    /// Returns true if `condition` has been explicitly set.
    public var hasCondition: Bool { _condition != nil }
    /// Clears the value of `condition`. Subsequent reads from it will return its default value.
    public mutating func clearCondition() { _condition = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _condition: Macosusesdk_V1_WaitCondition?
}

/// Condition to wait for.
public struct Macosusesdk_V1_WaitCondition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Condition type.
    public var condition: Macosusesdk_V1_WaitCondition.OneOf_Condition?

    /// Wait for element to appear.
    public var elementSelector: String {
        get {
            if case let .elementSelector(v)? = condition { return v }
            return String()
        }
        set { condition = .elementSelector(newValue) }
    }

    /// Wait for window to appear.
    public var windowTitle: String {
        get {
            if case let .windowTitle(v)? = condition { return v }
            return String()
        }
        set { condition = .windowTitle(newValue) }
    }

    /// Wait for application to launch.
    public var application: String {
        get {
            if case let .application(v)? = condition { return v }
            return String()
        }
        set { condition = .application(newValue) }
    }

    /// Timeout in seconds.
    public var timeout: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Condition type.
    public enum OneOf_Condition: Equatable, Sendable {
        /// Wait for element to appear.
        case elementSelector(String)
        /// Wait for window to appear.
        case windowTitle(String)
        /// Wait for application to launch.
        case application(String)
    }

    public init() {}
}

/// Conditional action (if-then-else).
public struct Macosusesdk_V1_ConditionalAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Condition to evaluate.
    public var condition: Macosusesdk_V1_MacroCondition {
        get { _condition ?? Macosusesdk_V1_MacroCondition() }
        set { _condition = newValue }
    }

    /// Returns true if `condition` has been explicitly set.
    public var hasCondition: Bool { _condition != nil }
    /// Clears the value of `condition`. Subsequent reads from it will return its default value.
    public mutating func clearCondition() { _condition = nil }

    /// Actions to execute if condition is true.
    public var thenActions: [Macosusesdk_V1_MacroAction] = []

    /// Actions to execute if condition is false.
    public var elseActions: [Macosusesdk_V1_MacroAction] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _condition: Macosusesdk_V1_MacroCondition?
}

/// Condition for conditional actions.
public struct Macosusesdk_V1_MacroCondition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Condition type.
    public var condition: Macosusesdk_V1_MacroCondition.OneOf_Condition?

    /// Element exists.
    public var elementExists: String {
        get {
            if case let .elementExists(v)? = condition { return v }
            return String()
        }
        set { condition = .elementExists(newValue) }
    }

    /// Window exists.
    public var windowExists: String {
        get {
            if case let .windowExists(v)? = condition { return v }
            return String()
        }
        set { condition = .windowExists(newValue) }
    }

    /// Application is running.
    public var applicationRunning: String {
        get {
            if case let .applicationRunning(v)? = condition { return v }
            return String()
        }
        set { condition = .applicationRunning(newValue) }
    }

    /// Variable equals value.
    public var variableEquals: Macosusesdk_V1_VariableCondition {
        get {
            if case let .variableEquals(v)? = condition { return v }
            return Macosusesdk_V1_VariableCondition()
        }
        set { condition = .variableEquals(newValue) }
    }

    /// Compound condition.
    public var compound: Macosusesdk_V1_CompoundCondition {
        get {
            if case let .compound(v)? = condition { return v }
            return Macosusesdk_V1_CompoundCondition()
        }
        set { condition = .compound(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Condition type.
    public enum OneOf_Condition: Equatable, Sendable {
        /// Element exists.
        case elementExists(String)
        /// Window exists.
        case windowExists(String)
        /// Application is running.
        case applicationRunning(String)
        /// Variable equals value.
        case variableEquals(Macosusesdk_V1_VariableCondition)
        /// Compound condition.
        case compound(Macosusesdk_V1_CompoundCondition)
    }

    public init() {}
}

/// Variable equality condition.
public struct Macosusesdk_V1_VariableCondition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Variable name.
    public var variable: String = .init()

    /// Expected value.
    public var value: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Compound condition (AND/OR/NOT).
public struct Macosusesdk_V1_CompoundCondition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Operator.
    public var `operator`: Macosusesdk_V1_CompoundCondition.Operator = .unspecified

    /// Sub-conditions.
    public var conditions: [Macosusesdk_V1_MacroCondition] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Logical operator.
    public enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default unspecified.
        case unspecified // = 0

        /// All conditions must be true.
        case and // = 1

        /// At least one condition must be true.
        case or // = 2

        /// Condition must be false (only with single condition).
        case not // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .and
            case 2: self = .or
            case 3: self = .not
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .and: 1
            case .or: 2
            case .not: 3
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_CompoundCondition.Operator] = [
            .unspecified,
            .and,
            .or,
            .not,
        ]
    }

    public init() {}
}

/// Loop action (repeat).
public struct Macosusesdk_V1_LoopAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Loop type.
    public var loopType: Macosusesdk_V1_LoopAction.OneOf_LoopType?

    /// Fixed iteration count.
    public var count: Int32 {
        get {
            if case let .count(v)? = loopType { return v }
            return 0
        }
        set { loopType = .count(newValue) }
    }

    /// Loop while condition is true.
    public var whileCondition: Macosusesdk_V1_MacroCondition {
        get {
            if case let .whileCondition(v)? = loopType { return v }
            return Macosusesdk_V1_MacroCondition()
        }
        set { loopType = .whileCondition(newValue) }
    }

    /// Loop over each item in collection.
    public var foreach: Macosusesdk_V1_ForEachLoop {
        get {
            if case let .foreach(v)? = loopType { return v }
            return Macosusesdk_V1_ForEachLoop()
        }
        set { loopType = .foreach(newValue) }
    }

    /// Actions to execute in each iteration.
    public var actions: [Macosusesdk_V1_MacroAction] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Loop type.
    public enum OneOf_LoopType: Equatable, Sendable {
        /// Fixed iteration count.
        case count(Int32)
        /// Loop while condition is true.
        case whileCondition(Macosusesdk_V1_MacroCondition)
        /// Loop over each item in collection.
        case foreach(Macosusesdk_V1_ForEachLoop)
    }

    public init() {}
}

/// For-each loop over collection.
public struct Macosusesdk_V1_ForEachLoop: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Collection to iterate over.
    public var collection: Macosusesdk_V1_ForEachLoop.OneOf_Collection?

    /// List of elements.
    public var elementSelector: String {
        get {
            if case let .elementSelector(v)? = collection { return v }
            return String()
        }
        set { collection = .elementSelector(newValue) }
    }

    /// List of windows.
    public var windowPattern: String {
        get {
            if case let .windowPattern(v)? = collection { return v }
            return String()
        }
        set { collection = .windowPattern(newValue) }
    }

    /// List of values (newline or comma-separated).
    public var values: String {
        get {
            if case let .values(v)? = collection { return v }
            return String()
        }
        set { collection = .values(newValue) }
    }

    /// Variable name for current item.
    public var itemVariable: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Collection to iterate over.
    public enum OneOf_Collection: Equatable, Sendable {
        /// List of elements.
        case elementSelector(String)
        /// List of windows.
        case windowPattern(String)
        /// List of values (newline or comma-separated).
        case values(String)
    }

    public init() {}
}

/// Variable assignment action.
public struct Macosusesdk_V1_AssignAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Variable name.
    public var variable: String = .init()

    /// Value source.
    public var value: Macosusesdk_V1_AssignAction.OneOf_Value?

    /// Literal string value.
    public var literal: String {
        get {
            if case let .literal(v)? = value { return v }
            return String()
        }
        set { value = .literal(newValue) }
    }

    /// Value from element attribute.
    public var elementAttribute: Macosusesdk_V1_ElementAttributeValue {
        get {
            if case let .elementAttribute(v)? = value { return v }
            return Macosusesdk_V1_ElementAttributeValue()
        }
        set { value = .elementAttribute(newValue) }
    }

    /// Value from parameter.
    public var parameter: String {
        get {
            if case let .parameter(v)? = value { return v }
            return String()
        }
        set { value = .parameter(newValue) }
    }

    /// Result of expression.
    public var expression: String {
        get {
            if case let .expression(v)? = value { return v }
            return String()
        }
        set { value = .expression(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Value source.
    public enum OneOf_Value: Equatable, Sendable {
        /// Literal string value.
        case literal(String)
        /// Value from element attribute.
        case elementAttribute(Macosusesdk_V1_ElementAttributeValue)
        /// Value from parameter.
        case parameter(String)
        /// Result of expression.
        case expression(String)
    }

    public init() {}
}

/// Value from element attribute.
public struct Macosusesdk_V1_ElementAttributeValue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Element selector.
    public var elementSelector: String = .init()

    /// Attribute name.
    public var attribute: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Custom method call action.
public struct Macosusesdk_V1_MethodCall: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Method name (e.g., "ClickElement", "SetElementValue").
    public var method: String = .init()

    /// Method arguments (key-value pairs).
    public var args: [String: String] = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Macro parameter definition.
public struct Macosusesdk_V1_MacroParameter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parameter key/identifier.
    public var key: String = .init()

    /// Parameter type.
    public var type: Macosusesdk_V1_MacroParameter.ParameterType = .unspecified

    /// Default value (optional).
    public var defaultValue: String = .init()

    /// Parameter description.
    public var description_p: String = .init()

    /// Whether parameter is required.
    public var required: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Parameter type enumeration.
    public enum ParameterType: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default unspecified type.
        case unspecified // = 0

        /// String value.
        case string // = 1

        /// Integer value.
        case integer // = 2

        /// Boolean value.
        case boolean // = 3

        /// Element selector.
        case selector // = 4

        /// File path.
        case path // = 5
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .string
            case 2: self = .integer
            case 3: self = .boolean
            case 4: self = .selector
            case 5: self = .path
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .string: 1
            case .integer: 2
            case .boolean: 3
            case .selector: 4
            case .path: 5
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_MacroParameter.ParameterType] = [
            .unspecified,
            .string,
            .integer,
            .boolean,
            .selector,
            .path,
        ]
    }

    public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_Macro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Macro"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}display_name\0\u{1}description\0\u{1}actions\0\u{1}parameters\0\u{3}create_time\0\u{3}update_time\0\u{3}execution_count\0\u{1}tags\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &displayName)
            case 3: try decoder.decodeSingularStringField(value: &description_p)
            case 4: try decoder.decodeRepeatedMessageField(value: &actions)
            case 5: try decoder.decodeRepeatedMessageField(value: &parameters)
            case 6: try decoder.decodeSingularMessageField(value: &_createTime)
            case 7: try decoder.decodeSingularMessageField(value: &_updateTime)
            case 8: try decoder.decodeSingularInt64Field(value: &executionCount)
            case 9: try decoder.decodeRepeatedStringField(value: &tags)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !displayName.isEmpty {
            try visitor.visitSingularStringField(value: displayName, fieldNumber: 2)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 3)
        }
        if !actions.isEmpty {
            try visitor.visitRepeatedMessageField(value: actions, fieldNumber: 4)
        }
        if !parameters.isEmpty {
            try visitor.visitRepeatedMessageField(value: parameters, fieldNumber: 5)
        }
        try { if let v = self._createTime {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
        } }()
        try { if let v = self._updateTime {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
        } }()
        if executionCount != 0 {
            try visitor.visitSingularInt64Field(value: executionCount, fieldNumber: 8)
        }
        if !tags.isEmpty {
            try visitor.visitRepeatedStringField(value: tags, fieldNumber: 9)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_Macro, rhs: Macosusesdk_V1_Macro) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.displayName != rhs.displayName { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.actions != rhs.actions { return false }
        if lhs.parameters != rhs.parameters { return false }
        if lhs._createTime != rhs._createTime { return false }
        if lhs._updateTime != rhs._updateTime { return false }
        if lhs.executionCount != rhs.executionCount { return false }
        if lhs.tags != rhs.tags { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecutionLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecutionLogEntry"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}execution_time\0\u{3}action_index\0\u{1}description\0\u{1}success\0\u{1}error\0\u{1}duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularMessageField(value: &_executionTime)
            case 3: try decoder.decodeSingularInt32Field(value: &actionIndex)
            case 4: try decoder.decodeSingularStringField(value: &description_p)
            case 5: try decoder.decodeSingularBoolField(value: &success)
            case 6: try decoder.decodeSingularStringField(value: &error)
            case 7: try decoder.decodeSingularDoubleField(value: &duration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try { if let v = self._executionTime {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if actionIndex != 0 {
            try visitor.visitSingularInt32Field(value: actionIndex, fieldNumber: 3)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 4)
        }
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 5)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 6)
        }
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecutionLogEntry, rhs: Macosusesdk_V1_ExecutionLogEntry) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs._executionTime != rhs._executionTime { return false }
        if lhs.actionIndex != rhs.actionIndex { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.success != rhs.success { return false }
        if lhs.error != rhs.error { return false }
        if lhs.duration != rhs.duration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MacroAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MacroAction"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0\u{1}wait\0\u{1}conditional\0\u{1}loop\0\u{1}assign\0\u{3}method_call\0\u{2}\u{4}description\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Macosusesdk_V1_InputAction?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .input(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .input(v)
                    }
                }()
            case 2: try {
                    var v: Macosusesdk_V1_WaitAction?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .wait(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .wait(v)
                    }
                }()
            case 3: try {
                    var v: Macosusesdk_V1_ConditionalAction?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .conditional(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .conditional(v)
                    }
                }()
            case 4: try {
                    var v: Macosusesdk_V1_LoopAction?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .loop(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .loop(v)
                    }
                }()
            case 5: try {
                    var v: Macosusesdk_V1_AssignAction?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .assign(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .assign(v)
                    }
                }()
            case 6: try {
                    var v: Macosusesdk_V1_MethodCall?
                    var hadOneofValue = false
                    if let current = self.action {
                        hadOneofValue = true
                        if case let .methodCall(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.action = .methodCall(v)
                    }
                }()
            case 10: try decoder.decodeSingularStringField(value: &description_p)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch action {
        case .input?: try {
                guard case let .input(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .wait?: try {
                guard case let .wait(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .conditional?: try {
                guard case let .conditional(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .loop?: try {
                guard case let .loop(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .assign?: try {
                guard case let .assign(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case .methodCall?: try {
                guard case let .methodCall(v)? = self.action else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case nil: break
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MacroAction, rhs: Macosusesdk_V1_MacroAction) -> Bool {
        if lhs.action != rhs.action { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitAction"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}duration\0\u{1}condition\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularDoubleField(value: &duration)
            case 2: try decoder.decodeSingularMessageField(value: &_condition)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 1)
        }
        try { if let v = self._condition {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitAction, rhs: Macosusesdk_V1_WaitAction) -> Bool {
        if lhs.duration != rhs.duration { return false }
        if lhs._condition != rhs._condition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitCondition"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_selector\0\u{3}window_title\0\u{1}application\0\u{2}\u{7}timeout\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .elementSelector(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .windowTitle(v)
                    }
                }()
            case 3: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .application(v)
                    }
                }()
            case 10: try decoder.decodeSingularDoubleField(value: &timeout)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch condition {
        case .elementSelector?: try {
                guard case let .elementSelector(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }()
        case .windowTitle?: try {
                guard case let .windowTitle(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .application?: try {
                guard case let .application(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        if timeout.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: timeout, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitCondition, rhs: Macosusesdk_V1_WaitCondition) -> Bool {
        if lhs.condition != rhs.condition { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ConditionalAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ConditionalAction"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}condition\0\u{3}then_actions\0\u{3}else_actions\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_condition)
            case 2: try decoder.decodeRepeatedMessageField(value: &thenActions)
            case 3: try decoder.decodeRepeatedMessageField(value: &elseActions)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _condition {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !thenActions.isEmpty {
            try visitor.visitRepeatedMessageField(value: thenActions, fieldNumber: 2)
        }
        if !elseActions.isEmpty {
            try visitor.visitRepeatedMessageField(value: elseActions, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ConditionalAction, rhs: Macosusesdk_V1_ConditionalAction) -> Bool {
        if lhs._condition != rhs._condition { return false }
        if lhs.thenActions != rhs.thenActions { return false }
        if lhs.elseActions != rhs.elseActions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MacroCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MacroCondition"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_exists\0\u{3}window_exists\0\u{3}application_running\0\u{3}variable_equals\0\u{1}compound\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .elementExists(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .windowExists(v)
                    }
                }()
            case 3: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .applicationRunning(v)
                    }
                }()
            case 4: try {
                    var v: Macosusesdk_V1_VariableCondition?
                    var hadOneofValue = false
                    if let current = self.condition {
                        hadOneofValue = true
                        if case let .variableEquals(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.condition = .variableEquals(v)
                    }
                }()
            case 5: try {
                    var v: Macosusesdk_V1_CompoundCondition?
                    var hadOneofValue = false
                    if let current = self.condition {
                        hadOneofValue = true
                        if case let .compound(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.condition = .compound(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch condition {
        case .elementExists?: try {
                guard case let .elementExists(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }()
        case .windowExists?: try {
                guard case let .windowExists(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .applicationRunning?: try {
                guard case let .applicationRunning(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 3)
            }()
        case .variableEquals?: try {
                guard case let .variableEquals(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .compound?: try {
                guard case let .compound(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MacroCondition, rhs: Macosusesdk_V1_MacroCondition) -> Bool {
        if lhs.condition != rhs.condition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_VariableCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".VariableCondition"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}variable\0\u{1}value\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &variable)
            case 2: try decoder.decodeSingularStringField(value: &value)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !variable.isEmpty {
            try visitor.visitSingularStringField(value: variable, fieldNumber: 1)
        }
        if !value.isEmpty {
            try visitor.visitSingularStringField(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_VariableCondition, rhs: Macosusesdk_V1_VariableCondition) -> Bool {
        if lhs.variable != rhs.variable { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CompoundCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CompoundCondition"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}operator\0\u{1}conditions\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &self.operator)
            case 2: try decoder.decodeRepeatedMessageField(value: &conditions)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if self.operator != .unspecified {
            try visitor.visitSingularEnumField(value: self.operator, fieldNumber: 1)
        }
        if !conditions.isEmpty {
            try visitor.visitRepeatedMessageField(value: conditions, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CompoundCondition, rhs: Macosusesdk_V1_CompoundCondition) -> Bool {
        if lhs.operator != rhs.operator { return false }
        if lhs.conditions != rhs.conditions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CompoundCondition.Operator: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OPERATOR_UNSPECIFIED\0\u{1}OPERATOR_AND\0\u{1}OPERATOR_OR\0\u{1}OPERATOR_NOT\0")
}

extension Macosusesdk_V1_LoopAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".LoopAction"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{3}while_condition\0\u{1}foreach\0\u{2}\u{7}actions\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v {
                        if self.loopType != nil { try decoder.handleConflictingOneOf() }
                        self.loopType = .count(v)
                    }
                }()
            case 2: try {
                    var v: Macosusesdk_V1_MacroCondition?
                    var hadOneofValue = false
                    if let current = self.loopType {
                        hadOneofValue = true
                        if case let .whileCondition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.loopType = .whileCondition(v)
                    }
                }()
            case 3: try {
                    var v: Macosusesdk_V1_ForEachLoop?
                    var hadOneofValue = false
                    if let current = self.loopType {
                        hadOneofValue = true
                        if case let .foreach(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.loopType = .foreach(v)
                    }
                }()
            case 10: try decoder.decodeRepeatedMessageField(value: &actions)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch loopType {
        case .count?: try {
                guard case let .count(v)? = self.loopType else { preconditionFailure() }
                try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
            }()
        case .whileCondition?: try {
                guard case let .whileCondition(v)? = self.loopType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .foreach?: try {
                guard case let .foreach(v)? = self.loopType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        if !actions.isEmpty {
            try visitor.visitRepeatedMessageField(value: actions, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_LoopAction, rhs: Macosusesdk_V1_LoopAction) -> Bool {
        if lhs.loopType != rhs.loopType { return false }
        if lhs.actions != rhs.actions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ForEachLoop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ForEachLoop"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_selector\0\u{3}window_pattern\0\u{1}values\0\u{4}\u{7}item_variable\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.collection != nil { try decoder.handleConflictingOneOf() }
                        self.collection = .elementSelector(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.collection != nil { try decoder.handleConflictingOneOf() }
                        self.collection = .windowPattern(v)
                    }
                }()
            case 3: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.collection != nil { try decoder.handleConflictingOneOf() }
                        self.collection = .values(v)
                    }
                }()
            case 10: try decoder.decodeSingularStringField(value: &itemVariable)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch collection {
        case .elementSelector?: try {
                guard case let .elementSelector(v)? = self.collection else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }()
        case .windowPattern?: try {
                guard case let .windowPattern(v)? = self.collection else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .values?: try {
                guard case let .values(v)? = self.collection else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        if !itemVariable.isEmpty {
            try visitor.visitSingularStringField(value: itemVariable, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ForEachLoop, rhs: Macosusesdk_V1_ForEachLoop) -> Bool {
        if lhs.collection != rhs.collection { return false }
        if lhs.itemVariable != rhs.itemVariable { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_AssignAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AssignAction"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}variable\0\u{1}literal\0\u{3}element_attribute\0\u{1}parameter\0\u{1}expression\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &variable)
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.value != nil { try decoder.handleConflictingOneOf() }
                        self.value = .literal(v)
                    }
                }()
            case 3: try {
                    var v: Macosusesdk_V1_ElementAttributeValue?
                    var hadOneofValue = false
                    if let current = self.value {
                        hadOneofValue = true
                        if case let .elementAttribute(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.value = .elementAttribute(v)
                    }
                }()
            case 4: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.value != nil { try decoder.handleConflictingOneOf() }
                        self.value = .parameter(v)
                    }
                }()
            case 5: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.value != nil { try decoder.handleConflictingOneOf() }
                        self.value = .expression(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !variable.isEmpty {
            try visitor.visitSingularStringField(value: variable, fieldNumber: 1)
        }
        switch value {
        case .literal?: try {
                guard case let .literal(v)? = self.value else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .elementAttribute?: try {
                guard case let .elementAttribute(v)? = self.value else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .parameter?: try {
                guard case let .parameter(v)? = self.value else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 4)
            }()
        case .expression?: try {
                guard case let .expression(v)? = self.value else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_AssignAction, rhs: Macosusesdk_V1_AssignAction) -> Bool {
        if lhs.variable != rhs.variable { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ElementAttributeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ElementAttributeValue"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_selector\0\u{1}attribute\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &elementSelector)
            case 2: try decoder.decodeSingularStringField(value: &attribute)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !elementSelector.isEmpty {
            try visitor.visitSingularStringField(value: elementSelector, fieldNumber: 1)
        }
        if !attribute.isEmpty {
            try visitor.visitSingularStringField(value: attribute, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ElementAttributeValue, rhs: Macosusesdk_V1_ElementAttributeValue) -> Bool {
        if lhs.elementSelector != rhs.elementSelector { return false }
        if lhs.attribute != rhs.attribute { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MethodCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MethodCall"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}method\0\u{1}args\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &method)
            case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &args)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !method.isEmpty {
            try visitor.visitSingularStringField(value: method, fieldNumber: 1)
        }
        if !args.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: args, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MethodCall, rhs: Macosusesdk_V1_MethodCall) -> Bool {
        if lhs.method != rhs.method { return false }
        if lhs.args != rhs.args { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MacroParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MacroParameter"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}type\0\u{3}default_value\0\u{1}description\0\u{1}required\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &key)
            case 2: try decoder.decodeSingularEnumField(value: &type)
            case 3: try decoder.decodeSingularStringField(value: &defaultValue)
            case 4: try decoder.decodeSingularStringField(value: &description_p)
            case 5: try decoder.decodeSingularBoolField(value: &required)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        if type != .unspecified {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 2)
        }
        if !defaultValue.isEmpty {
            try visitor.visitSingularStringField(value: defaultValue, fieldNumber: 3)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 4)
        }
        if required != false {
            try visitor.visitSingularBoolField(value: required, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MacroParameter, rhs: Macosusesdk_V1_MacroParameter) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.type != rhs.type { return false }
        if lhs.defaultValue != rhs.defaultValue { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.required != rhs.required { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MacroParameter.ParameterType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PARAMETER_TYPE_UNSPECIFIED\0\u{1}PARAMETER_TYPE_STRING\0\u{1}PARAMETER_TYPE_INTEGER\0\u{1}PARAMETER_TYPE_BOOLEAN\0\u{1}PARAMETER_TYPE_SELECTOR\0\u{1}PARAMETER_TYPE_PATH\0")
}
