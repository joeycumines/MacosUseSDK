// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/macro.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 MacosUseSDK
//
// Macro resource for recordable action sequences

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A resource representing a recorded sequence of actions.
/// Macros can be replayed to automate repetitive tasks.
public struct Macosusesdk_V1_Macro: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name in the format "macros/{macro}"
  /// where {macro} is a unique macro identifier.
  public var name: String = String()

  /// Display name for the macro.
  public var displayName: String = String()

  /// Description of what the macro does.
  public var description_p: String = String()

  /// Sequence of actions in the macro.
  public var actions: [Macosusesdk_V1_MacroAction] = []

  /// Macro parameters (for parameterized macros).
  public var parameters: [Macosusesdk_V1_MacroParameter] = []

  /// When the macro was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// When the macro was last modified.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Number of times the macro has been executed.
  public var executionCount: Int64 = 0

  /// Tags for categorization.
  public var tags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A single action within a macro.
public struct Macosusesdk_V1_MacroAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Action type.
  public var action: Macosusesdk_V1_MacroAction.OneOf_Action? = nil

  /// Input action (click, type, etc.).
  public var input: Macosusesdk_V1_InputAction {
    get {
      if case .input(let v)? = action {return v}
      return Macosusesdk_V1_InputAction()
    }
    set {action = .input(newValue)}
  }

  /// Wait/delay action.
  public var wait: Macosusesdk_V1_WaitAction {
    get {
      if case .wait(let v)? = action {return v}
      return Macosusesdk_V1_WaitAction()
    }
    set {action = .wait(newValue)}
  }

  /// Conditional action (if-then).
  public var conditional: Macosusesdk_V1_ConditionalAction {
    get {
      if case .conditional(let v)? = action {return v}
      return Macosusesdk_V1_ConditionalAction()
    }
    set {action = .conditional(newValue)}
  }

  /// Loop action (repeat).
  public var loop: Macosusesdk_V1_LoopAction {
    get {
      if case .loop(let v)? = action {return v}
      return Macosusesdk_V1_LoopAction()
    }
    set {action = .loop(newValue)}
  }

  /// Variable assignment.
  public var assign: Macosusesdk_V1_AssignAction {
    get {
      if case .assign(let v)? = action {return v}
      return Macosusesdk_V1_AssignAction()
    }
    set {action = .assign(newValue)}
  }

  /// Custom method call.
  public var methodCall: Macosusesdk_V1_MethodCall {
    get {
      if case .methodCall(let v)? = action {return v}
      return Macosusesdk_V1_MethodCall()
    }
    set {action = .methodCall(newValue)}
  }

  /// Human-readable description of this action.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Action type.
  public enum OneOf_Action: Equatable, Sendable {
    /// Input action (click, type, etc.).
    case input(Macosusesdk_V1_InputAction)
    /// Wait/delay action.
    case wait(Macosusesdk_V1_WaitAction)
    /// Conditional action (if-then).
    case conditional(Macosusesdk_V1_ConditionalAction)
    /// Loop action (repeat).
    case loop(Macosusesdk_V1_LoopAction)
    /// Variable assignment.
    case assign(Macosusesdk_V1_AssignAction)
    /// Custom method call.
    case methodCall(Macosusesdk_V1_MethodCall)

  }

  public init() {}
}

/// Wait/delay action.
public struct Macosusesdk_V1_WaitAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Duration to wait in seconds.
  public var duration: Double = 0

  /// Optional condition to wait for.
  public var condition: Macosusesdk_V1_WaitCondition {
    get {return _condition ?? Macosusesdk_V1_WaitCondition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _condition: Macosusesdk_V1_WaitCondition? = nil
}

/// Condition to wait for.
public struct Macosusesdk_V1_WaitCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Condition type.
  public var condition: Macosusesdk_V1_WaitCondition.OneOf_Condition? = nil

  /// Wait for element to appear.
  public var elementSelector: String {
    get {
      if case .elementSelector(let v)? = condition {return v}
      return String()
    }
    set {condition = .elementSelector(newValue)}
  }

  /// Wait for window to appear.
  public var windowTitle: String {
    get {
      if case .windowTitle(let v)? = condition {return v}
      return String()
    }
    set {condition = .windowTitle(newValue)}
  }

  /// Wait for application to launch.
  public var applicationName: String {
    get {
      if case .applicationName(let v)? = condition {return v}
      return String()
    }
    set {condition = .applicationName(newValue)}
  }

  /// Timeout in seconds.
  public var timeout: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Condition type.
  public enum OneOf_Condition: Equatable, Sendable {
    /// Wait for element to appear.
    case elementSelector(String)
    /// Wait for window to appear.
    case windowTitle(String)
    /// Wait for application to launch.
    case applicationName(String)

  }

  public init() {}
}

/// Conditional action (if-then-else).
public struct Macosusesdk_V1_ConditionalAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Condition to evaluate.
  public var condition: Macosusesdk_V1_MacroCondition {
    get {return _condition ?? Macosusesdk_V1_MacroCondition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  /// Actions to execute if condition is true.
  public var thenActions: [Macosusesdk_V1_MacroAction] = []

  /// Actions to execute if condition is false.
  public var elseActions: [Macosusesdk_V1_MacroAction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _condition: Macosusesdk_V1_MacroCondition? = nil
}

/// Condition for conditional actions.
public struct Macosusesdk_V1_MacroCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Condition type.
  public var condition: Macosusesdk_V1_MacroCondition.OneOf_Condition? = nil

  /// Element exists.
  public var elementExists: String {
    get {
      if case .elementExists(let v)? = condition {return v}
      return String()
    }
    set {condition = .elementExists(newValue)}
  }

  /// Window exists.
  public var windowExists: String {
    get {
      if case .windowExists(let v)? = condition {return v}
      return String()
    }
    set {condition = .windowExists(newValue)}
  }

  /// Application is running.
  public var applicationRunning: String {
    get {
      if case .applicationRunning(let v)? = condition {return v}
      return String()
    }
    set {condition = .applicationRunning(newValue)}
  }

  /// Variable equals value.
  public var variableEquals: Macosusesdk_V1_VariableCondition {
    get {
      if case .variableEquals(let v)? = condition {return v}
      return Macosusesdk_V1_VariableCondition()
    }
    set {condition = .variableEquals(newValue)}
  }

  /// Compound condition.
  public var compound: Macosusesdk_V1_CompoundCondition {
    get {
      if case .compound(let v)? = condition {return v}
      return Macosusesdk_V1_CompoundCondition()
    }
    set {condition = .compound(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Condition type.
  public enum OneOf_Condition: Equatable, Sendable {
    /// Element exists.
    case elementExists(String)
    /// Window exists.
    case windowExists(String)
    /// Application is running.
    case applicationRunning(String)
    /// Variable equals value.
    case variableEquals(Macosusesdk_V1_VariableCondition)
    /// Compound condition.
    case compound(Macosusesdk_V1_CompoundCondition)

  }

  public init() {}
}

/// Variable equality condition.
public struct Macosusesdk_V1_VariableCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Variable name.
  public var variable: String = String()

  /// Expected value.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Compound condition (AND/OR/NOT).
public struct Macosusesdk_V1_CompoundCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operator.
  public var `operator`: Macosusesdk_V1_CompoundCondition.Operator = .unspecified

  /// Sub-conditions.
  public var conditions: [Macosusesdk_V1_MacroCondition] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Logical operator.
  public enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Default unspecified.
    case unspecified // = 0

    /// All conditions must be true.
    case and // = 1

    /// At least one condition must be true.
    case or // = 2

    /// Condition must be false (only with single condition).
    case not // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .and
      case 2: self = .or
      case 3: self = .not
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .and: return 1
      case .or: return 2
      case .not: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Macosusesdk_V1_CompoundCondition.Operator] = [
      .unspecified,
      .and,
      .or,
      .not,
    ]

  }

  public init() {}
}

/// Loop action (repeat).
public struct Macosusesdk_V1_LoopAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Loop type.
  public var loopType: Macosusesdk_V1_LoopAction.OneOf_LoopType? = nil

  /// Fixed iteration count.
  public var count: Int32 {
    get {
      if case .count(let v)? = loopType {return v}
      return 0
    }
    set {loopType = .count(newValue)}
  }

  /// Loop while condition is true.
  public var whileCondition: Macosusesdk_V1_MacroCondition {
    get {
      if case .whileCondition(let v)? = loopType {return v}
      return Macosusesdk_V1_MacroCondition()
    }
    set {loopType = .whileCondition(newValue)}
  }

  /// Loop for each item in collection.
  public var forEach: Macosusesdk_V1_ForEachLoop {
    get {
      if case .forEach(let v)? = loopType {return v}
      return Macosusesdk_V1_ForEachLoop()
    }
    set {loopType = .forEach(newValue)}
  }

  /// Actions to execute in each iteration.
  public var actions: [Macosusesdk_V1_MacroAction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Loop type.
  public enum OneOf_LoopType: Equatable, Sendable {
    /// Fixed iteration count.
    case count(Int32)
    /// Loop while condition is true.
    case whileCondition(Macosusesdk_V1_MacroCondition)
    /// Loop for each item in collection.
    case forEach(Macosusesdk_V1_ForEachLoop)

  }

  public init() {}
}

/// For-each loop over collection.
public struct Macosusesdk_V1_ForEachLoop: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collection to iterate over.
  public var collection: Macosusesdk_V1_ForEachLoop.OneOf_Collection? = nil

  /// List of elements.
  public var elementSelector: String {
    get {
      if case .elementSelector(let v)? = collection {return v}
      return String()
    }
    set {collection = .elementSelector(newValue)}
  }

  /// List of windows.
  public var windowPattern: String {
    get {
      if case .windowPattern(let v)? = collection {return v}
      return String()
    }
    set {collection = .windowPattern(newValue)}
  }

  /// List of values (newline or comma-separated).
  public var values: String {
    get {
      if case .values(let v)? = collection {return v}
      return String()
    }
    set {collection = .values(newValue)}
  }

  /// Variable name for current item.
  public var itemVariable: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Collection to iterate over.
  public enum OneOf_Collection: Equatable, Sendable {
    /// List of elements.
    case elementSelector(String)
    /// List of windows.
    case windowPattern(String)
    /// List of values (newline or comma-separated).
    case values(String)

  }

  public init() {}
}

/// Variable assignment action.
public struct Macosusesdk_V1_AssignAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Variable name.
  public var variable: String = String()

  /// Value source.
  public var value: Macosusesdk_V1_AssignAction.OneOf_Value? = nil

  /// Literal string value.
  public var literal: String {
    get {
      if case .literal(let v)? = value {return v}
      return String()
    }
    set {value = .literal(newValue)}
  }

  /// Value from element attribute.
  public var elementAttribute: Macosusesdk_V1_ElementAttributeValue {
    get {
      if case .elementAttribute(let v)? = value {return v}
      return Macosusesdk_V1_ElementAttributeValue()
    }
    set {value = .elementAttribute(newValue)}
  }

  /// Value from parameter.
  public var parameter: String {
    get {
      if case .parameter(let v)? = value {return v}
      return String()
    }
    set {value = .parameter(newValue)}
  }

  /// Result of expression.
  public var expression: String {
    get {
      if case .expression(let v)? = value {return v}
      return String()
    }
    set {value = .expression(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Value source.
  public enum OneOf_Value: Equatable, Sendable {
    /// Literal string value.
    case literal(String)
    /// Value from element attribute.
    case elementAttribute(Macosusesdk_V1_ElementAttributeValue)
    /// Value from parameter.
    case parameter(String)
    /// Result of expression.
    case expression(String)

  }

  public init() {}
}

/// Value from element attribute.
public struct Macosusesdk_V1_ElementAttributeValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Element selector.
  public var elementSelector: String = String()

  /// Attribute name.
  public var attribute: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Custom method call action.
public struct Macosusesdk_V1_MethodCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Method name (e.g., "ClickElement", "SetElementValue").
  public var method: String = String()

  /// Method arguments (key-value pairs).
  public var arguments: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Macro parameter definition.
public struct Macosusesdk_V1_MacroParameter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parameter name.
  public var name: String = String()

  /// Parameter type.
  public var type: Macosusesdk_V1_MacroParameter.ParameterType = .unspecified

  /// Default value (optional).
  public var defaultValue: String = String()

  /// Parameter description.
  public var description_p: String = String()

  /// Whether parameter is required.
  public var required: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Parameter type enumeration.
  public enum ParameterType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Default unspecified type.
    case unspecified // = 0

    /// String value.
    case string // = 1

    /// Integer value.
    case integer // = 2

    /// Boolean value.
    case boolean // = 3

    /// Element selector.
    case selector // = 4

    /// File path.
    case path // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .string
      case 2: self = .integer
      case 3: self = .boolean
      case 4: self = .selector
      case 5: self = .path
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .string: return 1
      case .integer: return 2
      case .boolean: return 3
      case .selector: return 4
      case .path: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Macosusesdk_V1_MacroParameter.ParameterType] = [
      .unspecified,
      .string,
      .integer,
      .boolean,
      .selector,
      .path,
    ]

  }

  public init() {}
}

/// Request to execute a macro (long-running operation).
public struct Macosusesdk_V1_ExecuteMacroRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Macro to execute.
  public var macro: String = String()

  /// Parameter values (for parameterized macros).
  public var parameterValues: Dictionary<String,String> = [:]

  /// Application context (if needed).
  public var application: String = String()

  /// Execution options.
  public var options: Macosusesdk_V1_ExecutionOptions {
    get {return _options ?? Macosusesdk_V1_ExecutionOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Macosusesdk_V1_ExecutionOptions? = nil
}

/// Options for macro execution.
public struct Macosusesdk_V1_ExecutionOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Execution speed multiplier (1.0 = normal speed).
  public var speed: Double = 0

  /// Whether to continue on error.
  public var continueOnError: Bool = false

  /// Maximum execution time in seconds.
  public var timeout: Double = 0

  /// Whether to record execution for debugging.
  public var recordExecution: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from executing a macro.
public struct Macosusesdk_V1_ExecuteMacroResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether execution succeeded.
  public var success: Bool = false

  /// Number of actions executed.
  public var actionsExecuted: Int32 = 0

  /// Execution time in seconds.
  public var executionTime: Double = 0

  /// Error message if failed.
  public var error: String = String()

  /// Execution log (if recording was enabled).
  public var log: [Macosusesdk_V1_ExecutionLogEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Log entry for macro execution.
public struct Macosusesdk_V1_ExecutionLogEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When the action executed.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// Action index in macro.
  public var actionIndex: Int32 = 0

  /// Action description.
  public var description_p: String = String()

  /// Whether action succeeded.
  public var success: Bool = false

  /// Error message if failed.
  public var error: String = String()

  /// Duration in seconds.
  public var duration: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata for ExecuteMacro operation.
public struct Macosusesdk_V1_ExecuteMacroMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Macro being executed.
  public var macro: String = String()

  /// Current action index.
  public var currentAction: Int32 = 0

  /// Total actions in macro.
  public var totalActions: Int32 = 0

  /// Elapsed time in seconds.
  public var elapsedTime: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_Macro: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Macro"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}display_name\0\u{1}description\0\u{1}actions\0\u{1}parameters\0\u{3}create_time\0\u{3}update_time\0\u{3}execution_count\0\u{1}tags\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.executionCount) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 4)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 5)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.executionCount != 0 {
      try visitor.visitSingularInt64Field(value: self.executionCount, fieldNumber: 8)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_Macro, rhs: Macosusesdk_V1_Macro) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.executionCount != rhs.executionCount {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_MacroAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MacroAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}input\0\u{1}wait\0\u{1}conditional\0\u{1}loop\0\u{1}assign\0\u{3}method_call\0\u{2}\u{4}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Macosusesdk_V1_InputAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .input(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .input(v)
        }
      }()
      case 2: try {
        var v: Macosusesdk_V1_WaitAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .wait(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .wait(v)
        }
      }()
      case 3: try {
        var v: Macosusesdk_V1_ConditionalAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .conditional(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .conditional(v)
        }
      }()
      case 4: try {
        var v: Macosusesdk_V1_LoopAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .loop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .loop(v)
        }
      }()
      case 5: try {
        var v: Macosusesdk_V1_AssignAction?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .assign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .assign(v)
        }
      }()
      case 6: try {
        var v: Macosusesdk_V1_MethodCall?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .methodCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .methodCall(v)
        }
      }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .input?: try {
      guard case .input(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .wait?: try {
      guard case .wait(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .conditional?: try {
      guard case .conditional(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .loop?: try {
      guard case .loop(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .assign?: try {
      guard case .assign(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .methodCall?: try {
      guard case .methodCall(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_MacroAction, rhs: Macosusesdk_V1_MacroAction) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}duration\0\u{1}condition\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 1)
    }
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitAction, rhs: Macosusesdk_V1_WaitAction) -> Bool {
    if lhs.duration != rhs.duration {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_selector\0\u{3}window_title\0\u{3}application_name\0\u{2}\u{7}timeout\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .elementSelector(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .windowTitle(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .applicationName(v)
        }
      }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.condition {
    case .elementSelector?: try {
      guard case .elementSelector(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .windowTitle?: try {
      guard case .windowTitle(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .applicationName?: try {
      guard case .applicationName(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.timeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitCondition, rhs: Macosusesdk_V1_WaitCondition) -> Bool {
    if lhs.condition != rhs.condition {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ConditionalAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConditionalAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}condition\0\u{3}then_actions\0\u{3}else_actions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.thenActions) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.elseActions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.thenActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.thenActions, fieldNumber: 2)
    }
    if !self.elseActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elseActions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ConditionalAction, rhs: Macosusesdk_V1_ConditionalAction) -> Bool {
    if lhs._condition != rhs._condition {return false}
    if lhs.thenActions != rhs.thenActions {return false}
    if lhs.elseActions != rhs.elseActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_MacroCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MacroCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_exists\0\u{3}window_exists\0\u{3}application_running\0\u{3}variable_equals\0\u{1}compound\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .elementExists(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .windowExists(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .applicationRunning(v)
        }
      }()
      case 4: try {
        var v: Macosusesdk_V1_VariableCondition?
        var hadOneofValue = false
        if let current = self.condition {
          hadOneofValue = true
          if case .variableEquals(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.condition = .variableEquals(v)
        }
      }()
      case 5: try {
        var v: Macosusesdk_V1_CompoundCondition?
        var hadOneofValue = false
        if let current = self.condition {
          hadOneofValue = true
          if case .compound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.condition = .compound(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.condition {
    case .elementExists?: try {
      guard case .elementExists(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .windowExists?: try {
      guard case .windowExists(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .applicationRunning?: try {
      guard case .applicationRunning(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .variableEquals?: try {
      guard case .variableEquals(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .compound?: try {
      guard case .compound(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_MacroCondition, rhs: Macosusesdk_V1_MacroCondition) -> Bool {
    if lhs.condition != rhs.condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_VariableCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariableCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}variable\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variable) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variable.isEmpty {
      try visitor.visitSingularStringField(value: self.variable, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_VariableCondition, rhs: Macosusesdk_V1_VariableCondition) -> Bool {
    if lhs.variable != rhs.variable {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_CompoundCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompoundCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}operator\0\u{1}conditions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`operator`) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`operator` != .unspecified {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 1)
    }
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_CompoundCondition, rhs: Macosusesdk_V1_CompoundCondition) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_CompoundCondition.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OPERATOR_UNSPECIFIED\0\u{1}OPERATOR_AND\0\u{1}OPERATOR_OR\0\u{1}OPERATOR_NOT\0")
}

extension Macosusesdk_V1_LoopAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoopAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{3}while_condition\0\u{3}for_each\0\u{2}\u{7}actions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.loopType != nil {try decoder.handleConflictingOneOf()}
          self.loopType = .count(v)
        }
      }()
      case 2: try {
        var v: Macosusesdk_V1_MacroCondition?
        var hadOneofValue = false
        if let current = self.loopType {
          hadOneofValue = true
          if case .whileCondition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.loopType = .whileCondition(v)
        }
      }()
      case 3: try {
        var v: Macosusesdk_V1_ForEachLoop?
        var hadOneofValue = false
        if let current = self.loopType {
          hadOneofValue = true
          if case .forEach(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.loopType = .forEach(v)
        }
      }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.loopType {
    case .count?: try {
      guard case .count(let v)? = self.loopType else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .whileCondition?: try {
      guard case .whileCondition(let v)? = self.loopType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .forEach?: try {
      guard case .forEach(let v)? = self.loopType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_LoopAction, rhs: Macosusesdk_V1_LoopAction) -> Bool {
    if lhs.loopType != rhs.loopType {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ForEachLoop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForEachLoop"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_selector\0\u{3}window_pattern\0\u{1}values\0\u{4}\u{7}item_variable\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.collection != nil {try decoder.handleConflictingOneOf()}
          self.collection = .elementSelector(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.collection != nil {try decoder.handleConflictingOneOf()}
          self.collection = .windowPattern(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.collection != nil {try decoder.handleConflictingOneOf()}
          self.collection = .values(v)
        }
      }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.itemVariable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.collection {
    case .elementSelector?: try {
      guard case .elementSelector(let v)? = self.collection else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .windowPattern?: try {
      guard case .windowPattern(let v)? = self.collection else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .values?: try {
      guard case .values(let v)? = self.collection else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.itemVariable.isEmpty {
      try visitor.visitSingularStringField(value: self.itemVariable, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ForEachLoop, rhs: Macosusesdk_V1_ForEachLoop) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.itemVariable != rhs.itemVariable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_AssignAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssignAction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}variable\0\u{1}literal\0\u{3}element_attribute\0\u{1}parameter\0\u{1}expression\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variable) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .literal(v)
        }
      }()
      case 3: try {
        var v: Macosusesdk_V1_ElementAttributeValue?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .elementAttribute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .elementAttribute(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .parameter(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .expression(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.variable.isEmpty {
      try visitor.visitSingularStringField(value: self.variable, fieldNumber: 1)
    }
    switch self.value {
    case .literal?: try {
      guard case .literal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .elementAttribute?: try {
      guard case .elementAttribute(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .parameter?: try {
      guard case .parameter(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .expression?: try {
      guard case .expression(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_AssignAction, rhs: Macosusesdk_V1_AssignAction) -> Bool {
    if lhs.variable != rhs.variable {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ElementAttributeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ElementAttributeValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}element_selector\0\u{1}attribute\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.elementSelector) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attribute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elementSelector.isEmpty {
      try visitor.visitSingularStringField(value: self.elementSelector, fieldNumber: 1)
    }
    if !self.attribute.isEmpty {
      try visitor.visitSingularStringField(value: self.attribute, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ElementAttributeValue, rhs: Macosusesdk_V1_ElementAttributeValue) -> Bool {
    if lhs.elementSelector != rhs.elementSelector {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_MethodCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MethodCall"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}method\0\u{1}arguments\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.arguments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.arguments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_MethodCall, rhs: Macosusesdk_V1_MethodCall) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_MacroParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MacroParameter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}type\0\u{3}default_value\0\u{1}description\0\u{1}required\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_MacroParameter, rhs: Macosusesdk_V1_MacroParameter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.required != rhs.required {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_MacroParameter.ParameterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PARAMETER_TYPE_UNSPECIFIED\0\u{1}PARAMETER_TYPE_STRING\0\u{1}PARAMETER_TYPE_INTEGER\0\u{1}PARAMETER_TYPE_BOOLEAN\0\u{1}PARAMETER_TYPE_SELECTOR\0\u{1}PARAMETER_TYPE_PATH\0")
}

extension Macosusesdk_V1_ExecuteMacroRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteMacroRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}macro\0\u{3}parameter_values\0\u{1}application\0\u{1}options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.macro) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.parameterValues) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.macro.isEmpty {
      try visitor.visitSingularStringField(value: self.macro, fieldNumber: 1)
    }
    if !self.parameterValues.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.parameterValues, fieldNumber: 2)
    }
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 3)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ExecuteMacroRequest, rhs: Macosusesdk_V1_ExecuteMacroRequest) -> Bool {
    if lhs.macro != rhs.macro {return false}
    if lhs.parameterValues != rhs.parameterValues {return false}
    if lhs.application != rhs.application {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}speed\0\u{3}continue_on_error\0\u{1}timeout\0\u{3}record_execution\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.speed) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.continueOnError) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.timeout) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.recordExecution) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.speed.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.speed, fieldNumber: 1)
    }
    if self.continueOnError != false {
      try visitor.visitSingularBoolField(value: self.continueOnError, fieldNumber: 2)
    }
    if self.timeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 3)
    }
    if self.recordExecution != false {
      try visitor.visitSingularBoolField(value: self.recordExecution, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ExecutionOptions, rhs: Macosusesdk_V1_ExecutionOptions) -> Bool {
    if lhs.speed != rhs.speed {return false}
    if lhs.continueOnError != rhs.continueOnError {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.recordExecution != rhs.recordExecution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ExecuteMacroResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteMacroResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}actions_executed\0\u{3}execution_time\0\u{1}error\0\u{1}log\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.actionsExecuted) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.executionTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.log) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.actionsExecuted != 0 {
      try visitor.visitSingularInt32Field(value: self.actionsExecuted, fieldNumber: 2)
    }
    if self.executionTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.executionTime, fieldNumber: 3)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 4)
    }
    if !self.log.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.log, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ExecuteMacroResponse, rhs: Macosusesdk_V1_ExecuteMacroResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.actionsExecuted != rhs.actionsExecuted {return false}
    if lhs.executionTime != rhs.executionTime {return false}
    if lhs.error != rhs.error {return false}
    if lhs.log != rhs.log {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ExecutionLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionLogEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}timestamp\0\u{3}action_index\0\u{1}description\0\u{1}success\0\u{1}error\0\u{1}duration\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.actionIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.error) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.actionIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.actionIndex, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 4)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 5)
    }
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ExecutionLogEntry, rhs: Macosusesdk_V1_ExecutionLogEntry) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.actionIndex != rhs.actionIndex {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ExecuteMacroMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteMacroMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}macro\0\u{3}current_action\0\u{3}total_actions\0\u{3}elapsed_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.macro) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.currentAction) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalActions) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.elapsedTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.macro.isEmpty {
      try visitor.visitSingularStringField(value: self.macro, fieldNumber: 1)
    }
    if self.currentAction != 0 {
      try visitor.visitSingularInt32Field(value: self.currentAction, fieldNumber: 2)
    }
    if self.totalActions != 0 {
      try visitor.visitSingularInt32Field(value: self.totalActions, fieldNumber: 3)
    }
    if self.elapsedTime.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.elapsedTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ExecuteMacroMetadata, rhs: Macosusesdk_V1_ExecuteMacroMetadata) -> Bool {
    if lhs.macro != rhs.macro {return false}
    if lhs.currentAction != rhs.currentAction {return false}
    if lhs.totalActions != rhs.totalActions {return false}
    if lhs.elapsedTime != rhs.elapsedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
