// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/window.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 Joseph Cumines
//
// Window resource definition

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// A resource representing an individual window within an application.
public struct Macosusesdk_V1_Window: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name in the format "applications/{application}/windows/{window}"
    /// where {application} is the process ID and {window} is the window ID.
    public var name: String {
        get { _storage._name }
        set { _uniqueStorage()._name = newValue }
    }

    /// The title of the window.
    public var title: String {
        get { _storage._title }
        set { _uniqueStorage()._title = newValue }
    }

    /// Bounding rectangle of the window.
    public var bounds: Macosusesdk_V1_Bounds {
        get { _storage._bounds ?? Macosusesdk_V1_Bounds() }
        set { _uniqueStorage()._bounds = newValue }
    }

    /// Returns true if `bounds` has been explicitly set.
    public var hasBounds: Bool { _storage._bounds != nil }
    /// Clears the value of `bounds`. Subsequent reads from it will return its default value.
    public mutating func clearBounds() { _uniqueStorage()._bounds = nil }

    /// Z-order index (higher values are in front).
    public var zIndex: Int32 {
        get { _storage._zIndex }
        set { _uniqueStorage()._zIndex = newValue }
    }

    /// Whether the window is currently visible.
    public var visible: Bool {
        get { _storage._visible }
        set { _uniqueStorage()._visible = newValue }
    }

    /// Whether the window is minimized.
    public var minimized: Bool {
        get { _storage._minimized }
        set { _uniqueStorage()._minimized = newValue }
    }

    /// Whether the window is focused.
    /// Optional: unset if state is unknown (accessibility query failed).
    public var focused: Bool {
        get { _storage._focused ?? false }
        set { _uniqueStorage()._focused = newValue }
    }

    /// Returns true if `focused` has been explicitly set.
    public var hasFocused: Bool { _storage._focused != nil }
    /// Clears the value of `focused`. Subsequent reads from it will return its default value.
    public mutating func clearFocused() { _uniqueStorage()._focused = nil }

    /// Whether the window is in full-screen mode.
    /// Optional: unset if state is unknown (accessibility query failed).
    public var fullscreen: Bool {
        get { _storage._fullscreen ?? false }
        set { _uniqueStorage()._fullscreen = newValue }
    }

    /// Returns true if `fullscreen` has been explicitly set.
    public var hasFullscreen: Bool { _storage._fullscreen != nil }
    /// Clears the value of `fullscreen`. Subsequent reads from it will return its default value.
    public mutating func clearFullscreen() { _uniqueStorage()._fullscreen = nil }

    /// Window attributes and state.
    public var state: Macosusesdk_V1_WindowState {
        get { _storage._state ?? Macosusesdk_V1_WindowState() }
        set { _uniqueStorage()._state = newValue }
    }

    /// Returns true if `state` has been explicitly set.
    public var hasState: Bool { _storage._state != nil }
    /// Clears the value of `state`. Subsequent reads from it will return its default value.
    public mutating func clearState() { _uniqueStorage()._state = nil }

    /// Bundle identifier of the application that owns this window.
    /// Resolved via NSRunningApplication. Empty string if unavailable.
    public var bundleID: String {
        get { _storage._bundleID }
        set { _uniqueStorage()._bundleID = newValue }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// Bounding rectangle for window positioning.
public struct Macosusesdk_V1_Bounds: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// X coordinate of the window's origin.
    public var x: Double = 0

    /// Y coordinate of the window's origin.
    public var y: Double = 0

    /// Width of the window.
    public var width: Double = 0

    /// Height of the window.
    public var height: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// State information about a window.
public struct Macosusesdk_V1_WindowState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the window can be resized.
    public var resizable: Bool = false

    /// Whether the window can be minimized.
    public var minimizable: Bool = false

    /// Whether the window can be closed.
    public var closable: Bool = false

    /// Whether the window is a modal dialog.
    public var modal: Bool = false

    /// Whether the window is a floating window.
    public var floating: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_Window: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Window"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}title\0\u{1}bounds\0\u{3}z_index\0\u{1}visible\0\u{1}minimized\0\u{1}focused\0\u{1}fullscreen\0\u{1}state\0\u{3}bundle_id\0")

    fileprivate class _StorageClass {
        var _name: String = .init()
        var _title: String = .init()
        var _bounds: Macosusesdk_V1_Bounds?
        var _zIndex: Int32 = 0
        var _visible: Bool = false
        var _minimized: Bool = false
        var _focused: Bool?
        var _fullscreen: Bool?
        var _state: Macosusesdk_V1_WindowState?
        var _bundleID: String = .init()

        // This property is used as the initial default value for new instances of the type.
        // The type itself is protecting the reference to its storage via CoW semantics.
        // This will force a copy to be made of this reference when the first mutation occurs;
        // hence, it is safe to mark this as `nonisolated(unsafe)`.
        nonisolated(unsafe) static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _name = source._name
            _title = source._title
            _bounds = source._bounds
            _zIndex = source._zIndex
            _visible = source._visible
            _minimized = source._minimized
            _focused = source._focused
            _fullscreen = source._fullscreen
            _state = source._state
            _bundleID = source._bundleID
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._name)
                case 2: try decoder.decodeSingularStringField(value: &_storage._title)
                case 3: try decoder.decodeSingularMessageField(value: &_storage._bounds)
                case 4: try decoder.decodeSingularInt32Field(value: &_storage._zIndex)
                case 5: try decoder.decodeSingularBoolField(value: &_storage._visible)
                case 6: try decoder.decodeSingularBoolField(value: &_storage._minimized)
                case 7: try decoder.decodeSingularBoolField(value: &_storage._focused)
                case 8: try decoder.decodeSingularBoolField(value: &_storage._fullscreen)
                case 9: try decoder.decodeSingularMessageField(value: &_storage._state)
                case 10: try decoder.decodeSingularStringField(value: &_storage._bundleID)
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._name.isEmpty {
                try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
            }
            if !_storage._title.isEmpty {
                try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
            }
            try { if let v = _storage._bounds {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
            if _storage._zIndex != 0 {
                try visitor.visitSingularInt32Field(value: _storage._zIndex, fieldNumber: 4)
            }
            if _storage._visible != false {
                try visitor.visitSingularBoolField(value: _storage._visible, fieldNumber: 5)
            }
            if _storage._minimized != false {
                try visitor.visitSingularBoolField(value: _storage._minimized, fieldNumber: 6)
            }
            try { if let v = _storage._focused {
                try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
            } }()
            try { if let v = _storage._fullscreen {
                try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
            } }()
            try { if let v = _storage._state {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
            } }()
            if !_storage._bundleID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._bundleID, fieldNumber: 10)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_Window, rhs: Macosusesdk_V1_Window) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._name != rhs_storage._name { return false }
                if _storage._title != rhs_storage._title { return false }
                if _storage._bounds != rhs_storage._bounds { return false }
                if _storage._zIndex != rhs_storage._zIndex { return false }
                if _storage._visible != rhs_storage._visible { return false }
                if _storage._minimized != rhs_storage._minimized { return false }
                if _storage._focused != rhs_storage._focused { return false }
                if _storage._fullscreen != rhs_storage._fullscreen { return false }
                if _storage._state != rhs_storage._state { return false }
                if _storage._bundleID != rhs_storage._bundleID { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_Bounds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Bounds"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularDoubleField(value: &x)
            case 2: try decoder.decodeSingularDoubleField(value: &y)
            case 3: try decoder.decodeSingularDoubleField(value: &width)
            case 4: try decoder.decodeSingularDoubleField(value: &height)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if x.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: x, fieldNumber: 1)
        }
        if y.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: y, fieldNumber: 2)
        }
        if width.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: width, fieldNumber: 3)
        }
        if height.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: height, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_Bounds, rhs: Macosusesdk_V1_Bounds) -> Bool {
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WindowState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WindowState"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}resizable\0\u{1}minimizable\0\u{1}closable\0\u{1}modal\0\u{1}floating\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &resizable)
            case 2: try decoder.decodeSingularBoolField(value: &minimizable)
            case 3: try decoder.decodeSingularBoolField(value: &closable)
            case 4: try decoder.decodeSingularBoolField(value: &modal)
            case 5: try decoder.decodeSingularBoolField(value: &floating)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if resizable != false {
            try visitor.visitSingularBoolField(value: resizable, fieldNumber: 1)
        }
        if minimizable != false {
            try visitor.visitSingularBoolField(value: minimizable, fieldNumber: 2)
        }
        if closable != false {
            try visitor.visitSingularBoolField(value: closable, fieldNumber: 3)
        }
        if modal != false {
            try visitor.visitSingularBoolField(value: modal, fieldNumber: 4)
        }
        if floating != false {
            try visitor.visitSingularBoolField(value: floating, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WindowState, rhs: Macosusesdk_V1_WindowState) -> Bool {
        if lhs.resizable != rhs.resizable { return false }
        if lhs.minimizable != rhs.minimizable { return false }
        if lhs.closable != rhs.closable { return false }
        if lhs.modal != rhs.modal { return false }
        if lhs.floating != rhs.floating { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
