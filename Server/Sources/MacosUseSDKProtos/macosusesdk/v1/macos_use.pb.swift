// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/macos_use.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 MacosUseSDK
//
// MacosUse service definition

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// Request to open an application.
public struct Macosusesdk_V1_OpenApplicationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identifier (name, bundle ID, or path) of the application to open.
    /// Examples: "Calculator", "com.apple.calculator", "/Applications/Calculator.app"
    public var id: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from opening an application.
public struct Macosusesdk_V1_OpenApplicationResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The application resource that was opened.
    public var application: Macosusesdk_V1_Application {
        get { _application ?? Macosusesdk_V1_Application() }
        set { _application = newValue }
    }

    /// Returns true if `application` has been explicitly set.
    public var hasApplication: Bool { _application != nil }
    /// Clears the value of `application`. Subsequent reads from it will return its default value.
    public mutating func clearApplication() { _application = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _application: Macosusesdk_V1_Application?
}

/// Metadata for OpenApplication long-running operation.
public struct Macosusesdk_V1_OpenApplicationMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identifier being opened.
    public var id: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to get an application.
public struct Macosusesdk_V1_GetApplicationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the application.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to list applications.
public struct Macosusesdk_V1_ListApplicationsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Maximum number of applications to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous ListApplications call.
    public var pageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from listing applications.
public struct Macosusesdk_V1_ListApplicationsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The applications.
    public var applications: [Macosusesdk_V1_Application] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to delete an application.
public struct Macosusesdk_V1_DeleteApplicationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the application.
    public var name: String = .init()

    /// If set to true, any pending inputs for this application will also be deleted.
    public var force: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to create an input.
public struct Macosusesdk_V1_CreateInputRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent resource. Either "applications/{application}" or "" for desktop inputs.
    public var parent: String {
        get { _storage._parent }
        set { _uniqueStorage()._parent = newValue }
    }

    /// The input to create.
    public var input: Macosusesdk_V1_Input {
        get { _storage._input ?? Macosusesdk_V1_Input() }
        set { _uniqueStorage()._input = newValue }
    }

    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool { _storage._input != nil }
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() { _uniqueStorage()._input = nil }

    /// Optional input ID. If not provided, the server generates one.
    public var inputID: String {
        get { _storage._inputID }
        set { _uniqueStorage()._inputID = newValue }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to get an input.
public struct Macosusesdk_V1_GetInputRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the input.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to list inputs.
public struct Macosusesdk_V1_ListInputsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent resource. Either "applications/{application}" or "" for desktop inputs.
    public var parent: String = .init()

    /// Maximum number of inputs to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous ListInputs call.
    public var pageToken: String = .init()

    /// Filter inputs by state. Valid values: PENDING, EXECUTING, COMPLETED, FAILED.
    public var filter: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from listing inputs.
public struct Macosusesdk_V1_ListInputsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The inputs.
    public var inputs: [Macosusesdk_V1_Input] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to traverse accessibility tree.
public struct Macosusesdk_V1_TraverseAccessibilityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the application.
    public var name: String = .init()

    /// Whether to return only visible elements.
    public var visibleOnly: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from traversing accessibility tree.
public struct Macosusesdk_V1_TraverseAccessibilityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the application.
    public var app: String = .init()

    /// Elements found in the traversal.
    public var elements: [Macosusesdk_Type_Element] = []

    /// Statistics about the traversal.
    public var stats: Macosusesdk_Type_TraversalStats {
        get { _stats ?? Macosusesdk_Type_TraversalStats() }
        set { _stats = newValue }
    }

    /// Returns true if `stats` has been explicitly set.
    public var hasStats: Bool { _stats != nil }
    /// Clears the value of `stats`. Subsequent reads from it will return its default value.
    public mutating func clearStats() { _stats = nil }

    /// Processing time.
    public var processingTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _processingTime ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _processingTime = newValue }
    }

    /// Returns true if `processingTime` has been explicitly set.
    public var hasProcessingTime: Bool { _processingTime != nil }
    /// Clears the value of `processingTime`. Subsequent reads from it will return its default value.
    public mutating func clearProcessingTime() { _processingTime = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _stats: Macosusesdk_Type_TraversalStats?
    fileprivate var _processingTime: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// Request to watch accessibility changes.
public struct Macosusesdk_V1_WatchAccessibilityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the application.
    public var name: String = .init()

    /// Poll interval in seconds.
    public var pollInterval: Double = 0

    /// Whether to return only visible elements.
    public var visibleOnly: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response streamed from watching accessibility.
public struct Macosusesdk_V1_WatchAccessibilityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Elements added since last update.
    public var added: [Macosusesdk_Type_Element] = []

    /// Elements removed since last update.
    public var removed: [Macosusesdk_Type_Element] = []

    /// Elements modified since last update.
    public var modified: [Macosusesdk_V1_ModifiedElement] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// An element that was modified.
public struct Macosusesdk_V1_ModifiedElement: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The element before modification.
    public var oldElement: Macosusesdk_Type_Element {
        get { _storage._oldElement ?? Macosusesdk_Type_Element() }
        set { _uniqueStorage()._oldElement = newValue }
    }

    /// Returns true if `oldElement` has been explicitly set.
    public var hasOldElement: Bool { _storage._oldElement != nil }
    /// Clears the value of `oldElement`. Subsequent reads from it will return its default value.
    public mutating func clearOldElement() { _uniqueStorage()._oldElement = nil }

    /// The element after modification.
    public var newElement: Macosusesdk_Type_Element {
        get { _storage._newElement ?? Macosusesdk_Type_Element() }
        set { _uniqueStorage()._newElement = newValue }
    }

    /// Returns true if `newElement` has been explicitly set.
    public var hasNewElement: Bool { _storage._newElement != nil }
    /// Clears the value of `newElement`. Subsequent reads from it will return its default value.
    public mutating func clearNewElement() { _uniqueStorage()._newElement = nil }

    /// List of changed attributes (uses AttributeChange from observation.proto).
    public var changes: [Macosusesdk_V1_AttributeChange] {
        get { _storage._changes }
        set { _uniqueStorage()._changes = newValue }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
}

/// ===== Element Messages =====
/// Request to find elements matching a selector.
public struct Macosusesdk_V1_FindElementsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context. Either:
    /// - "applications/{application}" to search within an app
    /// - "applications/{application}/windows/{window}" to search within a window
    public var parent: String = .init()

    /// Selector for finding elements.
    public var selector: Macosusesdk_Type_ElementSelector {
        get { _selector ?? Macosusesdk_Type_ElementSelector() }
        set { _selector = newValue }
    }

    /// Returns true if `selector` has been explicitly set.
    public var hasSelector: Bool { _selector != nil }
    /// Clears the value of `selector`. Subsequent reads from it will return its default value.
    public mutating func clearSelector() { _selector = nil }

    /// Maximum number of elements to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous FindElements call.
    public var pageToken: String = .init()

    /// Whether to search only visible elements.
    public var visibleOnly: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _selector: Macosusesdk_Type_ElementSelector?
}

/// Response from finding elements.
public struct Macosusesdk_V1_FindElementsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Elements matching the selector.
    public var elements: [Macosusesdk_Type_Element] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to find elements within a screen region.
public struct Macosusesdk_V1_FindRegionElementsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context (same as FindElementsRequest).
    public var parent: String = .init()

    /// Region to search within (screen coordinates).
    public var region: Macosusesdk_Type_Region {
        get { _region ?? Macosusesdk_Type_Region() }
        set { _region = newValue }
    }

    /// Returns true if `region` has been explicitly set.
    public var hasRegion: Bool { _region != nil }
    /// Clears the value of `region`. Subsequent reads from it will return its default value.
    public mutating func clearRegion() { _region = nil }

    /// Optional selector for additional filtering.
    public var selector: Macosusesdk_Type_ElementSelector {
        get { _selector ?? Macosusesdk_Type_ElementSelector() }
        set { _selector = newValue }
    }

    /// Returns true if `selector` has been explicitly set.
    public var hasSelector: Bool { _selector != nil }
    /// Clears the value of `selector`. Subsequent reads from it will return its default value.
    public mutating func clearSelector() { _selector = nil }

    /// Maximum number of elements to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous call.
    public var pageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _region: Macosusesdk_Type_Region?
    fileprivate var _selector: Macosusesdk_Type_ElementSelector?
}

/// Response from finding elements in a region.
public struct Macosusesdk_V1_FindRegionElementsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Elements within the region.
    public var elements: [Macosusesdk_Type_Element] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to get a specific element by its resource name.
public struct Macosusesdk_V1_GetElementRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the element to retrieve.
    /// Format: applications/{application}/elements/{element}
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to click an element.
public struct Macosusesdk_V1_ClickElementRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context.
    public var parent: String = .init()

    /// Element ID or selector.
    public var target: Macosusesdk_V1_ClickElementRequest.OneOf_Target?

    /// Element ID to click.
    public var elementID: String {
        get {
            if case let .elementID(v)? = target { return v }
            return String()
        }
        set { target = .elementID(newValue) }
    }

    /// Selector to find element to click.
    public var selector: Macosusesdk_Type_ElementSelector {
        get {
            if case let .selector(v)? = target { return v }
            return Macosusesdk_Type_ElementSelector()
        }
        set { target = .selector(newValue) }
    }

    /// Click type (single, double, right-click).
    public var clickType: Macosusesdk_V1_ClickElementRequest.ClickType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Element ID or selector.
    public enum OneOf_Target: Equatable, Sendable {
        /// Element ID to click.
        case elementID(String)
        /// Selector to find element to click.
        case selector(Macosusesdk_Type_ElementSelector)
    }

    /// Click type enumeration.
    public enum ClickType: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default single click.
        case unspecified // = 0

        /// Single left-click.
        case single // = 1

        /// Double-click.
        case double // = 2

        /// Right-click.
        case right // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .single
            case 2: self = .double
            case 3: self = .right
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .single: 1
            case .double: 2
            case .right: 3
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_ClickElementRequest.ClickType] = [
            .unspecified,
            .single,
            .double,
            .right,
        ]
    }

    public init() {}
}

/// Response from clicking an element.
public struct Macosusesdk_V1_ClickElementResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the click was successful.
    public var success: Bool = false

    /// The element that was clicked.
    public var element: Macosusesdk_Type_Element {
        get { _element ?? Macosusesdk_Type_Element() }
        set { _element = newValue }
    }

    /// Returns true if `element` has been explicitly set.
    public var hasElement: Bool { _element != nil }
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    public mutating func clearElement() { _element = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _element: Macosusesdk_Type_Element?
}

/// Request to write an element's value.
public struct Macosusesdk_V1_WriteElementValueRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context.
    public var parent: String = .init()

    /// Element ID or selector.
    public var target: Macosusesdk_V1_WriteElementValueRequest.OneOf_Target?

    /// Element ID to modify.
    public var elementID: String {
        get {
            if case let .elementID(v)? = target { return v }
            return String()
        }
        set { target = .elementID(newValue) }
    }

    /// Selector to find element to modify.
    public var selector: Macosusesdk_Type_ElementSelector {
        get {
            if case let .selector(v)? = target { return v }
            return Macosusesdk_Type_ElementSelector()
        }
        set { target = .selector(newValue) }
    }

    /// Value to write.
    public var value: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Element ID or selector.
    public enum OneOf_Target: Equatable, Sendable {
        /// Element ID to modify.
        case elementID(String)
        /// Selector to find element to modify.
        case selector(Macosusesdk_Type_ElementSelector)
    }

    public init() {}
}

/// Response from writing an element's value.
public struct Macosusesdk_V1_WriteElementValueResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation was successful.
    public var success: Bool = false

    /// The element that was modified.
    public var element: Macosusesdk_Type_Element {
        get { _element ?? Macosusesdk_Type_Element() }
        set { _element = newValue }
    }

    /// Returns true if `element` has been explicitly set.
    public var hasElement: Bool { _element != nil }
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    public mutating func clearElement() { _element = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _element: Macosusesdk_Type_Element?
}

/// Request to get available actions for an element.
public struct Macosusesdk_V1_GetElementActionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the element to get actions for.
    /// Format: applications/{application}/elements/{element}
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Available actions for an element.
public struct Macosusesdk_V1_ElementActions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Available action names.
    public var actions: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to perform an accessibility action on an element.
public struct Macosusesdk_V1_PerformElementActionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context.
    public var parent: String = .init()

    /// Element ID or selector.
    public var target: Macosusesdk_V1_PerformElementActionRequest.OneOf_Target?

    /// Element ID.
    public var elementID: String {
        get {
            if case let .elementID(v)? = target { return v }
            return String()
        }
        set { target = .elementID(newValue) }
    }

    /// Selector to find element.
    public var selector: Macosusesdk_Type_ElementSelector {
        get {
            if case let .selector(v)? = target { return v }
            return Macosusesdk_Type_ElementSelector()
        }
        set { target = .selector(newValue) }
    }

    /// Action name to perform.
    public var action: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Element ID or selector.
    public enum OneOf_Target: Equatable, Sendable {
        /// Element ID.
        case elementID(String)
        /// Selector to find element.
        case selector(Macosusesdk_Type_ElementSelector)
    }

    public init() {}
}

/// Response from performing an element action.
public struct Macosusesdk_V1_PerformElementActionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the action was successful.
    public var success: Bool = false

    /// The element.
    public var element: Macosusesdk_Type_Element {
        get { _element ?? Macosusesdk_Type_Element() }
        set { _element = newValue }
    }

    /// Returns true if `element` has been explicitly set.
    public var hasElement: Bool { _element != nil }
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    public mutating func clearElement() { _element = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _element: Macosusesdk_Type_Element?
}

/// Request to wait for an element to appear (long-running operation).
public struct Macosusesdk_V1_WaitElementRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context.
    public var parent: String = .init()

    /// Selector for the element to wait for.
    public var selector: Macosusesdk_Type_ElementSelector {
        get { _selector ?? Macosusesdk_Type_ElementSelector() }
        set { _selector = newValue }
    }

    /// Returns true if `selector` has been explicitly set.
    public var hasSelector: Bool { _selector != nil }
    /// Clears the value of `selector`. Subsequent reads from it will return its default value.
    public mutating func clearSelector() { _selector = nil }

    /// Maximum time to wait in seconds (default: 30).
    public var timeout: Double = 0

    /// Poll interval in seconds (default: 0.5).
    public var pollInterval: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _selector: Macosusesdk_Type_ElementSelector?
}

/// Response from waiting for an element.
public struct Macosusesdk_V1_WaitElementResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The element that appeared.
    public var element: Macosusesdk_Type_Element {
        get { _element ?? Macosusesdk_Type_Element() }
        set { _element = newValue }
    }

    /// Returns true if `element` has been explicitly set.
    public var hasElement: Bool { _element != nil }
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    public mutating func clearElement() { _element = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _element: Macosusesdk_Type_Element?
}

/// Metadata for WaitElement long-running operation.
public struct Macosusesdk_V1_WaitElementMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The selector being waited for.
    public var selector: Macosusesdk_Type_ElementSelector {
        get { _selector ?? Macosusesdk_Type_ElementSelector() }
        set { _selector = newValue }
    }

    /// Returns true if `selector` has been explicitly set.
    public var hasSelector: Bool { _selector != nil }
    /// Clears the value of `selector`. Subsequent reads from it will return its default value.
    public mutating func clearSelector() { _selector = nil }

    /// Number of poll attempts so far.
    public var attempts: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _selector: Macosusesdk_Type_ElementSelector?
}

/// Request to wait for an element to reach a specific state.
public struct Macosusesdk_V1_WaitElementStateRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context.
    public var parent: String = .init()

    /// Element ID or selector.
    public var target: Macosusesdk_V1_WaitElementStateRequest.OneOf_Target?

    /// Element ID.
    public var elementID: String {
        get {
            if case let .elementID(v)? = target { return v }
            return String()
        }
        set { target = .elementID(newValue) }
    }

    /// Selector to find element.
    public var selector: Macosusesdk_Type_ElementSelector {
        get {
            if case let .selector(v)? = target { return v }
            return Macosusesdk_Type_ElementSelector()
        }
        set { target = .selector(newValue) }
    }

    /// State condition to wait for.
    public var condition: Macosusesdk_V1_StateCondition {
        get { _condition ?? Macosusesdk_V1_StateCondition() }
        set { _condition = newValue }
    }

    /// Returns true if `condition` has been explicitly set.
    public var hasCondition: Bool { _condition != nil }
    /// Clears the value of `condition`. Subsequent reads from it will return its default value.
    public mutating func clearCondition() { _condition = nil }

    /// Maximum time to wait in seconds (default: 30).
    public var timeout: Double = 0

    /// Poll interval in seconds (default: 0.5).
    public var pollInterval: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Element ID or selector.
    public enum OneOf_Target: Equatable, Sendable {
        /// Element ID.
        case elementID(String)
        /// Selector to find element.
        case selector(Macosusesdk_Type_ElementSelector)
    }

    public init() {}

    fileprivate var _condition: Macosusesdk_V1_StateCondition?
}

/// State condition for waiting.
public struct Macosusesdk_V1_StateCondition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Condition type.
    public var condition: Macosusesdk_V1_StateCondition.OneOf_Condition?

    /// Wait for element to be enabled.
    public var enabled: Bool {
        get {
            if case let .enabled(v)? = condition { return v }
            return false
        }
        set { condition = .enabled(newValue) }
    }

    /// Wait for element to be focused.
    public var focused: Bool {
        get {
            if case let .focused(v)? = condition { return v }
            return false
        }
        set { condition = .focused(newValue) }
    }

    /// Wait for element text to match.
    public var textEquals: String {
        get {
            if case let .textEquals(v)? = condition { return v }
            return String()
        }
        set { condition = .textEquals(newValue) }
    }

    /// Wait for element text to contain substring.
    public var textContains: String {
        get {
            if case let .textContains(v)? = condition { return v }
            return String()
        }
        set { condition = .textContains(newValue) }
    }

    /// Wait for element to have specific attribute value.
    public var attribute: Macosusesdk_V1_AttributeCondition {
        get {
            if case let .attribute(v)? = condition { return v }
            return Macosusesdk_V1_AttributeCondition()
        }
        set { condition = .attribute(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Condition type.
    public enum OneOf_Condition: Equatable, Sendable {
        /// Wait for element to be enabled.
        case enabled(Bool)
        /// Wait for element to be focused.
        case focused(Bool)
        /// Wait for element text to match.
        case textEquals(String)
        /// Wait for element text to contain substring.
        case textContains(String)
        /// Wait for element to have specific attribute value.
        case attribute(Macosusesdk_V1_AttributeCondition)
    }

    public init() {}
}

/// Attribute condition for waiting.
public struct Macosusesdk_V1_AttributeCondition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name.
    public var name: String = .init()

    /// Attribute name.
    public var attribute: String = .init()

    /// Expected attribute value.
    public var value: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from waiting for element state.
public struct Macosusesdk_V1_WaitElementStateResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The element in the expected state.
    public var element: Macosusesdk_Type_Element {
        get { _element ?? Macosusesdk_Type_Element() }
        set { _element = newValue }
    }

    /// Returns true if `element` has been explicitly set.
    public var hasElement: Bool { _element != nil }
    /// Clears the value of `element`. Subsequent reads from it will return its default value.
    public mutating func clearElement() { _element = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _element: Macosusesdk_Type_Element?
}

/// Metadata for WaitElementState operation.
public struct Macosusesdk_V1_WaitElementStateMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The condition being waited for.
    public var condition: Macosusesdk_V1_StateCondition {
        get { _condition ?? Macosusesdk_V1_StateCondition() }
        set { _condition = newValue }
    }

    /// Returns true if `condition` has been explicitly set.
    public var hasCondition: Bool { _condition != nil }
    /// Clears the value of `condition`. Subsequent reads from it will return its default value.
    public mutating func clearCondition() { _condition = nil }

    /// Number of poll attempts so far.
    public var attempts: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _condition: Macosusesdk_V1_StateCondition?
}

/// ===== Window Messages =====
/// Request to get a window.
public struct Macosusesdk_V1_GetWindowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the window.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to list windows.
public struct Macosusesdk_V1_ListWindowsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent application.
    public var parent: String = .init()

    /// Maximum number of windows to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous ListWindows call.
    public var pageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from listing windows.
public struct Macosusesdk_V1_ListWindowsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The windows.
    public var windows: [Macosusesdk_V1_Window] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to focus a window.
public struct Macosusesdk_V1_FocusWindowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the window.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to move a window.
public struct Macosusesdk_V1_MoveWindowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the window.
    public var name: String = .init()

    /// New X coordinate.
    public var x: Double = 0

    /// New Y coordinate.
    public var y: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to resize a window.
public struct Macosusesdk_V1_ResizeWindowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the window.
    public var name: String = .init()

    /// New width.
    public var width: Double = 0

    /// New height.
    public var height: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to minimize a window.
public struct Macosusesdk_V1_MinimizeWindowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the window.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to restore a window.
public struct Macosusesdk_V1_RestoreWindowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the window.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to close a window.
public struct Macosusesdk_V1_CloseWindowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the window.
    public var name: String = .init()

    /// Whether to force close without confirmation.
    public var force: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from closing a window.
public struct Macosusesdk_V1_CloseWindowResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// ===== Observation Messages =====
/// Request to create an observation.
public struct Macosusesdk_V1_CreateObservationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent application.
    public var parent: String = .init()

    /// The observation to create.
    public var observation: Macosusesdk_V1_Observation {
        get { _observation ?? Macosusesdk_V1_Observation() }
        set { _observation = newValue }
    }

    /// Returns true if `observation` has been explicitly set.
    public var hasObservation: Bool { _observation != nil }
    /// Clears the value of `observation`. Subsequent reads from it will return its default value.
    public mutating func clearObservation() { _observation = nil }

    /// Optional observation ID. If not provided, the server generates one.
    public var observationID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _observation: Macosusesdk_V1_Observation?
}

/// Metadata for CreateObservation operation.
public struct Macosusesdk_V1_CreateObservationMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The observation being created.
    public var observation: String = .init()

    /// Observation type.
    public var type: Macosusesdk_V1_ObservationType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to get an observation.
public struct Macosusesdk_V1_GetObservationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the observation.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to list observations.
public struct Macosusesdk_V1_ListObservationsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent application.
    public var parent: String = .init()

    /// Maximum number of observations to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous ListObservations call.
    public var pageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from listing observations.
public struct Macosusesdk_V1_ListObservationsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The observations.
    public var observations: [Macosusesdk_V1_Observation] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to cancel an observation.
public struct Macosusesdk_V1_CancelObservationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the observation.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to stream observation events.
public struct Macosusesdk_V1_StreamObservationsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the observation.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from streaming observations.
public struct Macosusesdk_V1_StreamObservationsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The observation event.
    public var event: Macosusesdk_V1_ObservationEvent {
        get { _event ?? Macosusesdk_V1_ObservationEvent() }
        set { _event = newValue }
    }

    /// Returns true if `event` has been explicitly set.
    public var hasEvent: Bool { _event != nil }
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    public mutating func clearEvent() { _event = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _event: Macosusesdk_V1_ObservationEvent?
}

/// ===== Session Messages =====
/// Request to create a session.
public struct Macosusesdk_V1_CreateSessionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The session to create.
    public var session: Macosusesdk_V1_Session {
        get { _session ?? Macosusesdk_V1_Session() }
        set { _session = newValue }
    }

    /// Returns true if `session` has been explicitly set.
    public var hasSession: Bool { _session != nil }
    /// Clears the value of `session`. Subsequent reads from it will return its default value.
    public mutating func clearSession() { _session = nil }

    /// Optional session ID. If not provided, the server generates one.
    public var sessionID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _session: Macosusesdk_V1_Session?
}

/// Request to get a session.
public struct Macosusesdk_V1_GetSessionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the session.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to list sessions.
public struct Macosusesdk_V1_ListSessionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Maximum number of sessions to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous ListSessions call.
    public var pageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from listing sessions.
public struct Macosusesdk_V1_ListSessionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The sessions.
    public var sessions: [Macosusesdk_V1_Session] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to delete a session.
public struct Macosusesdk_V1_DeleteSessionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the session.
    public var name: String = .init()

    /// Whether to force delete active sessions.
    public var force: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// ===== Macro Messages =====
/// Request to create a macro.
public struct Macosusesdk_V1_CreateMacroRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The macro to create.
    public var macro: Macosusesdk_V1_Macro {
        get { _macro ?? Macosusesdk_V1_Macro() }
        set { _macro = newValue }
    }

    /// Returns true if `macro` has been explicitly set.
    public var hasMacro: Bool { _macro != nil }
    /// Clears the value of `macro`. Subsequent reads from it will return its default value.
    public mutating func clearMacro() { _macro = nil }

    /// Optional macro ID. If not provided, the server generates one.
    public var macroID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _macro: Macosusesdk_V1_Macro?
}

/// Request to get a macro.
public struct Macosusesdk_V1_GetMacroRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the macro.
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to list macros.
public struct Macosusesdk_V1_ListMacrosRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Maximum number of macros to return.
    public var pageSize: Int32 = 0

    /// Page token from a previous ListMacros call.
    public var pageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from listing macros.
public struct Macosusesdk_V1_ListMacrosResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The macros.
    public var macros: [Macosusesdk_V1_Macro] = []

    /// Token to retrieve the next page of results.
    public var nextPageToken: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to update a macro.
public struct Macosusesdk_V1_UpdateMacroRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The macro to update. The name field must be set.
    public var macro: Macosusesdk_V1_Macro {
        get { _macro ?? Macosusesdk_V1_Macro() }
        set { _macro = newValue }
    }

    /// Returns true if `macro` has been explicitly set.
    public var hasMacro: Bool { _macro != nil }
    /// Clears the value of `macro`. Subsequent reads from it will return its default value.
    public mutating func clearMacro() { _macro = nil }

    /// Fields to update.
    public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
        get { _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask() }
        set { _updateMask = newValue }
    }

    /// Returns true if `updateMask` has been explicitly set.
    public var hasUpdateMask: Bool { _updateMask != nil }
    /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMask() { _updateMask = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _macro: Macosusesdk_V1_Macro?
    fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask?
}

/// Request to delete a macro.
public struct Macosusesdk_V1_DeleteMacroRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name of the macro.
    public var name: String = .init()

    /// If true, delete child resources (executions, logs).
    public var force: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to execute a macro (long-running operation).
public struct Macosusesdk_V1_ExecuteMacroRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Macro to execute.
    public var macro: String = .init()

    /// Parameter values (for parameterized macros).
    public var parameterValues: [String: String] = [:]

    /// Application context (if needed).
    public var application: String = .init()

    /// Execution options.
    public var options: Macosusesdk_V1_ExecutionOptions {
        get { _options ?? Macosusesdk_V1_ExecutionOptions() }
        set { _options = newValue }
    }

    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool { _options != nil }
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() { _options = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _options: Macosusesdk_V1_ExecutionOptions?
}

/// Options for macro execution.
public struct Macosusesdk_V1_ExecutionOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Execution speed multiplier (1.0 = normal speed).
    public var speed: Double = 0

    /// Whether to continue on error.
    public var continueOnError: Bool = false

    /// Maximum execution time in seconds.
    public var timeout: Double = 0

    /// Whether to record execution for debugging.
    public var recordExecution: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from executing a macro.
public struct Macosusesdk_V1_ExecuteMacroResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether execution succeeded.
    public var success: Bool = false

    /// Number of actions executed.
    public var actionsExecuted: Int32 = 0

    /// Execution duration.
    public var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
        get { _executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _executionDuration = newValue }
    }

    /// Returns true if `executionDuration` has been explicitly set.
    public var hasExecutionDuration: Bool { _executionDuration != nil }
    /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionDuration() { _executionDuration = nil }

    /// Error message if failed.
    public var error: String = .init()

    /// Execution log (if recording was enabled).
    public var log: [Macosusesdk_V1_ExecutionLogEntry] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration?
}

/// Log entry for macro execution.
public struct Macosusesdk_V1_ExecutionLogEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name.
    public var name: String = .init()

    /// When the action executed.
    public var executionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _executionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _executionTime = newValue }
    }

    /// Returns true if `executionTime` has been explicitly set.
    public var hasExecutionTime: Bool { _executionTime != nil }
    /// Clears the value of `executionTime`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionTime() { _executionTime = nil }

    /// Action index in macro.
    public var actionIndex: Int32 = 0

    /// Action description.
    public var description_p: String = .init()

    /// Whether action succeeded.
    public var success: Bool = false

    /// Error message if failed.
    public var error: String = .init()

    /// Duration in seconds.
    public var duration: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _executionTime: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// Metadata for ExecuteMacro operation.
public struct Macosusesdk_V1_ExecuteMacroMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Macro being executed.
    public var macro: String = .init()

    /// Current action index.
    public var currentAction: Int32 = 0

    /// Total actions in macro.
    public var totalActions: Int32 = 0

    /// Elapsed duration.
    public var elapsedDuration: SwiftProtobuf.Google_Protobuf_Duration {
        get { _elapsedDuration ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _elapsedDuration = newValue }
    }

    /// Returns true if `elapsedDuration` has been explicitly set.
    public var hasElapsedDuration: Bool { _elapsedDuration != nil }
    /// Clears the value of `elapsedDuration`. Subsequent reads from it will return its default value.
    public mutating func clearElapsedDuration() { _elapsedDuration = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _elapsedDuration: SwiftProtobuf.Google_Protobuf_Duration?
}

/// ===== Session Transaction Messages =====
/// Request to begin a transaction within a session.
public struct Macosusesdk_V1_BeginTransactionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Session name.
    public var session: String = .init()

    /// Transaction isolation level.
    public var isolationLevel: Macosusesdk_V1_BeginTransactionRequest.IsolationLevel = .unspecified

    /// Transaction timeout in seconds (default: 300).
    public var timeout: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Isolation level for transactions.
    public enum IsolationLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default isolation level (SERIALIZABLE).
        case unspecified // = 0

        /// All operations appear atomic (full snapshot/restore on rollback).
        case serializable // = 1

        /// Operations may see partial changes (best-effort rollback).
        case readCommitted // = 2
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .serializable
            case 2: self = .readCommitted
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .serializable: 1
            case .readCommitted: 2
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_BeginTransactionRequest.IsolationLevel] = [
            .unspecified,
            .serializable,
            .readCommitted,
        ]
    }

    public init() {}
}

/// Response from beginning a transaction.
public struct Macosusesdk_V1_BeginTransactionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Transaction ID for subsequent operations.
    public var transactionID: String = .init()

    /// Session with updated state.
    public var session: Macosusesdk_V1_Session {
        get { _session ?? Macosusesdk_V1_Session() }
        set { _session = newValue }
    }

    /// Returns true if `session` has been explicitly set.
    public var hasSession: Bool { _session != nil }
    /// Clears the value of `session`. Subsequent reads from it will return its default value.
    public mutating func clearSession() { _session = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _session: Macosusesdk_V1_Session?
}

/// Request to commit a transaction.
public struct Macosusesdk_V1_CommitTransactionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the session to commit.
    /// Format: sessions/{session}
    public var name: String = .init()

    /// Transaction ID to commit.
    public var transactionID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to rollback a transaction.
public struct Macosusesdk_V1_RollbackTransactionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the session to rollback.
    /// Format: sessions/{session}
    public var name: String = .init()

    /// The revision to rollback to.
    public var revisionID: String = .init()

    /// Transaction ID to rollback.
    public var transactionID: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to get a session state snapshot.
public struct Macosusesdk_V1_GetSessionSnapshotRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the session to snapshot.
    /// Format: sessions/{session}
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// ===== Screenshot Messages =====
/// Request to capture a screenshot of the entire screen.
public struct Macosusesdk_V1_CaptureScreenshotRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Image format.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// JPEG quality (1-100, only for JPEG format).
    public var quality: Int32 = 0

    /// Include display index in filename.
    public var display: Int32 = 0

    /// Whether to include OCR text extraction.
    public var includeOcrText: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from capturing a screenshot.
public struct Macosusesdk_V1_CaptureScreenshotResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Image data (encoded according to format).
    public var imageData: Data = .init()

    /// Image format used.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// Image width in pixels.
    public var width: Int32 = 0

    /// Image height in pixels.
    public var height: Int32 = 0

    /// OCR-extracted text (if requested).
    public var ocrText: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to capture a screenshot of a specific window.
public struct Macosusesdk_V1_CaptureWindowScreenshotRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Window to capture.
    public var window: String = .init()

    /// Image format.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// JPEG quality (1-100, only for JPEG format).
    public var quality: Int32 = 0

    /// Whether to include window shadow.
    public var includeShadow: Bool = false

    /// Whether to include OCR text extraction.
    public var includeOcrText: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from capturing a window screenshot.
public struct Macosusesdk_V1_CaptureWindowScreenshotResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Image data (encoded according to format).
    public var imageData: Data = .init()

    /// Image format used.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// Image width in pixels.
    public var width: Int32 = 0

    /// Image height in pixels.
    public var height: Int32 = 0

    /// Window that was captured.
    public var window: String = .init()

    /// OCR-extracted text (if requested).
    public var ocrText: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to capture a screenshot of a specific element.
public struct Macosusesdk_V1_CaptureElementScreenshotRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Parent context (application or window).
    public var parent: String = .init()

    /// Element ID to capture.
    public var elementID: String = .init()

    /// Image format.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// JPEG quality (1-100, only for JPEG format).
    public var quality: Int32 = 0

    /// Padding around element in pixels.
    public var padding: Int32 = 0

    /// Whether to include OCR text extraction.
    public var includeOcrText: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from capturing an element screenshot.
public struct Macosusesdk_V1_CaptureElementScreenshotResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Image data (encoded according to format).
    public var imageData: Data = .init()

    /// Image format used.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// Image width in pixels.
    public var width: Int32 = 0

    /// Image height in pixels.
    public var height: Int32 = 0

    /// Element ID that was captured.
    public var elementID: String = .init()

    /// OCR-extracted text (if requested).
    public var ocrText: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to capture a screenshot of a screen region.
public struct Macosusesdk_V1_CaptureRegionScreenshotRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Region to capture (screen coordinates).
    public var region: Macosusesdk_Type_Region {
        get { _region ?? Macosusesdk_Type_Region() }
        set { _region = newValue }
    }

    /// Returns true if `region` has been explicitly set.
    public var hasRegion: Bool { _region != nil }
    /// Clears the value of `region`. Subsequent reads from it will return its default value.
    public mutating func clearRegion() { _region = nil }

    /// Image format.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// JPEG quality (1-100, only for JPEG format).
    public var quality: Int32 = 0

    /// Display index (for multi-monitor setups).
    public var display: Int32 = 0

    /// Whether to include OCR text extraction.
    public var includeOcrText: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _region: Macosusesdk_Type_Region?
}

/// Response from capturing a region screenshot.
public struct Macosusesdk_V1_CaptureRegionScreenshotResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Image data (encoded according to format).
    public var imageData: Data = .init()

    /// Image format used.
    public var format: Macosusesdk_V1_ImageFormat = .unspecified

    /// Image width in pixels.
    public var width: Int32 = 0

    /// Image height in pixels.
    public var height: Int32 = 0

    /// Region that was captured.
    public var region: Macosusesdk_Type_Region {
        get { _region ?? Macosusesdk_Type_Region() }
        set { _region = newValue }
    }

    /// Returns true if `region` has been explicitly set.
    public var hasRegion: Bool { _region != nil }
    /// Clears the value of `region`. Subsequent reads from it will return its default value.
    public mutating func clearRegion() { _region = nil }

    /// OCR-extracted text (if requested).
    public var ocrText: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _region: Macosusesdk_Type_Region?
}

/// ===== Clipboard Messages =====
/// Request to get clipboard contents.
public struct Macosusesdk_V1_GetClipboardRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the clipboard resource.
    /// Format: clipboard (singleton)
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to write clipboard contents.
public struct Macosusesdk_V1_WriteClipboardRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Content to write on clipboard.
    public var content: Macosusesdk_V1_ClipboardContent {
        get { _content ?? Macosusesdk_V1_ClipboardContent() }
        set { _content = newValue }
    }

    /// Returns true if `content` has been explicitly set.
    public var hasContent: Bool { _content != nil }
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    public mutating func clearContent() { _content = nil }

    /// Whether to clear existing clipboard content first.
    public var clearExisting_p: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _content: Macosusesdk_V1_ClipboardContent?
}

/// Response from writing clipboard contents.
public struct Macosusesdk_V1_WriteClipboardResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    /// Content type that was written.
    public var type: Macosusesdk_V1_ContentType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to clear clipboard contents.
public struct Macosusesdk_V1_ClearClipboardRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from clearing clipboard.
public struct Macosusesdk_V1_ClearClipboardResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to get clipboard history (if available).
public struct Macosusesdk_V1_GetClipboardHistoryRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the clipboard history resource.
    /// Format: clipboard/history (singleton)
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// ===== File Messages =====
/// Request to automate an open file dialog.
public struct Macosusesdk_V1_AutomateOpenFileDialogRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Application context.
    public var application: String = .init()

    /// File path to select (if known).
    public var filePath: String = .init()

    /// Default directory to navigate to.
    public var defaultDirectory: String = .init()

    /// File type filters (e.g., ["*.txt", "*.pdf"]).
    public var fileFilters: [String] = []

    /// Timeout for dialog to appear (seconds).
    public var timeout: Double = 0

    /// Whether to allow multiple file selection.
    public var allowMultiple: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from automating an open file dialog.
public struct Macosusesdk_V1_AutomateOpenFileDialogResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    /// Selected file path(s).
    public var selectedPaths: [String] = []

    /// Error message if failed.
    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to automate a save file dialog.
public struct Macosusesdk_V1_AutomateSaveFileDialogRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Application context.
    public var application: String = .init()

    /// File path to save to.
    public var filePath: String = .init()

    /// Default directory to navigate to.
    public var defaultDirectory: String = .init()

    /// Default filename.
    public var defaultFilename: String = .init()

    /// Timeout for dialog to appear (seconds).
    public var timeout: Double = 0

    /// Whether to confirm overwrite.
    public var confirmOverwrite: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from automating a save file dialog.
public struct Macosusesdk_V1_AutomateSaveFileDialogResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    /// Final save path.
    public var savedPath: String = .init()

    /// Error message if failed.
    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to select a file programmatically.
public struct Macosusesdk_V1_SelectFileRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Application context.
    public var application: String = .init()

    /// File path to select.
    public var filePath: String = .init()

    /// Whether to reveal Finder after selection.
    public var revealFinder: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from selecting a file.
public struct Macosusesdk_V1_SelectFileResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    /// Selected file path.
    public var selectedPath: String = .init()

    /// Error message if failed.
    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to select a directory.
public struct Macosusesdk_V1_SelectDirectoryRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Application context.
    public var application: String = .init()

    /// Directory path to select.
    public var directoryPath: String = .init()

    /// Whether to create directory when it doesn't exist.
    public var createMissing: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from selecting a directory.
public struct Macosusesdk_V1_SelectDirectoryResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    /// Selected directory path.
    public var selectedPath: String = .init()

    /// Whether the directory was created.
    public var created: Bool = false

    /// Error message if failed.
    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to drag and drop files.
public struct Macosusesdk_V1_DragFilesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Application context.
    public var application: String = .init()

    /// File paths to drag.
    public var filePaths: [String] = []

    /// Target element ID to drop on.
    public var targetElementID: String = .init()

    /// Drag duration in seconds.
    public var duration: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from dragging files.
public struct Macosusesdk_V1_DragFilesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the operation succeeded.
    public var success: Bool = false

    /// Number of files dropped.
    public var filesDropped: Int32 = 0

    /// Error message if failed.
    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// ===== Script Messages =====
/// Request to execute an AppleScript.
public struct Macosusesdk_V1_ExecuteAppleScriptRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// AppleScript source code.
    public var script: String = .init()

    /// Timeout for script execution.
    public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
        get { _timeout ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _timeout = newValue }
    }

    /// Returns true if `timeout` has been explicitly set.
    public var hasTimeout: Bool { _timeout != nil }
    /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
    public mutating func clearTimeout() { _timeout = nil }

    /// Whether to compile the script (for validation).
    public var compileOnly: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration?
}

/// Response from executing an AppleScript.
public struct Macosusesdk_V1_ExecuteAppleScriptResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether execution succeeded.
    public var success: Bool = false

    /// Script output (return value).
    public var output: String = .init()

    /// Error message if failed.
    public var error: String = .init()

    /// Execution duration.
    public var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
        get { _executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _executionDuration = newValue }
    }

    /// Returns true if `executionDuration` has been explicitly set.
    public var hasExecutionDuration: Bool { _executionDuration != nil }
    /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionDuration() { _executionDuration = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration?
}

/// Request to execute JavaScript for Automation (JXA).
public struct Macosusesdk_V1_ExecuteJavaScriptRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// JavaScript source code.
    public var script: String = .init()

    /// Timeout for script execution.
    public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
        get { _timeout ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _timeout = newValue }
    }

    /// Returns true if `timeout` has been explicitly set.
    public var hasTimeout: Bool { _timeout != nil }
    /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
    public mutating func clearTimeout() { _timeout = nil }

    /// Whether to compile the script (for validation).
    public var compileOnly: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration?
}

/// Response from executing JXA.
public struct Macosusesdk_V1_ExecuteJavaScriptResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether execution succeeded.
    public var success: Bool = false

    /// Script output (return value, JSON-encoded).
    public var output: String = .init()

    /// Error message if failed.
    public var error: String = .init()

    /// Execution duration.
    public var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
        get { _executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _executionDuration = newValue }
    }

    /// Returns true if `executionDuration` has been explicitly set.
    public var hasExecutionDuration: Bool { _executionDuration != nil }
    /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionDuration() { _executionDuration = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration?
}

/// Request to execute a shell command.
public struct Macosusesdk_V1_ExecuteShellCommandRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Shell command to execute.
    public var command: String = .init()

    /// Arguments for the command.
    public var args: [String] = []

    /// Working directory for command execution.
    public var workingDirectory: String = .init()

    /// Environment variables (key-value pairs).
    public var environment: [String: String] = [:]

    /// Timeout for command execution.
    public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
        get { _timeout ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _timeout = newValue }
    }

    /// Returns true if `timeout` has been explicitly set.
    public var hasTimeout: Bool { _timeout != nil }
    /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
    public mutating func clearTimeout() { _timeout = nil }

    /// Input to provide to command via stdin.
    public var stdin: String = .init()

    /// Shell to use (default: /bin/bash).
    public var shell: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration?
}

/// Response from executing a shell command.
public struct Macosusesdk_V1_ExecuteShellCommandResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether execution succeeded.
    public var success: Bool = false

    /// Standard output from command.
    public var stdout: String = .init()

    /// Standard error from command.
    public var stderr: String = .init()

    /// Exit code from command.
    public var exitCode: Int32 = 0

    /// Execution duration.
    public var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
        get { _executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration() }
        set { _executionDuration = newValue }
    }

    /// Returns true if `executionDuration` has been explicitly set.
    public var hasExecutionDuration: Bool { _executionDuration != nil }
    /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionDuration() { _executionDuration = nil }

    /// Error message if execution failed (not command failure).
    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration?
}

/// Request to validate a script without executing.
public struct Macosusesdk_V1_ValidateScriptRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Script type.
    public var type: Macosusesdk_V1_ScriptType = .unspecified

    /// Script source code.
    public var script: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from validating a script.
public struct Macosusesdk_V1_ValidateScriptResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the script is valid.
    public var valid: Bool = false

    /// Validation error messages (if any).
    public var errors: [String] = []

    /// Validation warnings (if any).
    public var warnings: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to get available scripting dictionaries.
public struct Macosusesdk_V1_GetScriptingDictionariesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the scripting dictionaries resource.
    /// Format: scriptingDictionaries (singleton)
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// ===== Metrics Messages =====
/// Request to get current metrics.
public struct Macosusesdk_V1_GetMetricsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the metrics resource.
    /// Format: metrics (singleton)
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to get a performance report.
public struct Macosusesdk_V1_GetPerformanceReportRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the performance report resource.
    /// Format: metrics/performanceReport (singleton)
    public var name: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Request to reset metrics.
public struct Macosusesdk_V1_ResetMetricsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Metric types to reset (empty = all).
    public var types: [Macosusesdk_V1_MetricType] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Response from resetting metrics.
public struct Macosusesdk_V1_ResetMetricsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether reset succeeded.
    public var success: Bool = false

    /// Metrics that were reset.
    public var resetTypes: [Macosusesdk_V1_MetricType] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_OpenApplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".OpenApplicationRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &id)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_OpenApplicationRequest, rhs: Macosusesdk_V1_OpenApplicationRequest) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_OpenApplicationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".OpenApplicationResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_application)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _application {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_OpenApplicationResponse, rhs: Macosusesdk_V1_OpenApplicationResponse) -> Bool {
        if lhs._application != rhs._application { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_OpenApplicationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".OpenApplicationMetadata"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &id)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularStringField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_OpenApplicationMetadata, rhs: Macosusesdk_V1_OpenApplicationMetadata) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetApplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetApplicationRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetApplicationRequest, rhs: Macosusesdk_V1_GetApplicationRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListApplicationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListApplicationsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 2: try decoder.decodeSingularStringField(value: &pageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 1)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListApplicationsRequest, rhs: Macosusesdk_V1_ListApplicationsRequest) -> Bool {
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListApplicationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListApplicationsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}applications\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &applications)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !applications.isEmpty {
            try visitor.visitRepeatedMessageField(value: applications, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListApplicationsResponse, rhs: Macosusesdk_V1_ListApplicationsResponse) -> Bool {
        if lhs.applications != rhs.applications { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_DeleteApplicationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteApplicationRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}force\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularBoolField(value: &force)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if force != false {
            try visitor.visitSingularBoolField(value: force, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_DeleteApplicationRequest, rhs: Macosusesdk_V1_DeleteApplicationRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.force != rhs.force { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CreateInputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateInputRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}input\0\u{3}input_id\0")

    fileprivate class _StorageClass {
        var _parent: String = .init()
        var _input: Macosusesdk_V1_Input?
        var _inputID: String = .init()

        // This property is used as the initial default value for new instances of the type.
        // The type itself is protecting the reference to its storage via CoW semantics.
        // This will force a copy to be made of this reference when the first mutation occurs;
        // hence, it is safe to mark this as `nonisolated(unsafe)`.
        nonisolated(unsafe) static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _parent = source._parent
            _input = source._input
            _inputID = source._inputID
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularStringField(value: &_storage._parent)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._input)
                case 3: try decoder.decodeSingularStringField(value: &_storage._inputID)
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if !_storage._parent.isEmpty {
                try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
            }
            try { if let v = _storage._input {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if !_storage._inputID.isEmpty {
                try visitor.visitSingularStringField(value: _storage._inputID, fieldNumber: 3)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CreateInputRequest, rhs: Macosusesdk_V1_CreateInputRequest) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._parent != rhs_storage._parent { return false }
                if _storage._input != rhs_storage._input { return false }
                if _storage._inputID != rhs_storage._inputID { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetInputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetInputRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetInputRequest, rhs: Macosusesdk_V1_GetInputRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListInputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListInputsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}page_size\0\u{3}page_token\0\u{1}filter\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 3: try decoder.decodeSingularStringField(value: &pageToken)
            case 4: try decoder.decodeSingularStringField(value: &filter)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 2)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 3)
        }
        if !filter.isEmpty {
            try visitor.visitSingularStringField(value: filter, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListInputsRequest, rhs: Macosusesdk_V1_ListInputsRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.filter != rhs.filter { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListInputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListInputsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}inputs\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &inputs)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !inputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: inputs, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListInputsResponse, rhs: Macosusesdk_V1_ListInputsResponse) -> Bool {
        if lhs.inputs != rhs.inputs { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_TraverseAccessibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TraverseAccessibilityRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}visible_only\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularBoolField(value: &visibleOnly)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if visibleOnly != false {
            try visitor.visitSingularBoolField(value: visibleOnly, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_TraverseAccessibilityRequest, rhs: Macosusesdk_V1_TraverseAccessibilityRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.visibleOnly != rhs.visibleOnly { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_TraverseAccessibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TraverseAccessibilityResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}app\0\u{1}elements\0\u{1}stats\0\u{3}processing_time\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &app)
            case 2: try decoder.decodeRepeatedMessageField(value: &elements)
            case 3: try decoder.decodeSingularMessageField(value: &_stats)
            case 4: try decoder.decodeSingularMessageField(value: &_processingTime)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !app.isEmpty {
            try visitor.visitSingularStringField(value: app, fieldNumber: 1)
        }
        if !elements.isEmpty {
            try visitor.visitRepeatedMessageField(value: elements, fieldNumber: 2)
        }
        try { if let v = self._stats {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._processingTime {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_TraverseAccessibilityResponse, rhs: Macosusesdk_V1_TraverseAccessibilityResponse) -> Bool {
        if lhs.app != rhs.app { return false }
        if lhs.elements != rhs.elements { return false }
        if lhs._stats != rhs._stats { return false }
        if lhs._processingTime != rhs._processingTime { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WatchAccessibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WatchAccessibilityRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}poll_interval\0\u{3}visible_only\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularDoubleField(value: &pollInterval)
            case 3: try decoder.decodeSingularBoolField(value: &visibleOnly)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if pollInterval.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: pollInterval, fieldNumber: 2)
        }
        if visibleOnly != false {
            try visitor.visitSingularBoolField(value: visibleOnly, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WatchAccessibilityRequest, rhs: Macosusesdk_V1_WatchAccessibilityRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.pollInterval != rhs.pollInterval { return false }
        if lhs.visibleOnly != rhs.visibleOnly { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WatchAccessibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WatchAccessibilityResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}added\0\u{1}removed\0\u{1}modified\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &added)
            case 2: try decoder.decodeRepeatedMessageField(value: &removed)
            case 3: try decoder.decodeRepeatedMessageField(value: &modified)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !added.isEmpty {
            try visitor.visitRepeatedMessageField(value: added, fieldNumber: 1)
        }
        if !removed.isEmpty {
            try visitor.visitRepeatedMessageField(value: removed, fieldNumber: 2)
        }
        if !modified.isEmpty {
            try visitor.visitRepeatedMessageField(value: modified, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WatchAccessibilityResponse, rhs: Macosusesdk_V1_WatchAccessibilityResponse) -> Bool {
        if lhs.added != rhs.added { return false }
        if lhs.removed != rhs.removed { return false }
        if lhs.modified != rhs.modified { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ModifiedElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ModifiedElement"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}old_element\0\u{3}new_element\0\u{1}changes\0")

    fileprivate class _StorageClass {
        var _oldElement: Macosusesdk_Type_Element?
        var _newElement: Macosusesdk_Type_Element?
        var _changes: [Macosusesdk_V1_AttributeChange] = []

        // This property is used as the initial default value for new instances of the type.
        // The type itself is protecting the reference to its storage via CoW semantics.
        // This will force a copy to be made of this reference when the first mutation occurs;
        // hence, it is safe to mark this as `nonisolated(unsafe)`.
        nonisolated(unsafe) static let defaultInstance = _StorageClass()

        private init() {}

        init(copying source: _StorageClass) {
            _oldElement = source._oldElement
            _newElement = source._newElement
            _changes = source._changes
        }
    }

    fileprivate mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try decoder.decodeSingularMessageField(value: &_storage._oldElement)
                case 2: try decoder.decodeSingularMessageField(value: &_storage._newElement)
                case 3: try decoder.decodeRepeatedMessageField(value: &_storage._changes)
                default: break
                }
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._oldElement {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            try { if let v = _storage._newElement {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            } }()
            if !_storage._changes.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._changes, fieldNumber: 3)
            }
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ModifiedElement, rhs: Macosusesdk_V1_ModifiedElement) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._oldElement != rhs_storage._oldElement { return false }
                if _storage._newElement != rhs_storage._newElement { return false }
                if _storage._changes != rhs_storage._changes { return false }
                return true
            }
            if !storagesAreEqual { return false }
        }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_FindElementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FindElementsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}selector\0\u{3}page_size\0\u{3}page_token\0\u{3}visible_only\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularMessageField(value: &_selector)
            case 3: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 4: try decoder.decodeSingularStringField(value: &pageToken)
            case 5: try decoder.decodeSingularBoolField(value: &visibleOnly)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        try { if let v = self._selector {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 3)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 4)
        }
        if visibleOnly != false {
            try visitor.visitSingularBoolField(value: visibleOnly, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_FindElementsRequest, rhs: Macosusesdk_V1_FindElementsRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs._selector != rhs._selector { return false }
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.visibleOnly != rhs.visibleOnly { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_FindElementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FindElementsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}elements\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &elements)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !elements.isEmpty {
            try visitor.visitRepeatedMessageField(value: elements, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_FindElementsResponse, rhs: Macosusesdk_V1_FindElementsResponse) -> Bool {
        if lhs.elements != rhs.elements { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_FindRegionElementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FindRegionElementsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}region\0\u{1}selector\0\u{3}page_size\0\u{3}page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularMessageField(value: &_region)
            case 3: try decoder.decodeSingularMessageField(value: &_selector)
            case 4: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 5: try decoder.decodeSingularStringField(value: &pageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        try { if let v = self._region {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._selector {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 4)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_FindRegionElementsRequest, rhs: Macosusesdk_V1_FindRegionElementsRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs._region != rhs._region { return false }
        if lhs._selector != rhs._selector { return false }
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_FindRegionElementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FindRegionElementsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}elements\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &elements)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !elements.isEmpty {
            try visitor.visitRepeatedMessageField(value: elements, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_FindRegionElementsResponse, rhs: Macosusesdk_V1_FindRegionElementsResponse) -> Bool {
        if lhs.elements != rhs.elements { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetElementRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetElementRequest, rhs: Macosusesdk_V1_GetElementRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ClickElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ClickElementRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{3}click_type\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.target != nil { try decoder.handleConflictingOneOf() }
                        self.target = .elementID(v)
                    }
                }()
            case 3: try {
                    var v: Macosusesdk_Type_ElementSelector?
                    var hadOneofValue = false
                    if let current = self.target {
                        hadOneofValue = true
                        if case let .selector(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.target = .selector(v)
                    }
                }()
            case 4: try decoder.decodeSingularEnumField(value: &clickType)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        switch target {
        case .elementID?: try {
                guard case let .elementID(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .selector?: try {
                guard case let .selector(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        if clickType != .unspecified {
            try visitor.visitSingularEnumField(value: clickType, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ClickElementRequest, rhs: Macosusesdk_V1_ClickElementRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.target != rhs.target { return false }
        if lhs.clickType != rhs.clickType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ClickElementRequest.ClickType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CLICK_TYPE_UNSPECIFIED\0\u{1}CLICK_TYPE_SINGLE\0\u{1}CLICK_TYPE_DOUBLE\0\u{1}CLICK_TYPE_RIGHT\0")
}

extension Macosusesdk_V1_ClickElementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ClickElementResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}element\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularMessageField(value: &_element)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        try { if let v = self._element {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ClickElementResponse, rhs: Macosusesdk_V1_ClickElementResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs._element != rhs._element { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WriteElementValueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WriteElementValueRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{1}value\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.target != nil { try decoder.handleConflictingOneOf() }
                        self.target = .elementID(v)
                    }
                }()
            case 3: try {
                    var v: Macosusesdk_Type_ElementSelector?
                    var hadOneofValue = false
                    if let current = self.target {
                        hadOneofValue = true
                        if case let .selector(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.target = .selector(v)
                    }
                }()
            case 4: try decoder.decodeSingularStringField(value: &value)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        switch target {
        case .elementID?: try {
                guard case let .elementID(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .selector?: try {
                guard case let .selector(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        if !value.isEmpty {
            try visitor.visitSingularStringField(value: value, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WriteElementValueRequest, rhs: Macosusesdk_V1_WriteElementValueRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.target != rhs.target { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WriteElementValueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WriteElementValueResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}element\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularMessageField(value: &_element)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        try { if let v = self._element {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WriteElementValueResponse, rhs: Macosusesdk_V1_WriteElementValueResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs._element != rhs._element { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetElementActionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetElementActionsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetElementActionsRequest, rhs: Macosusesdk_V1_GetElementActionsRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ElementActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ElementActions"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}actions\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedStringField(value: &actions)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !actions.isEmpty {
            try visitor.visitRepeatedStringField(value: actions, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ElementActions, rhs: Macosusesdk_V1_ElementActions) -> Bool {
        if lhs.actions != rhs.actions { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_PerformElementActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PerformElementActionRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{1}action\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.target != nil { try decoder.handleConflictingOneOf() }
                        self.target = .elementID(v)
                    }
                }()
            case 3: try {
                    var v: Macosusesdk_Type_ElementSelector?
                    var hadOneofValue = false
                    if let current = self.target {
                        hadOneofValue = true
                        if case let .selector(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.target = .selector(v)
                    }
                }()
            case 4: try decoder.decodeSingularStringField(value: &action)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        switch target {
        case .elementID?: try {
                guard case let .elementID(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .selector?: try {
                guard case let .selector(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        if !action.isEmpty {
            try visitor.visitSingularStringField(value: action, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_PerformElementActionRequest, rhs: Macosusesdk_V1_PerformElementActionRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.target != rhs.target { return false }
        if lhs.action != rhs.action { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_PerformElementActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PerformElementActionResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}element\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularMessageField(value: &_element)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        try { if let v = self._element {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_PerformElementActionResponse, rhs: Macosusesdk_V1_PerformElementActionResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs._element != rhs._element { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitElementRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}selector\0\u{1}timeout\0\u{3}poll_interval\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularMessageField(value: &_selector)
            case 3: try decoder.decodeSingularDoubleField(value: &timeout)
            case 4: try decoder.decodeSingularDoubleField(value: &pollInterval)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        try { if let v = self._selector {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if timeout.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: timeout, fieldNumber: 3)
        }
        if pollInterval.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: pollInterval, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitElementRequest, rhs: Macosusesdk_V1_WaitElementRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs._selector != rhs._selector { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.pollInterval != rhs.pollInterval { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitElementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitElementResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}element\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_element)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _element {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitElementResponse, rhs: Macosusesdk_V1_WaitElementResponse) -> Bool {
        if lhs._element != rhs._element { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitElementMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitElementMetadata"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}selector\0\u{1}attempts\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_selector)
            case 2: try decoder.decodeSingularInt32Field(value: &attempts)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _selector {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if attempts != 0 {
            try visitor.visitSingularInt32Field(value: attempts, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitElementMetadata, rhs: Macosusesdk_V1_WaitElementMetadata) -> Bool {
        if lhs._selector != rhs._selector { return false }
        if lhs.attempts != rhs.attempts { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitElementStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitElementStateRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{1}condition\0\u{1}timeout\0\u{3}poll_interval\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.target != nil { try decoder.handleConflictingOneOf() }
                        self.target = .elementID(v)
                    }
                }()
            case 3: try {
                    var v: Macosusesdk_Type_ElementSelector?
                    var hadOneofValue = false
                    if let current = self.target {
                        hadOneofValue = true
                        if case let .selector(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.target = .selector(v)
                    }
                }()
            case 4: try decoder.decodeSingularMessageField(value: &_condition)
            case 5: try decoder.decodeSingularDoubleField(value: &timeout)
            case 6: try decoder.decodeSingularDoubleField(value: &pollInterval)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        switch target {
        case .elementID?: try {
                guard case let .elementID(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .selector?: try {
                guard case let .selector(v)? = self.target else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try { if let v = self._condition {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if timeout.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: timeout, fieldNumber: 5)
        }
        if pollInterval.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: pollInterval, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitElementStateRequest, rhs: Macosusesdk_V1_WaitElementStateRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.target != rhs.target { return false }
        if lhs._condition != rhs._condition { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.pollInterval != rhs.pollInterval { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_StateCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StateCondition"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}focused\0\u{3}text_equals\0\u{3}text_contains\0\u{1}attribute\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: Bool?
                    try decoder.decodeSingularBoolField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .enabled(v)
                    }
                }()
            case 2: try {
                    var v: Bool?
                    try decoder.decodeSingularBoolField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .focused(v)
                    }
                }()
            case 3: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .textEquals(v)
                    }
                }()
            case 4: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.condition != nil { try decoder.handleConflictingOneOf() }
                        self.condition = .textContains(v)
                    }
                }()
            case 5: try {
                    var v: Macosusesdk_V1_AttributeCondition?
                    var hadOneofValue = false
                    if let current = self.condition {
                        hadOneofValue = true
                        if case let .attribute(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.condition = .attribute(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch condition {
        case .enabled?: try {
                guard case let .enabled(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
            }()
        case .focused?: try {
                guard case let .focused(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
            }()
        case .textEquals?: try {
                guard case let .textEquals(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 3)
            }()
        case .textContains?: try {
                guard case let .textContains(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 4)
            }()
        case .attribute?: try {
                guard case let .attribute(v)? = self.condition else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_StateCondition, rhs: Macosusesdk_V1_StateCondition) -> Bool {
        if lhs.condition != rhs.condition { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_AttributeCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AttributeCondition"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}attribute\0\u{1}value\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &attribute)
            case 3: try decoder.decodeSingularStringField(value: &value)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !attribute.isEmpty {
            try visitor.visitSingularStringField(value: attribute, fieldNumber: 2)
        }
        if !value.isEmpty {
            try visitor.visitSingularStringField(value: value, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_AttributeCondition, rhs: Macosusesdk_V1_AttributeCondition) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.attribute != rhs.attribute { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitElementStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitElementStateResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}element\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_element)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _element {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitElementStateResponse, rhs: Macosusesdk_V1_WaitElementStateResponse) -> Bool {
        if lhs._element != rhs._element { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WaitElementStateMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WaitElementStateMetadata"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}condition\0\u{1}attempts\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_condition)
            case 2: try decoder.decodeSingularInt32Field(value: &attempts)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _condition {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if attempts != 0 {
            try visitor.visitSingularInt32Field(value: attempts, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WaitElementStateMetadata, rhs: Macosusesdk_V1_WaitElementStateMetadata) -> Bool {
        if lhs._condition != rhs._condition { return false }
        if lhs.attempts != rhs.attempts { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetWindowRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetWindowRequest, rhs: Macosusesdk_V1_GetWindowRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListWindowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListWindowsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}page_size\0\u{3}page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 3: try decoder.decodeSingularStringField(value: &pageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 2)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListWindowsRequest, rhs: Macosusesdk_V1_ListWindowsRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListWindowsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListWindowsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}windows\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &windows)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !windows.isEmpty {
            try visitor.visitRepeatedMessageField(value: windows, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListWindowsResponse, rhs: Macosusesdk_V1_ListWindowsResponse) -> Bool {
        if lhs.windows != rhs.windows { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_FocusWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FocusWindowRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_FocusWindowRequest, rhs: Macosusesdk_V1_FocusWindowRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MoveWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MoveWindowRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}x\0\u{1}y\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularDoubleField(value: &x)
            case 3: try decoder.decodeSingularDoubleField(value: &y)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if x.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: x, fieldNumber: 2)
        }
        if y.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: y, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MoveWindowRequest, rhs: Macosusesdk_V1_MoveWindowRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ResizeWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResizeWindowRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}width\0\u{1}height\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularDoubleField(value: &width)
            case 3: try decoder.decodeSingularDoubleField(value: &height)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if width.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: width, fieldNumber: 2)
        }
        if height.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: height, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ResizeWindowRequest, rhs: Macosusesdk_V1_ResizeWindowRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MinimizeWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MinimizeWindowRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MinimizeWindowRequest, rhs: Macosusesdk_V1_MinimizeWindowRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_RestoreWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RestoreWindowRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_RestoreWindowRequest, rhs: Macosusesdk_V1_RestoreWindowRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CloseWindowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CloseWindowRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}force\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularBoolField(value: &force)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if force != false {
            try visitor.visitSingularBoolField(value: force, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CloseWindowRequest, rhs: Macosusesdk_V1_CloseWindowRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.force != rhs.force { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CloseWindowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CloseWindowResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CloseWindowResponse, rhs: Macosusesdk_V1_CloseWindowResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CreateObservationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateObservationRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}observation\0\u{3}observation_id\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularMessageField(value: &_observation)
            case 3: try decoder.decodeSingularStringField(value: &observationID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        try { if let v = self._observation {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if !observationID.isEmpty {
            try visitor.visitSingularStringField(value: observationID, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CreateObservationRequest, rhs: Macosusesdk_V1_CreateObservationRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs._observation != rhs._observation { return false }
        if lhs.observationID != rhs.observationID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CreateObservationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateObservationMetadata"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}observation\0\u{1}type\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &observation)
            case 2: try decoder.decodeSingularEnumField(value: &type)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !observation.isEmpty {
            try visitor.visitSingularStringField(value: observation, fieldNumber: 1)
        }
        if type != .unspecified {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CreateObservationMetadata, rhs: Macosusesdk_V1_CreateObservationMetadata) -> Bool {
        if lhs.observation != rhs.observation { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetObservationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetObservationRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetObservationRequest, rhs: Macosusesdk_V1_GetObservationRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListObservationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListObservationsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}page_size\0\u{3}page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 3: try decoder.decodeSingularStringField(value: &pageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 2)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListObservationsRequest, rhs: Macosusesdk_V1_ListObservationsRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListObservationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListObservationsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}observations\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &observations)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !observations.isEmpty {
            try visitor.visitRepeatedMessageField(value: observations, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListObservationsResponse, rhs: Macosusesdk_V1_ListObservationsResponse) -> Bool {
        if lhs.observations != rhs.observations { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CancelObservationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CancelObservationRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CancelObservationRequest, rhs: Macosusesdk_V1_CancelObservationRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_StreamObservationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StreamObservationsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_StreamObservationsRequest, rhs: Macosusesdk_V1_StreamObservationsRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_StreamObservationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StreamObservationsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}event\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_event)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _event {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_StreamObservationsResponse, rhs: Macosusesdk_V1_StreamObservationsResponse) -> Bool {
        if lhs._event != rhs._event { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CreateSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateSessionRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}session\0\u{3}session_id\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_session)
            case 2: try decoder.decodeSingularStringField(value: &sessionID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _session {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !sessionID.isEmpty {
            try visitor.visitSingularStringField(value: sessionID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CreateSessionRequest, rhs: Macosusesdk_V1_CreateSessionRequest) -> Bool {
        if lhs._session != rhs._session { return false }
        if lhs.sessionID != rhs.sessionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSessionRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetSessionRequest, rhs: Macosusesdk_V1_GetSessionRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListSessionsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 2: try decoder.decodeSingularStringField(value: &pageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 1)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListSessionsRequest, rhs: Macosusesdk_V1_ListSessionsRequest) -> Bool {
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListSessionsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sessions\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &sessions)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !sessions.isEmpty {
            try visitor.visitRepeatedMessageField(value: sessions, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListSessionsResponse, rhs: Macosusesdk_V1_ListSessionsResponse) -> Bool {
        if lhs.sessions != rhs.sessions { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_DeleteSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteSessionRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}force\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularBoolField(value: &force)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if force != false {
            try visitor.visitSingularBoolField(value: force, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_DeleteSessionRequest, rhs: Macosusesdk_V1_DeleteSessionRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.force != rhs.force { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CreateMacroRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CreateMacroRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}macro\0\u{3}macro_id\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_macro)
            case 2: try decoder.decodeSingularStringField(value: &macroID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _macro {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !macroID.isEmpty {
            try visitor.visitSingularStringField(value: macroID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CreateMacroRequest, rhs: Macosusesdk_V1_CreateMacroRequest) -> Bool {
        if lhs._macro != rhs._macro { return false }
        if lhs.macroID != rhs.macroID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetMacroRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMacroRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetMacroRequest, rhs: Macosusesdk_V1_GetMacroRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListMacrosRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListMacrosRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &pageSize)
            case 2: try decoder.decodeSingularStringField(value: &pageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if pageSize != 0 {
            try visitor.visitSingularInt32Field(value: pageSize, fieldNumber: 1)
        }
        if !pageToken.isEmpty {
            try visitor.visitSingularStringField(value: pageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListMacrosRequest, rhs: Macosusesdk_V1_ListMacrosRequest) -> Bool {
        if lhs.pageSize != rhs.pageSize { return false }
        if lhs.pageToken != rhs.pageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ListMacrosResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ListMacrosResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}macros\0\u{3}next_page_token\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &macros)
            case 2: try decoder.decodeSingularStringField(value: &nextPageToken)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !macros.isEmpty {
            try visitor.visitRepeatedMessageField(value: macros, fieldNumber: 1)
        }
        if !nextPageToken.isEmpty {
            try visitor.visitSingularStringField(value: nextPageToken, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ListMacrosResponse, rhs: Macosusesdk_V1_ListMacrosResponse) -> Bool {
        if lhs.macros != rhs.macros { return false }
        if lhs.nextPageToken != rhs.nextPageToken { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_UpdateMacroRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UpdateMacroRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}macro\0\u{3}update_mask\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_macro)
            case 2: try decoder.decodeSingularMessageField(value: &_updateMask)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _macro {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._updateMask {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_UpdateMacroRequest, rhs: Macosusesdk_V1_UpdateMacroRequest) -> Bool {
        if lhs._macro != rhs._macro { return false }
        if lhs._updateMask != rhs._updateMask { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_DeleteMacroRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DeleteMacroRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}force\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularBoolField(value: &force)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if force != false {
            try visitor.visitSingularBoolField(value: force, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_DeleteMacroRequest, rhs: Macosusesdk_V1_DeleteMacroRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.force != rhs.force { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteMacroRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteMacroRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}macro\0\u{3}parameter_values\0\u{1}application\0\u{1}options\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &macro)
            case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &parameterValues)
            case 3: try decoder.decodeSingularStringField(value: &application)
            case 4: try decoder.decodeSingularMessageField(value: &_options)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !macro.isEmpty {
            try visitor.visitSingularStringField(value: macro, fieldNumber: 1)
        }
        if !parameterValues.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: parameterValues, fieldNumber: 2)
        }
        if !application.isEmpty {
            try visitor.visitSingularStringField(value: application, fieldNumber: 3)
        }
        try { if let v = self._options {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteMacroRequest, rhs: Macosusesdk_V1_ExecuteMacroRequest) -> Bool {
        if lhs.macro != rhs.macro { return false }
        if lhs.parameterValues != rhs.parameterValues { return false }
        if lhs.application != rhs.application { return false }
        if lhs._options != rhs._options { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecutionOptions"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}speed\0\u{3}continue_on_error\0\u{1}timeout\0\u{3}record_execution\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularDoubleField(value: &speed)
            case 2: try decoder.decodeSingularBoolField(value: &continueOnError)
            case 3: try decoder.decodeSingularDoubleField(value: &timeout)
            case 4: try decoder.decodeSingularBoolField(value: &recordExecution)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if speed.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: speed, fieldNumber: 1)
        }
        if continueOnError != false {
            try visitor.visitSingularBoolField(value: continueOnError, fieldNumber: 2)
        }
        if timeout.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: timeout, fieldNumber: 3)
        }
        if recordExecution != false {
            try visitor.visitSingularBoolField(value: recordExecution, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecutionOptions, rhs: Macosusesdk_V1_ExecutionOptions) -> Bool {
        if lhs.speed != rhs.speed { return false }
        if lhs.continueOnError != rhs.continueOnError { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.recordExecution != rhs.recordExecution { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteMacroResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteMacroResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}actions_executed\0\u{3}execution_duration\0\u{1}error\0\u{1}log\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularInt32Field(value: &actionsExecuted)
            case 3: try decoder.decodeSingularMessageField(value: &_executionDuration)
            case 4: try decoder.decodeSingularStringField(value: &error)
            case 5: try decoder.decodeRepeatedMessageField(value: &log)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if actionsExecuted != 0 {
            try visitor.visitSingularInt32Field(value: actionsExecuted, fieldNumber: 2)
        }
        try { if let v = self._executionDuration {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 4)
        }
        if !log.isEmpty {
            try visitor.visitRepeatedMessageField(value: log, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteMacroResponse, rhs: Macosusesdk_V1_ExecuteMacroResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.actionsExecuted != rhs.actionsExecuted { return false }
        if lhs._executionDuration != rhs._executionDuration { return false }
        if lhs.error != rhs.error { return false }
        if lhs.log != rhs.log { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecutionLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecutionLogEntry"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}execution_time\0\u{3}action_index\0\u{1}description\0\u{1}success\0\u{1}error\0\u{1}duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularMessageField(value: &_executionTime)
            case 3: try decoder.decodeSingularInt32Field(value: &actionIndex)
            case 4: try decoder.decodeSingularStringField(value: &description_p)
            case 5: try decoder.decodeSingularBoolField(value: &success)
            case 6: try decoder.decodeSingularStringField(value: &error)
            case 7: try decoder.decodeSingularDoubleField(value: &duration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try { if let v = self._executionTime {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if actionIndex != 0 {
            try visitor.visitSingularInt32Field(value: actionIndex, fieldNumber: 3)
        }
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 4)
        }
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 5)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 6)
        }
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecutionLogEntry, rhs: Macosusesdk_V1_ExecutionLogEntry) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs._executionTime != rhs._executionTime { return false }
        if lhs.actionIndex != rhs.actionIndex { return false }
        if lhs.description_p != rhs.description_p { return false }
        if lhs.success != rhs.success { return false }
        if lhs.error != rhs.error { return false }
        if lhs.duration != rhs.duration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteMacroMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteMacroMetadata"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}macro\0\u{3}current_action\0\u{3}total_actions\0\u{3}elapsed_duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &macro)
            case 2: try decoder.decodeSingularInt32Field(value: &currentAction)
            case 3: try decoder.decodeSingularInt32Field(value: &totalActions)
            case 4: try decoder.decodeSingularMessageField(value: &_elapsedDuration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !macro.isEmpty {
            try visitor.visitSingularStringField(value: macro, fieldNumber: 1)
        }
        if currentAction != 0 {
            try visitor.visitSingularInt32Field(value: currentAction, fieldNumber: 2)
        }
        if totalActions != 0 {
            try visitor.visitSingularInt32Field(value: totalActions, fieldNumber: 3)
        }
        try { if let v = self._elapsedDuration {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteMacroMetadata, rhs: Macosusesdk_V1_ExecuteMacroMetadata) -> Bool {
        if lhs.macro != rhs.macro { return false }
        if lhs.currentAction != rhs.currentAction { return false }
        if lhs.totalActions != rhs.totalActions { return false }
        if lhs._elapsedDuration != rhs._elapsedDuration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_BeginTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BeginTransactionRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}session\0\u{3}isolation_level\0\u{1}timeout\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &session)
            case 2: try decoder.decodeSingularEnumField(value: &isolationLevel)
            case 3: try decoder.decodeSingularDoubleField(value: &timeout)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !session.isEmpty {
            try visitor.visitSingularStringField(value: session, fieldNumber: 1)
        }
        if isolationLevel != .unspecified {
            try visitor.visitSingularEnumField(value: isolationLevel, fieldNumber: 2)
        }
        if timeout.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: timeout, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_BeginTransactionRequest, rhs: Macosusesdk_V1_BeginTransactionRequest) -> Bool {
        if lhs.session != rhs.session { return false }
        if lhs.isolationLevel != rhs.isolationLevel { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_BeginTransactionRequest.IsolationLevel: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ISOLATION_LEVEL_UNSPECIFIED\0\u{1}ISOLATION_LEVEL_SERIALIZABLE\0\u{1}ISOLATION_LEVEL_READ_COMMITTED\0")
}

extension Macosusesdk_V1_BeginTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BeginTransactionResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}transaction_id\0\u{1}session\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &transactionID)
            case 2: try decoder.decodeSingularMessageField(value: &_session)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !transactionID.isEmpty {
            try visitor.visitSingularStringField(value: transactionID, fieldNumber: 1)
        }
        try { if let v = self._session {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_BeginTransactionResponse, rhs: Macosusesdk_V1_BeginTransactionResponse) -> Bool {
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs._session != rhs._session { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CommitTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CommitTransactionRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}transaction_id\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &transactionID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !transactionID.isEmpty {
            try visitor.visitSingularStringField(value: transactionID, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CommitTransactionRequest, rhs: Macosusesdk_V1_CommitTransactionRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_RollbackTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RollbackTransactionRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}revision_id\0\u{3}transaction_id\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularStringField(value: &revisionID)
            case 3: try decoder.decodeSingularStringField(value: &transactionID)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        if !revisionID.isEmpty {
            try visitor.visitSingularStringField(value: revisionID, fieldNumber: 2)
        }
        if !transactionID.isEmpty {
            try visitor.visitSingularStringField(value: transactionID, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_RollbackTransactionRequest, rhs: Macosusesdk_V1_RollbackTransactionRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.revisionID != rhs.revisionID { return false }
        if lhs.transactionID != rhs.transactionID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetSessionSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSessionSnapshotRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetSessionSnapshotRequest, rhs: Macosusesdk_V1_GetSessionSnapshotRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureScreenshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureScreenshotRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}format\0\u{1}quality\0\u{1}display\0\u{3}include_ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &format)
            case 2: try decoder.decodeSingularInt32Field(value: &quality)
            case 3: try decoder.decodeSingularInt32Field(value: &display)
            case 4: try decoder.decodeSingularBoolField(value: &includeOcrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 1)
        }
        if quality != 0 {
            try visitor.visitSingularInt32Field(value: quality, fieldNumber: 2)
        }
        if display != 0 {
            try visitor.visitSingularInt32Field(value: display, fieldNumber: 3)
        }
        if includeOcrText != false {
            try visitor.visitSingularBoolField(value: includeOcrText, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureScreenshotRequest, rhs: Macosusesdk_V1_CaptureScreenshotRequest) -> Bool {
        if lhs.format != rhs.format { return false }
        if lhs.quality != rhs.quality { return false }
        if lhs.display != rhs.display { return false }
        if lhs.includeOcrText != rhs.includeOcrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureScreenshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureScreenshotResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_data\0\u{1}format\0\u{1}width\0\u{1}height\0\u{3}ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &imageData)
            case 2: try decoder.decodeSingularEnumField(value: &format)
            case 3: try decoder.decodeSingularInt32Field(value: &width)
            case 4: try decoder.decodeSingularInt32Field(value: &height)
            case 5: try decoder.decodeSingularStringField(value: &ocrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !imageData.isEmpty {
            try visitor.visitSingularBytesField(value: imageData, fieldNumber: 1)
        }
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 2)
        }
        if width != 0 {
            try visitor.visitSingularInt32Field(value: width, fieldNumber: 3)
        }
        if height != 0 {
            try visitor.visitSingularInt32Field(value: height, fieldNumber: 4)
        }
        if !ocrText.isEmpty {
            try visitor.visitSingularStringField(value: ocrText, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureScreenshotResponse, rhs: Macosusesdk_V1_CaptureScreenshotResponse) -> Bool {
        if lhs.imageData != rhs.imageData { return false }
        if lhs.format != rhs.format { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.ocrText != rhs.ocrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureWindowScreenshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureWindowScreenshotRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}window\0\u{1}format\0\u{1}quality\0\u{3}include_shadow\0\u{3}include_ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &window)
            case 2: try decoder.decodeSingularEnumField(value: &format)
            case 3: try decoder.decodeSingularInt32Field(value: &quality)
            case 4: try decoder.decodeSingularBoolField(value: &includeShadow)
            case 5: try decoder.decodeSingularBoolField(value: &includeOcrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !window.isEmpty {
            try visitor.visitSingularStringField(value: window, fieldNumber: 1)
        }
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 2)
        }
        if quality != 0 {
            try visitor.visitSingularInt32Field(value: quality, fieldNumber: 3)
        }
        if includeShadow != false {
            try visitor.visitSingularBoolField(value: includeShadow, fieldNumber: 4)
        }
        if includeOcrText != false {
            try visitor.visitSingularBoolField(value: includeOcrText, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureWindowScreenshotRequest, rhs: Macosusesdk_V1_CaptureWindowScreenshotRequest) -> Bool {
        if lhs.window != rhs.window { return false }
        if lhs.format != rhs.format { return false }
        if lhs.quality != rhs.quality { return false }
        if lhs.includeShadow != rhs.includeShadow { return false }
        if lhs.includeOcrText != rhs.includeOcrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureWindowScreenshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureWindowScreenshotResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_data\0\u{1}format\0\u{1}width\0\u{1}height\0\u{1}window\0\u{3}ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &imageData)
            case 2: try decoder.decodeSingularEnumField(value: &format)
            case 3: try decoder.decodeSingularInt32Field(value: &width)
            case 4: try decoder.decodeSingularInt32Field(value: &height)
            case 5: try decoder.decodeSingularStringField(value: &window)
            case 6: try decoder.decodeSingularStringField(value: &ocrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !imageData.isEmpty {
            try visitor.visitSingularBytesField(value: imageData, fieldNumber: 1)
        }
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 2)
        }
        if width != 0 {
            try visitor.visitSingularInt32Field(value: width, fieldNumber: 3)
        }
        if height != 0 {
            try visitor.visitSingularInt32Field(value: height, fieldNumber: 4)
        }
        if !window.isEmpty {
            try visitor.visitSingularStringField(value: window, fieldNumber: 5)
        }
        if !ocrText.isEmpty {
            try visitor.visitSingularStringField(value: ocrText, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureWindowScreenshotResponse, rhs: Macosusesdk_V1_CaptureWindowScreenshotResponse) -> Bool {
        if lhs.imageData != rhs.imageData { return false }
        if lhs.format != rhs.format { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.window != rhs.window { return false }
        if lhs.ocrText != rhs.ocrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureElementScreenshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureElementScreenshotRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}format\0\u{1}quality\0\u{1}padding\0\u{3}include_ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &parent)
            case 2: try decoder.decodeSingularStringField(value: &elementID)
            case 3: try decoder.decodeSingularEnumField(value: &format)
            case 4: try decoder.decodeSingularInt32Field(value: &quality)
            case 5: try decoder.decodeSingularInt32Field(value: &padding)
            case 6: try decoder.decodeSingularBoolField(value: &includeOcrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !parent.isEmpty {
            try visitor.visitSingularStringField(value: parent, fieldNumber: 1)
        }
        if !elementID.isEmpty {
            try visitor.visitSingularStringField(value: elementID, fieldNumber: 2)
        }
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 3)
        }
        if quality != 0 {
            try visitor.visitSingularInt32Field(value: quality, fieldNumber: 4)
        }
        if padding != 0 {
            try visitor.visitSingularInt32Field(value: padding, fieldNumber: 5)
        }
        if includeOcrText != false {
            try visitor.visitSingularBoolField(value: includeOcrText, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureElementScreenshotRequest, rhs: Macosusesdk_V1_CaptureElementScreenshotRequest) -> Bool {
        if lhs.parent != rhs.parent { return false }
        if lhs.elementID != rhs.elementID { return false }
        if lhs.format != rhs.format { return false }
        if lhs.quality != rhs.quality { return false }
        if lhs.padding != rhs.padding { return false }
        if lhs.includeOcrText != rhs.includeOcrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureElementScreenshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureElementScreenshotResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_data\0\u{1}format\0\u{1}width\0\u{1}height\0\u{3}element_id\0\u{3}ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &imageData)
            case 2: try decoder.decodeSingularEnumField(value: &format)
            case 3: try decoder.decodeSingularInt32Field(value: &width)
            case 4: try decoder.decodeSingularInt32Field(value: &height)
            case 5: try decoder.decodeSingularStringField(value: &elementID)
            case 6: try decoder.decodeSingularStringField(value: &ocrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !imageData.isEmpty {
            try visitor.visitSingularBytesField(value: imageData, fieldNumber: 1)
        }
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 2)
        }
        if width != 0 {
            try visitor.visitSingularInt32Field(value: width, fieldNumber: 3)
        }
        if height != 0 {
            try visitor.visitSingularInt32Field(value: height, fieldNumber: 4)
        }
        if !elementID.isEmpty {
            try visitor.visitSingularStringField(value: elementID, fieldNumber: 5)
        }
        if !ocrText.isEmpty {
            try visitor.visitSingularStringField(value: ocrText, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureElementScreenshotResponse, rhs: Macosusesdk_V1_CaptureElementScreenshotResponse) -> Bool {
        if lhs.imageData != rhs.imageData { return false }
        if lhs.format != rhs.format { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.elementID != rhs.elementID { return false }
        if lhs.ocrText != rhs.ocrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureRegionScreenshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureRegionScreenshotRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0\u{1}format\0\u{1}quality\0\u{1}display\0\u{3}include_ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_region)
            case 2: try decoder.decodeSingularEnumField(value: &format)
            case 3: try decoder.decodeSingularInt32Field(value: &quality)
            case 4: try decoder.decodeSingularInt32Field(value: &display)
            case 5: try decoder.decodeSingularBoolField(value: &includeOcrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _region {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 2)
        }
        if quality != 0 {
            try visitor.visitSingularInt32Field(value: quality, fieldNumber: 3)
        }
        if display != 0 {
            try visitor.visitSingularInt32Field(value: display, fieldNumber: 4)
        }
        if includeOcrText != false {
            try visitor.visitSingularBoolField(value: includeOcrText, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureRegionScreenshotRequest, rhs: Macosusesdk_V1_CaptureRegionScreenshotRequest) -> Bool {
        if lhs._region != rhs._region { return false }
        if lhs.format != rhs.format { return false }
        if lhs.quality != rhs.quality { return false }
        if lhs.display != rhs.display { return false }
        if lhs.includeOcrText != rhs.includeOcrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_CaptureRegionScreenshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CaptureRegionScreenshotResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_data\0\u{1}format\0\u{1}width\0\u{1}height\0\u{1}region\0\u{3}ocr_text\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &imageData)
            case 2: try decoder.decodeSingularEnumField(value: &format)
            case 3: try decoder.decodeSingularInt32Field(value: &width)
            case 4: try decoder.decodeSingularInt32Field(value: &height)
            case 5: try decoder.decodeSingularMessageField(value: &_region)
            case 6: try decoder.decodeSingularStringField(value: &ocrText)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !imageData.isEmpty {
            try visitor.visitSingularBytesField(value: imageData, fieldNumber: 1)
        }
        if format != .unspecified {
            try visitor.visitSingularEnumField(value: format, fieldNumber: 2)
        }
        if width != 0 {
            try visitor.visitSingularInt32Field(value: width, fieldNumber: 3)
        }
        if height != 0 {
            try visitor.visitSingularInt32Field(value: height, fieldNumber: 4)
        }
        try { if let v = self._region {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        if !ocrText.isEmpty {
            try visitor.visitSingularStringField(value: ocrText, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_CaptureRegionScreenshotResponse, rhs: Macosusesdk_V1_CaptureRegionScreenshotResponse) -> Bool {
        if lhs.imageData != rhs.imageData { return false }
        if lhs.format != rhs.format { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs._region != rhs._region { return false }
        if lhs.ocrText != rhs.ocrText { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetClipboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetClipboardRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetClipboardRequest, rhs: Macosusesdk_V1_GetClipboardRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WriteClipboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WriteClipboardRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}content\0\u{3}clear_existing\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_content)
            case 2: try decoder.decodeSingularBoolField(value: &clearExisting_p)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _content {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if clearExisting_p != false {
            try visitor.visitSingularBoolField(value: clearExisting_p, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WriteClipboardRequest, rhs: Macosusesdk_V1_WriteClipboardRequest) -> Bool {
        if lhs._content != rhs._content { return false }
        if lhs.clearExisting_p != rhs.clearExisting_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_WriteClipboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".WriteClipboardResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}type\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularEnumField(value: &type)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if type != .unspecified {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_WriteClipboardResponse, rhs: Macosusesdk_V1_WriteClipboardResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ClearClipboardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ClearClipboardRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ClearClipboardRequest, rhs: Macosusesdk_V1_ClearClipboardRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ClearClipboardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ClearClipboardResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ClearClipboardResponse, rhs: Macosusesdk_V1_ClearClipboardResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetClipboardHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetClipboardHistoryRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetClipboardHistoryRequest, rhs: Macosusesdk_V1_GetClipboardHistoryRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_AutomateOpenFileDialogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AutomateOpenFileDialogRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_path\0\u{3}default_directory\0\u{3}file_filters\0\u{1}timeout\0\u{3}allow_multiple\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &application)
            case 2: try decoder.decodeSingularStringField(value: &filePath)
            case 3: try decoder.decodeSingularStringField(value: &defaultDirectory)
            case 4: try decoder.decodeRepeatedStringField(value: &fileFilters)
            case 5: try decoder.decodeSingularDoubleField(value: &timeout)
            case 6: try decoder.decodeSingularBoolField(value: &allowMultiple)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !application.isEmpty {
            try visitor.visitSingularStringField(value: application, fieldNumber: 1)
        }
        if !filePath.isEmpty {
            try visitor.visitSingularStringField(value: filePath, fieldNumber: 2)
        }
        if !defaultDirectory.isEmpty {
            try visitor.visitSingularStringField(value: defaultDirectory, fieldNumber: 3)
        }
        if !fileFilters.isEmpty {
            try visitor.visitRepeatedStringField(value: fileFilters, fieldNumber: 4)
        }
        if timeout.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: timeout, fieldNumber: 5)
        }
        if allowMultiple != false {
            try visitor.visitSingularBoolField(value: allowMultiple, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_AutomateOpenFileDialogRequest, rhs: Macosusesdk_V1_AutomateOpenFileDialogRequest) -> Bool {
        if lhs.application != rhs.application { return false }
        if lhs.filePath != rhs.filePath { return false }
        if lhs.defaultDirectory != rhs.defaultDirectory { return false }
        if lhs.fileFilters != rhs.fileFilters { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.allowMultiple != rhs.allowMultiple { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_AutomateOpenFileDialogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AutomateOpenFileDialogResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}selected_paths\0\u{1}error\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeRepeatedStringField(value: &selectedPaths)
            case 3: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !selectedPaths.isEmpty {
            try visitor.visitRepeatedStringField(value: selectedPaths, fieldNumber: 2)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_AutomateOpenFileDialogResponse, rhs: Macosusesdk_V1_AutomateOpenFileDialogResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.selectedPaths != rhs.selectedPaths { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_AutomateSaveFileDialogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AutomateSaveFileDialogRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_path\0\u{3}default_directory\0\u{3}default_filename\0\u{1}timeout\0\u{3}confirm_overwrite\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &application)
            case 2: try decoder.decodeSingularStringField(value: &filePath)
            case 3: try decoder.decodeSingularStringField(value: &defaultDirectory)
            case 4: try decoder.decodeSingularStringField(value: &defaultFilename)
            case 5: try decoder.decodeSingularDoubleField(value: &timeout)
            case 6: try decoder.decodeSingularBoolField(value: &confirmOverwrite)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !application.isEmpty {
            try visitor.visitSingularStringField(value: application, fieldNumber: 1)
        }
        if !filePath.isEmpty {
            try visitor.visitSingularStringField(value: filePath, fieldNumber: 2)
        }
        if !defaultDirectory.isEmpty {
            try visitor.visitSingularStringField(value: defaultDirectory, fieldNumber: 3)
        }
        if !defaultFilename.isEmpty {
            try visitor.visitSingularStringField(value: defaultFilename, fieldNumber: 4)
        }
        if timeout.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: timeout, fieldNumber: 5)
        }
        if confirmOverwrite != false {
            try visitor.visitSingularBoolField(value: confirmOverwrite, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_AutomateSaveFileDialogRequest, rhs: Macosusesdk_V1_AutomateSaveFileDialogRequest) -> Bool {
        if lhs.application != rhs.application { return false }
        if lhs.filePath != rhs.filePath { return false }
        if lhs.defaultDirectory != rhs.defaultDirectory { return false }
        if lhs.defaultFilename != rhs.defaultFilename { return false }
        if lhs.timeout != rhs.timeout { return false }
        if lhs.confirmOverwrite != rhs.confirmOverwrite { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_AutomateSaveFileDialogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AutomateSaveFileDialogResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}saved_path\0\u{1}error\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularStringField(value: &savedPath)
            case 3: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !savedPath.isEmpty {
            try visitor.visitSingularStringField(value: savedPath, fieldNumber: 2)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_AutomateSaveFileDialogResponse, rhs: Macosusesdk_V1_AutomateSaveFileDialogResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.savedPath != rhs.savedPath { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_SelectFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SelectFileRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_path\0\u{3}reveal_finder\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &application)
            case 2: try decoder.decodeSingularStringField(value: &filePath)
            case 3: try decoder.decodeSingularBoolField(value: &revealFinder)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !application.isEmpty {
            try visitor.visitSingularStringField(value: application, fieldNumber: 1)
        }
        if !filePath.isEmpty {
            try visitor.visitSingularStringField(value: filePath, fieldNumber: 2)
        }
        if revealFinder != false {
            try visitor.visitSingularBoolField(value: revealFinder, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_SelectFileRequest, rhs: Macosusesdk_V1_SelectFileRequest) -> Bool {
        if lhs.application != rhs.application { return false }
        if lhs.filePath != rhs.filePath { return false }
        if lhs.revealFinder != rhs.revealFinder { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_SelectFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SelectFileResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}selected_path\0\u{1}error\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularStringField(value: &selectedPath)
            case 3: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !selectedPath.isEmpty {
            try visitor.visitSingularStringField(value: selectedPath, fieldNumber: 2)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_SelectFileResponse, rhs: Macosusesdk_V1_SelectFileResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.selectedPath != rhs.selectedPath { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_SelectDirectoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SelectDirectoryRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}directory_path\0\u{3}create_missing\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &application)
            case 2: try decoder.decodeSingularStringField(value: &directoryPath)
            case 3: try decoder.decodeSingularBoolField(value: &createMissing)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !application.isEmpty {
            try visitor.visitSingularStringField(value: application, fieldNumber: 1)
        }
        if !directoryPath.isEmpty {
            try visitor.visitSingularStringField(value: directoryPath, fieldNumber: 2)
        }
        if createMissing != false {
            try visitor.visitSingularBoolField(value: createMissing, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_SelectDirectoryRequest, rhs: Macosusesdk_V1_SelectDirectoryRequest) -> Bool {
        if lhs.application != rhs.application { return false }
        if lhs.directoryPath != rhs.directoryPath { return false }
        if lhs.createMissing != rhs.createMissing { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_SelectDirectoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SelectDirectoryResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}selected_path\0\u{1}created\0\u{1}error\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularStringField(value: &selectedPath)
            case 3: try decoder.decodeSingularBoolField(value: &created)
            case 4: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !selectedPath.isEmpty {
            try visitor.visitSingularStringField(value: selectedPath, fieldNumber: 2)
        }
        if created != false {
            try visitor.visitSingularBoolField(value: created, fieldNumber: 3)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_SelectDirectoryResponse, rhs: Macosusesdk_V1_SelectDirectoryResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.selectedPath != rhs.selectedPath { return false }
        if lhs.created != rhs.created { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_DragFilesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DragFilesRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_paths\0\u{3}target_element_id\0\u{1}duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &application)
            case 2: try decoder.decodeRepeatedStringField(value: &filePaths)
            case 3: try decoder.decodeSingularStringField(value: &targetElementID)
            case 4: try decoder.decodeSingularDoubleField(value: &duration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !application.isEmpty {
            try visitor.visitSingularStringField(value: application, fieldNumber: 1)
        }
        if !filePaths.isEmpty {
            try visitor.visitRepeatedStringField(value: filePaths, fieldNumber: 2)
        }
        if !targetElementID.isEmpty {
            try visitor.visitSingularStringField(value: targetElementID, fieldNumber: 3)
        }
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_DragFilesRequest, rhs: Macosusesdk_V1_DragFilesRequest) -> Bool {
        if lhs.application != rhs.application { return false }
        if lhs.filePaths != rhs.filePaths { return false }
        if lhs.targetElementID != rhs.targetElementID { return false }
        if lhs.duration != rhs.duration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_DragFilesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".DragFilesResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}files_dropped\0\u{1}error\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularInt32Field(value: &filesDropped)
            case 3: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if filesDropped != 0 {
            try visitor.visitSingularInt32Field(value: filesDropped, fieldNumber: 2)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_DragFilesResponse, rhs: Macosusesdk_V1_DragFilesResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.filesDropped != rhs.filesDropped { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteAppleScriptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteAppleScriptRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}script\0\u{1}timeout\0\u{3}compile_only\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &script)
            case 2: try decoder.decodeSingularMessageField(value: &_timeout)
            case 3: try decoder.decodeSingularBoolField(value: &compileOnly)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !script.isEmpty {
            try visitor.visitSingularStringField(value: script, fieldNumber: 1)
        }
        try { if let v = self._timeout {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if compileOnly != false {
            try visitor.visitSingularBoolField(value: compileOnly, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteAppleScriptRequest, rhs: Macosusesdk_V1_ExecuteAppleScriptRequest) -> Bool {
        if lhs.script != rhs.script { return false }
        if lhs._timeout != rhs._timeout { return false }
        if lhs.compileOnly != rhs.compileOnly { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteAppleScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteAppleScriptResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}output\0\u{1}error\0\u{3}execution_duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularStringField(value: &output)
            case 3: try decoder.decodeSingularStringField(value: &error)
            case 4: try decoder.decodeSingularMessageField(value: &_executionDuration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !output.isEmpty {
            try visitor.visitSingularStringField(value: output, fieldNumber: 2)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 3)
        }
        try { if let v = self._executionDuration {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteAppleScriptResponse, rhs: Macosusesdk_V1_ExecuteAppleScriptResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.output != rhs.output { return false }
        if lhs.error != rhs.error { return false }
        if lhs._executionDuration != rhs._executionDuration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteJavaScriptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteJavaScriptRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}script\0\u{1}timeout\0\u{3}compile_only\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &script)
            case 2: try decoder.decodeSingularMessageField(value: &_timeout)
            case 3: try decoder.decodeSingularBoolField(value: &compileOnly)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !script.isEmpty {
            try visitor.visitSingularStringField(value: script, fieldNumber: 1)
        }
        try { if let v = self._timeout {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if compileOnly != false {
            try visitor.visitSingularBoolField(value: compileOnly, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteJavaScriptRequest, rhs: Macosusesdk_V1_ExecuteJavaScriptRequest) -> Bool {
        if lhs.script != rhs.script { return false }
        if lhs._timeout != rhs._timeout { return false }
        if lhs.compileOnly != rhs.compileOnly { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteJavaScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteJavaScriptResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}output\0\u{1}error\0\u{3}execution_duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularStringField(value: &output)
            case 3: try decoder.decodeSingularStringField(value: &error)
            case 4: try decoder.decodeSingularMessageField(value: &_executionDuration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !output.isEmpty {
            try visitor.visitSingularStringField(value: output, fieldNumber: 2)
        }
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 3)
        }
        try { if let v = self._executionDuration {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteJavaScriptResponse, rhs: Macosusesdk_V1_ExecuteJavaScriptResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.output != rhs.output { return false }
        if lhs.error != rhs.error { return false }
        if lhs._executionDuration != rhs._executionDuration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteShellCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteShellCommandRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{1}args\0\u{3}working_directory\0\u{1}environment\0\u{1}timeout\0\u{1}stdin\0\u{1}shell\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &command)
            case 2: try decoder.decodeRepeatedStringField(value: &args)
            case 3: try decoder.decodeSingularStringField(value: &workingDirectory)
            case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &environment)
            case 5: try decoder.decodeSingularMessageField(value: &_timeout)
            case 6: try decoder.decodeSingularStringField(value: &stdin)
            case 7: try decoder.decodeSingularStringField(value: &shell)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !command.isEmpty {
            try visitor.visitSingularStringField(value: command, fieldNumber: 1)
        }
        if !args.isEmpty {
            try visitor.visitRepeatedStringField(value: args, fieldNumber: 2)
        }
        if !workingDirectory.isEmpty {
            try visitor.visitSingularStringField(value: workingDirectory, fieldNumber: 3)
        }
        if !environment.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: environment, fieldNumber: 4)
        }
        try { if let v = self._timeout {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        if !stdin.isEmpty {
            try visitor.visitSingularStringField(value: stdin, fieldNumber: 6)
        }
        if !shell.isEmpty {
            try visitor.visitSingularStringField(value: shell, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteShellCommandRequest, rhs: Macosusesdk_V1_ExecuteShellCommandRequest) -> Bool {
        if lhs.command != rhs.command { return false }
        if lhs.args != rhs.args { return false }
        if lhs.workingDirectory != rhs.workingDirectory { return false }
        if lhs.environment != rhs.environment { return false }
        if lhs._timeout != rhs._timeout { return false }
        if lhs.stdin != rhs.stdin { return false }
        if lhs.shell != rhs.shell { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ExecuteShellCommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ExecuteShellCommandResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}stdout\0\u{1}stderr\0\u{3}exit_code\0\u{3}execution_duration\0\u{1}error\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeSingularStringField(value: &stdout)
            case 3: try decoder.decodeSingularStringField(value: &stderr)
            case 4: try decoder.decodeSingularInt32Field(value: &exitCode)
            case 5: try decoder.decodeSingularMessageField(value: &_executionDuration)
            case 6: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !stdout.isEmpty {
            try visitor.visitSingularStringField(value: stdout, fieldNumber: 2)
        }
        if !stderr.isEmpty {
            try visitor.visitSingularStringField(value: stderr, fieldNumber: 3)
        }
        if exitCode != 0 {
            try visitor.visitSingularInt32Field(value: exitCode, fieldNumber: 4)
        }
        try { if let v = self._executionDuration {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ExecuteShellCommandResponse, rhs: Macosusesdk_V1_ExecuteShellCommandResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.stdout != rhs.stdout { return false }
        if lhs.stderr != rhs.stderr { return false }
        if lhs.exitCode != rhs.exitCode { return false }
        if lhs._executionDuration != rhs._executionDuration { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ValidateScriptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ValidateScriptRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}script\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &type)
            case 2: try decoder.decodeSingularStringField(value: &script)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if type != .unspecified {
            try visitor.visitSingularEnumField(value: type, fieldNumber: 1)
        }
        if !script.isEmpty {
            try visitor.visitSingularStringField(value: script, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ValidateScriptRequest, rhs: Macosusesdk_V1_ValidateScriptRequest) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.script != rhs.script { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ValidateScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ValidateScriptResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}valid\0\u{1}errors\0\u{1}warnings\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &valid)
            case 2: try decoder.decodeRepeatedStringField(value: &errors)
            case 3: try decoder.decodeRepeatedStringField(value: &warnings)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if valid != false {
            try visitor.visitSingularBoolField(value: valid, fieldNumber: 1)
        }
        if !errors.isEmpty {
            try visitor.visitRepeatedStringField(value: errors, fieldNumber: 2)
        }
        if !warnings.isEmpty {
            try visitor.visitRepeatedStringField(value: warnings, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ValidateScriptResponse, rhs: Macosusesdk_V1_ValidateScriptResponse) -> Bool {
        if lhs.valid != rhs.valid { return false }
        if lhs.errors != rhs.errors { return false }
        if lhs.warnings != rhs.warnings { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetScriptingDictionariesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetScriptingDictionariesRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetScriptingDictionariesRequest, rhs: Macosusesdk_V1_GetScriptingDictionariesRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMetricsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetMetricsRequest, rhs: Macosusesdk_V1_GetMetricsRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_GetPerformanceReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetPerformanceReportRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_GetPerformanceReportRequest, rhs: Macosusesdk_V1_GetPerformanceReportRequest) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ResetMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResetMetricsRequest"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}types\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedEnumField(value: &types)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !types.isEmpty {
            try visitor.visitPackedEnumField(value: types, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ResetMetricsRequest, rhs: Macosusesdk_V1_ResetMetricsRequest) -> Bool {
        if lhs.types != rhs.types { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_ResetMetricsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResetMetricsResponse"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}reset_types\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            case 2: try decoder.decodeRepeatedEnumField(value: &resetTypes)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        if !resetTypes.isEmpty {
            try visitor.visitPackedEnumField(value: resetTypes, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_ResetMetricsResponse, rhs: Macosusesdk_V1_ResetMetricsResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.resetTypes != rhs.resetTypes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
