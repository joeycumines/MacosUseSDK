// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/input.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 Joseph Cumines
//
// Input resource definition

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// A resource representing an input action that was or will be executed.
/// Inputs form a timeline for each application.
public struct Macosusesdk_V1_Input: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource name in the format "applications/{application}/inputs/{input}".
    public var name: String = .init()

    /// The specific action to perform or that was performed.
    public var action: Macosusesdk_V1_InputAction {
        get { _action ?? Macosusesdk_V1_InputAction() }
        set { _action = newValue }
    }

    /// Returns true if `action` has been explicitly set.
    public var hasAction: Bool { _action != nil }
    /// Clears the value of `action`. Subsequent reads from it will return its default value.
    public mutating func clearAction() { _action = nil }

    /// Current state of the input.
    public var state: Macosusesdk_V1_Input.State = .unspecified

    /// When the input was created.
    public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _createTime = newValue }
    }

    /// Returns true if `createTime` has been explicitly set.
    public var hasCreateTime: Bool { _createTime != nil }
    /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
    public mutating func clearCreateTime() { _createTime = nil }

    /// When the input completed (success or failure).
    public var completeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _completeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _completeTime = newValue }
    }

    /// Returns true if `completeTime` has been explicitly set.
    public var hasCompleteTime: Bool { _completeTime != nil }
    /// Clears the value of `completeTime`. Subsequent reads from it will return its default value.
    public mutating func clearCompleteTime() { _completeTime = nil }

    /// Error message if the input failed.
    public var error: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// State of an input action.
    public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default unspecified state.
        case unspecified // = 0

        /// Input is pending execution.
        case pending // = 1

        /// Input is currently executing.
        case executing // = 2

        /// Input completed successfully.
        case completed // = 3

        /// Input failed with an error.
        case failed // = 4
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .pending
            case 2: self = .executing
            case 3: self = .completed
            case 4: self = .failed
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .pending: 1
            case .executing: 2
            case .completed: 3
            case .failed: 4
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_Input.State] = [
            .unspecified,
            .pending,
            .executing,
            .completed,
            .failed,
        ]
    }

    public init() {}

    fileprivate var _action: Macosusesdk_V1_InputAction?
    fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp?
    fileprivate var _completeTime: SwiftProtobuf.Google_Protobuf_Timestamp?
}

/// Specification of an input action.
public struct Macosusesdk_V1_InputAction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether to show visual feedback during execution.
    public var showAnimation: Bool = false

    /// Duration of visual feedback in seconds.
    public var animationDuration: Double = 0

    /// The specific input type and parameters.
    public var inputType: Macosusesdk_V1_InputAction.OneOf_InputType?

    /// Click at a specific point.
    public var click: Macosusesdk_V1_MouseClick {
        get {
            if case let .click(v)? = inputType { return v }
            return Macosusesdk_V1_MouseClick()
        }
        set { inputType = .click(newValue) }
    }

    /// Type the specified text.
    public var typeText: Macosusesdk_V1_TextInput {
        get {
            if case let .typeText(v)? = inputType { return v }
            return Macosusesdk_V1_TextInput()
        }
        set { inputType = .typeText(newValue) }
    }

    /// Press a key combination.
    public var pressKey: Macosusesdk_V1_KeyPress {
        get {
            if case let .pressKey(v)? = inputType { return v }
            return Macosusesdk_V1_KeyPress()
        }
        set { inputType = .pressKey(newValue) }
    }

    /// Move mouse to a specific point.
    public var moveMouse: Macosusesdk_V1_MouseMove {
        get {
            if case let .moveMouse(v)? = inputType { return v }
            return Macosusesdk_V1_MouseMove()
        }
        set { inputType = .moveMouse(newValue) }
    }

    /// Drag from one point to another.
    public var drag: Macosusesdk_V1_MouseDrag {
        get {
            if case let .drag(v)? = inputType { return v }
            return Macosusesdk_V1_MouseDrag()
        }
        set { inputType = .drag(newValue) }
    }

    /// Scroll operation.
    public var scroll: Macosusesdk_V1_Scroll {
        get {
            if case let .scroll(v)? = inputType { return v }
            return Macosusesdk_V1_Scroll()
        }
        set { inputType = .scroll(newValue) }
    }

    /// Hover at a point for duration.
    public var hover: Macosusesdk_V1_Hover {
        get {
            if case let .hover(v)? = inputType { return v }
            return Macosusesdk_V1_Hover()
        }
        set { inputType = .hover(newValue) }
    }

    /// Multi-touch gesture.
    public var gesture: Macosusesdk_V1_Gesture {
        get {
            if case let .gesture(v)? = inputType { return v }
            return Macosusesdk_V1_Gesture()
        }
        set { inputType = .gesture(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The specific input type and parameters.
    public enum OneOf_InputType: Equatable, Sendable {
        /// Click at a specific point.
        case click(Macosusesdk_V1_MouseClick)
        /// Type the specified text.
        case typeText(Macosusesdk_V1_TextInput)
        /// Press a key combination.
        case pressKey(Macosusesdk_V1_KeyPress)
        /// Move mouse to a specific point.
        case moveMouse(Macosusesdk_V1_MouseMove)
        /// Drag from one point to another.
        case drag(Macosusesdk_V1_MouseDrag)
        /// Scroll operation.
        case scroll(Macosusesdk_V1_Scroll)
        /// Hover at a point for duration.
        case hover(Macosusesdk_V1_Hover)
        /// Multi-touch gesture.
        case gesture(Macosusesdk_V1_Gesture)
    }

    public init() {}
}

/// Mouse click action.
public struct Macosusesdk_V1_MouseClick: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Position to click.
    public var position: Macosusesdk_Type_Point {
        get { _position ?? Macosusesdk_Type_Point() }
        set { _position = newValue }
    }

    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool { _position != nil }
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() { _position = nil }

    /// Click type.
    public var clickType: Macosusesdk_V1_MouseClick.ClickType = .unspecified

    /// Number of clicks (1 for single, 2 for double, etc.).
    public var clickCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Click type enumeration.
    public enum ClickType: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default left click.
        case unspecified // = 0

        /// Left mouse button.
        case left // = 1

        /// Right mouse button.
        case right // = 2

        /// Middle mouse button.
        case middle // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .left
            case 2: self = .right
            case 3: self = .middle
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .left: 1
            case .right: 2
            case .middle: 3
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_MouseClick.ClickType] = [
            .unspecified,
            .left,
            .right,
            .middle,
        ]
    }

    public init() {}

    fileprivate var _position: Macosusesdk_Type_Point?
}

/// Text input action.
public struct Macosusesdk_V1_TextInput: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Text to type.
    public var text: String = .init()

    /// Whether to use IME for input (for non-ASCII text).
    public var useIme: Bool = false

    /// Delay between characters in seconds.
    public var charDelay: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Key press with optional modifiers.
public struct Macosusesdk_V1_KeyPress: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Key code or name (e.g., "return", "a", "f1").
    public var key: String = .init()

    /// Modifier keys to hold during press.
    public var modifiers: [Macosusesdk_V1_KeyPress.Modifier] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Modifier key enumeration.
    public enum Modifier: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default unspecified modifier.
        case unspecified // = 0

        /// Command (⌘) key.
        case command // = 1

        /// Option (⌥) key.
        case option // = 2

        /// Control (⌃) key.
        case control // = 3

        /// Shift (⇧) key.
        case shift // = 4

        /// Function (fn) key.
        case function // = 5

        /// Caps Lock.
        case capsLock // = 6
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .command
            case 2: self = .option
            case 3: self = .control
            case 4: self = .shift
            case 5: self = .function
            case 6: self = .capsLock
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .command: 1
            case .option: 2
            case .control: 3
            case .shift: 4
            case .function: 5
            case .capsLock: 6
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_KeyPress.Modifier] = [
            .unspecified,
            .command,
            .option,
            .control,
            .shift,
            .function,
            .capsLock,
        ]
    }

    public init() {}
}

/// Mouse move action.
public struct Macosusesdk_V1_MouseMove: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Target position.
    public var position: Macosusesdk_Type_Point {
        get { _position ?? Macosusesdk_Type_Point() }
        set { _position = newValue }
    }

    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool { _position != nil }
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() { _position = nil }

    /// Duration of movement in seconds (for smooth animation).
    public var duration: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _position: Macosusesdk_Type_Point?
}

/// Mouse drag action.
public struct Macosusesdk_V1_MouseDrag: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Starting position.
    public var startPosition: Macosusesdk_Type_Point {
        get { _startPosition ?? Macosusesdk_Type_Point() }
        set { _startPosition = newValue }
    }

    /// Returns true if `startPosition` has been explicitly set.
    public var hasStartPosition: Bool { _startPosition != nil }
    /// Clears the value of `startPosition`. Subsequent reads from it will return its default value.
    public mutating func clearStartPosition() { _startPosition = nil }

    /// Ending position.
    public var endPosition: Macosusesdk_Type_Point {
        get { _endPosition ?? Macosusesdk_Type_Point() }
        set { _endPosition = newValue }
    }

    /// Returns true if `endPosition` has been explicitly set.
    public var hasEndPosition: Bool { _endPosition != nil }
    /// Clears the value of `endPosition`. Subsequent reads from it will return its default value.
    public mutating func clearEndPosition() { _endPosition = nil }

    /// Duration of drag in seconds.
    public var duration: Double = 0

    /// Mouse button to use for drag.
    public var button: Macosusesdk_V1_MouseClick.ClickType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startPosition: Macosusesdk_Type_Point?
    fileprivate var _endPosition: Macosusesdk_Type_Point?
}

/// Scroll action.
public struct Macosusesdk_V1_Scroll: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Position to scroll at (optional, uses current mouse position if not set).
    public var position: Macosusesdk_Type_Point {
        get { _position ?? Macosusesdk_Type_Point() }
        set { _position = newValue }
    }

    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool { _position != nil }
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() { _position = nil }

    /// Horizontal scroll amount (positive = right, negative = left).
    public var horizontal: Double = 0

    /// Vertical scroll amount (positive = up, negative = down).
    public var vertical: Double = 0

    /// Duration of scroll in seconds (for momentum effect).
    public var duration: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _position: Macosusesdk_Type_Point?
}

/// Hover action.
public struct Macosusesdk_V1_Hover: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Position to hover at.
    public var position: Macosusesdk_Type_Point {
        get { _position ?? Macosusesdk_Type_Point() }
        set { _position = newValue }
    }

    /// Returns true if `position` has been explicitly set.
    public var hasPosition: Bool { _position != nil }
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    public mutating func clearPosition() { _position = nil }

    /// Duration to hover in seconds.
    public var duration: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _position: Macosusesdk_Type_Point?
}

/// Multi-touch gesture.
public struct Macosusesdk_V1_Gesture: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Center point of the gesture.
    public var center: Macosusesdk_Type_Point {
        get { _center ?? Macosusesdk_Type_Point() }
        set { _center = newValue }
    }

    /// Returns true if `center` has been explicitly set.
    public var hasCenter: Bool { _center != nil }
    /// Clears the value of `center`. Subsequent reads from it will return its default value.
    public mutating func clearCenter() { _center = nil }

    /// Gesture type.
    public var gestureType: Macosusesdk_V1_Gesture.GestureType = .unspecified

    /// Scale factor (for pinch/zoom gestures).
    public var scale: Double = 0

    /// Rotation angle in degrees (for rotation gestures).
    public var rotation: Double = 0

    /// Number of fingers (for swipe gestures).
    public var fingerCount: Int32 = 0

    /// Direction for swipe gestures.
    public var direction: Macosusesdk_V1_Gesture.Direction = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Gesture type enumeration.
    public enum GestureType: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default unspecified gesture.
        case unspecified // = 0

        /// Pinch (zoom out).
        case pinch // = 1

        /// Zoom (zoom in).
        case zoom // = 2

        /// Rotate.
        case rotate // = 3

        /// Swipe.
        case swipe // = 4

        /// Force touch (pressure-sensitive).
        case forceTouch // = 5
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .pinch
            case 2: self = .zoom
            case 3: self = .rotate
            case 4: self = .swipe
            case 5: self = .forceTouch
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .pinch: 1
            case .zoom: 2
            case .rotate: 3
            case .swipe: 4
            case .forceTouch: 5
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_Gesture.GestureType] = [
            .unspecified,
            .pinch,
            .zoom,
            .rotate,
            .swipe,
            .forceTouch,
        ]
    }

    /// Direction enumeration for swipes.
    public enum Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default unspecified direction.
        case unspecified // = 0

        /// Swipe up.
        case up // = 1

        /// Swipe down.
        case down // = 2

        /// Swipe left.
        case left // = 3

        /// Swipe right.
        case right // = 4
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .up
            case 2: self = .down
            case 3: self = .left
            case 4: self = .right
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .up: 1
            case .down: 2
            case .left: 3
            case .right: 4
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_V1_Gesture.Direction] = [
            .unspecified,
            .up,
            .down,
            .left,
            .right,
        ]
    }

    public init() {}

    fileprivate var _center: Macosusesdk_Type_Point?
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Input"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}action\0\u{1}state\0\u{3}create_time\0\u{3}complete_time\0\u{1}error\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &name)
            case 2: try decoder.decodeSingularMessageField(value: &_action)
            case 3: try decoder.decodeSingularEnumField(value: &state)
            case 4: try decoder.decodeSingularMessageField(value: &_createTime)
            case 5: try decoder.decodeSingularMessageField(value: &_completeTime)
            case 6: try decoder.decodeSingularStringField(value: &error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !name.isEmpty {
            try visitor.visitSingularStringField(value: name, fieldNumber: 1)
        }
        try { if let v = self._action {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if state != .unspecified {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 3)
        }
        try { if let v = self._createTime {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try { if let v = self._completeTime {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
        } }()
        if !error.isEmpty {
            try visitor.visitSingularStringField(value: error, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_Input, rhs: Macosusesdk_V1_Input) -> Bool {
        if lhs.name != rhs.name { return false }
        if lhs._action != rhs._action { return false }
        if lhs.state != rhs.state { return false }
        if lhs._createTime != rhs._createTime { return false }
        if lhs._completeTime != rhs._completeTime { return false }
        if lhs.error != rhs.error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_Input.State: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STATE_UNSPECIFIED\0\u{1}STATE_PENDING\0\u{1}STATE_EXECUTING\0\u{1}STATE_COMPLETED\0\u{1}STATE_FAILED\0")
}

extension Macosusesdk_V1_InputAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".InputAction"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}show_animation\0\u{3}animation_duration\0\u{2}\u{8}click\0\u{3}type_text\0\u{3}press_key\0\u{3}move_mouse\0\u{1}drag\0\u{1}scroll\0\u{1}hover\0\u{1}gesture\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &showAnimation)
            case 2: try decoder.decodeSingularDoubleField(value: &animationDuration)
            case 10: try {
                    var v: Macosusesdk_V1_MouseClick?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .click(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .click(v)
                    }
                }()
            case 11: try {
                    var v: Macosusesdk_V1_TextInput?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .typeText(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .typeText(v)
                    }
                }()
            case 12: try {
                    var v: Macosusesdk_V1_KeyPress?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .pressKey(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .pressKey(v)
                    }
                }()
            case 13: try {
                    var v: Macosusesdk_V1_MouseMove?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .moveMouse(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .moveMouse(v)
                    }
                }()
            case 14: try {
                    var v: Macosusesdk_V1_MouseDrag?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .drag(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .drag(v)
                    }
                }()
            case 15: try {
                    var v: Macosusesdk_V1_Scroll?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .scroll(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .scroll(v)
                    }
                }()
            case 16: try {
                    var v: Macosusesdk_V1_Hover?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .hover(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .hover(v)
                    }
                }()
            case 17: try {
                    var v: Macosusesdk_V1_Gesture?
                    var hadOneofValue = false
                    if let current = self.inputType {
                        hadOneofValue = true
                        if case let .gesture(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.inputType = .gesture(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if showAnimation != false {
            try visitor.visitSingularBoolField(value: showAnimation, fieldNumber: 1)
        }
        if animationDuration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: animationDuration, fieldNumber: 2)
        }
        switch inputType {
        case .click?: try {
                guard case let .click(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .typeText?: try {
                guard case let .typeText(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case .pressKey?: try {
                guard case let .pressKey(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            }()
        case .moveMouse?: try {
                guard case let .moveMouse(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            }()
        case .drag?: try {
                guard case let .drag(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            }()
        case .scroll?: try {
                guard case let .scroll(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            }()
        case .hover?: try {
                guard case let .hover(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
            }()
        case .gesture?: try {
                guard case let .gesture(v)? = self.inputType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_InputAction, rhs: Macosusesdk_V1_InputAction) -> Bool {
        if lhs.showAnimation != rhs.showAnimation { return false }
        if lhs.animationDuration != rhs.animationDuration { return false }
        if lhs.inputType != rhs.inputType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MouseClick: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MouseClick"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0\u{3}click_type\0\u{3}click_count\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_position)
            case 2: try decoder.decodeSingularEnumField(value: &clickType)
            case 3: try decoder.decodeSingularInt32Field(value: &clickCount)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _position {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if clickType != .unspecified {
            try visitor.visitSingularEnumField(value: clickType, fieldNumber: 2)
        }
        if clickCount != 0 {
            try visitor.visitSingularInt32Field(value: clickCount, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MouseClick, rhs: Macosusesdk_V1_MouseClick) -> Bool {
        if lhs._position != rhs._position { return false }
        if lhs.clickType != rhs.clickType { return false }
        if lhs.clickCount != rhs.clickCount { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MouseClick.ClickType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CLICK_TYPE_UNSPECIFIED\0\u{1}CLICK_TYPE_LEFT\0\u{1}CLICK_TYPE_RIGHT\0\u{1}CLICK_TYPE_MIDDLE\0")
}

extension Macosusesdk_V1_TextInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".TextInput"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{3}use_ime\0\u{3}char_delay\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &text)
            case 2: try decoder.decodeSingularBoolField(value: &useIme)
            case 3: try decoder.decodeSingularDoubleField(value: &charDelay)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !text.isEmpty {
            try visitor.visitSingularStringField(value: text, fieldNumber: 1)
        }
        if useIme != false {
            try visitor.visitSingularBoolField(value: useIme, fieldNumber: 2)
        }
        if charDelay.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: charDelay, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_TextInput, rhs: Macosusesdk_V1_TextInput) -> Bool {
        if lhs.text != rhs.text { return false }
        if lhs.useIme != rhs.useIme { return false }
        if lhs.charDelay != rhs.charDelay { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_KeyPress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".KeyPress"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}modifiers\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &key)
            case 2: try decoder.decodeRepeatedEnumField(value: &modifiers)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularStringField(value: key, fieldNumber: 1)
        }
        if !modifiers.isEmpty {
            try visitor.visitPackedEnumField(value: modifiers, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_KeyPress, rhs: Macosusesdk_V1_KeyPress) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.modifiers != rhs.modifiers { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_KeyPress.Modifier: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MODIFIER_UNSPECIFIED\0\u{1}MODIFIER_COMMAND\0\u{1}MODIFIER_OPTION\0\u{1}MODIFIER_CONTROL\0\u{1}MODIFIER_SHIFT\0\u{1}MODIFIER_FUNCTION\0\u{1}MODIFIER_CAPS_LOCK\0")
}

extension Macosusesdk_V1_MouseMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MouseMove"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0\u{1}duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_position)
            case 2: try decoder.decodeSingularDoubleField(value: &duration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _position {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MouseMove, rhs: Macosusesdk_V1_MouseMove) -> Bool {
        if lhs._position != rhs._position { return false }
        if lhs.duration != rhs.duration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_MouseDrag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".MouseDrag"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_position\0\u{3}end_position\0\u{1}duration\0\u{1}button\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_startPosition)
            case 2: try decoder.decodeSingularMessageField(value: &_endPosition)
            case 3: try decoder.decodeSingularDoubleField(value: &duration)
            case 4: try decoder.decodeSingularEnumField(value: &button)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _startPosition {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try { if let v = self._endPosition {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 3)
        }
        if button != .unspecified {
            try visitor.visitSingularEnumField(value: button, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_MouseDrag, rhs: Macosusesdk_V1_MouseDrag) -> Bool {
        if lhs._startPosition != rhs._startPosition { return false }
        if lhs._endPosition != rhs._endPosition { return false }
        if lhs.duration != rhs.duration { return false }
        if lhs.button != rhs.button { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_Scroll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Scroll"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0\u{1}horizontal\0\u{1}vertical\0\u{1}duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_position)
            case 2: try decoder.decodeSingularDoubleField(value: &horizontal)
            case 3: try decoder.decodeSingularDoubleField(value: &vertical)
            case 4: try decoder.decodeSingularDoubleField(value: &duration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _position {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if horizontal.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: horizontal, fieldNumber: 2)
        }
        if vertical.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: vertical, fieldNumber: 3)
        }
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_Scroll, rhs: Macosusesdk_V1_Scroll) -> Bool {
        if lhs._position != rhs._position { return false }
        if lhs.horizontal != rhs.horizontal { return false }
        if lhs.vertical != rhs.vertical { return false }
        if lhs.duration != rhs.duration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_Hover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Hover"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0\u{1}duration\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_position)
            case 2: try decoder.decodeSingularDoubleField(value: &duration)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _position {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if duration.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: duration, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_Hover, rhs: Macosusesdk_V1_Hover) -> Bool {
        if lhs._position != rhs._position { return false }
        if lhs.duration != rhs.duration { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_Gesture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".Gesture"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}center\0\u{3}gesture_type\0\u{1}scale\0\u{1}rotation\0\u{3}finger_count\0\u{1}direction\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_center)
            case 2: try decoder.decodeSingularEnumField(value: &gestureType)
            case 3: try decoder.decodeSingularDoubleField(value: &scale)
            case 4: try decoder.decodeSingularDoubleField(value: &rotation)
            case 5: try decoder.decodeSingularInt32Field(value: &fingerCount)
            case 6: try decoder.decodeSingularEnumField(value: &direction)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if let v = _center {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if gestureType != .unspecified {
            try visitor.visitSingularEnumField(value: gestureType, fieldNumber: 2)
        }
        if scale.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: scale, fieldNumber: 3)
        }
        if rotation.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: rotation, fieldNumber: 4)
        }
        if fingerCount != 0 {
            try visitor.visitSingularInt32Field(value: fingerCount, fieldNumber: 5)
        }
        if direction != .unspecified {
            try visitor.visitSingularEnumField(value: direction, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_V1_Gesture, rhs: Macosusesdk_V1_Gesture) -> Bool {
        if lhs._center != rhs._center { return false }
        if lhs.gestureType != rhs.gestureType { return false }
        if lhs.scale != rhs.scale { return false }
        if lhs.rotation != rhs.rotation { return false }
        if lhs.fingerCount != rhs.fingerCount { return false }
        if lhs.direction != rhs.direction { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_V1_Gesture.GestureType: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0GESTURE_TYPE_UNSPECIFIED\0\u{1}GESTURE_TYPE_PINCH\0\u{1}GESTURE_TYPE_ZOOM\0\u{1}GESTURE_TYPE_ROTATE\0\u{1}GESTURE_TYPE_SWIPE\0\u{1}GESTURE_TYPE_FORCE_TOUCH\0")
}

extension Macosusesdk_V1_Gesture.Direction: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DIRECTION_UNSPECIFIED\0\u{1}DIRECTION_UP\0\u{1}DIRECTION_DOWN\0\u{1}DIRECTION_LEFT\0\u{1}DIRECTION_RIGHT\0")
}
