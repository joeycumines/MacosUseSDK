// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/file.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 MacosUseSDK
//
// File dialog automation and file operations

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to automate an open file dialog.
public struct Macosusesdk_V1_AutomateOpenFileDialogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Application context.
  public var application: String = String()

  /// File path to select (if known).
  public var filePath: String = String()

  /// Default directory to navigate to.
  public var defaultDirectory: String = String()

  /// File type filters (e.g., ["*.txt", "*.pdf"]).
  public var fileFilters: [String] = []

  /// Timeout for dialog to appear (seconds).
  public var timeout: Double = 0

  /// Whether to allow multiple file selection.
  public var allowMultiple: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from automating an open file dialog.
public struct Macosusesdk_V1_AutomateOpenFileDialogResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the operation succeeded.
  public var success: Bool = false

  /// Selected file path(s).
  public var selectedPaths: [String] = []

  /// Error message if failed.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to automate a save file dialog.
public struct Macosusesdk_V1_AutomateSaveFileDialogRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Application context.
  public var application: String = String()

  /// File path to save to.
  public var filePath: String = String()

  /// Default directory to navigate to.
  public var defaultDirectory: String = String()

  /// Default filename.
  public var defaultFilename: String = String()

  /// Timeout for dialog to appear (seconds).
  public var timeout: Double = 0

  /// Whether to confirm overwrite.
  public var confirmOverwrite: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from automating a save file dialog.
public struct Macosusesdk_V1_AutomateSaveFileDialogResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the operation succeeded.
  public var success: Bool = false

  /// Final save path.
  public var savedPath: String = String()

  /// Error message if failed.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to select a file programmatically.
public struct Macosusesdk_V1_SelectFileRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Application context.
  public var application: String = String()

  /// File path to select.
  public var filePath: String = String()

  /// Whether to reveal Finder after selection.
  public var revealFinder: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from selecting a file.
public struct Macosusesdk_V1_SelectFileResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the operation succeeded.
  public var success: Bool = false

  /// Selected file path.
  public var selectedPath: String = String()

  /// Error message if failed.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to select a directory.
public struct Macosusesdk_V1_SelectDirectoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Application context.
  public var application: String = String()

  /// Directory path to select.
  public var directoryPath: String = String()

  /// Whether to create directory when it doesn't exist.
  public var createMissing: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from selecting a directory.
public struct Macosusesdk_V1_SelectDirectoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the operation succeeded.
  public var success: Bool = false

  /// Selected directory path.
  public var selectedPath: String = String()

  /// Whether the directory was created.
  public var created: Bool = false

  /// Error message if failed.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to drag and drop files.
public struct Macosusesdk_V1_DragFilesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Application context.
  public var application: String = String()

  /// File paths to drag.
  public var filePaths: [String] = []

  /// Target element ID to drop on.
  public var targetElementID: String = String()

  /// Drag duration in seconds.
  public var duration: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from dragging files.
public struct Macosusesdk_V1_DragFilesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the operation succeeded.
  public var success: Bool = false

  /// Number of files dropped.
  public var filesDropped: Int32 = 0

  /// Error message if failed.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_AutomateOpenFileDialogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutomateOpenFileDialogRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_path\0\u{3}default_directory\0\u{3}file_filters\0\u{1}timeout\0\u{3}allow_multiple\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultDirectory) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.fileFilters) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.timeout) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.allowMultiple) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 2)
    }
    if !self.defaultDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultDirectory, fieldNumber: 3)
    }
    if !self.fileFilters.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fileFilters, fieldNumber: 4)
    }
    if self.timeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 5)
    }
    if self.allowMultiple != false {
      try visitor.visitSingularBoolField(value: self.allowMultiple, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_AutomateOpenFileDialogRequest, rhs: Macosusesdk_V1_AutomateOpenFileDialogRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.defaultDirectory != rhs.defaultDirectory {return false}
    if lhs.fileFilters != rhs.fileFilters {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.allowMultiple != rhs.allowMultiple {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_AutomateOpenFileDialogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutomateOpenFileDialogResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}selected_paths\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.selectedPaths) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.selectedPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.selectedPaths, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_AutomateOpenFileDialogResponse, rhs: Macosusesdk_V1_AutomateOpenFileDialogResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.selectedPaths != rhs.selectedPaths {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_AutomateSaveFileDialogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutomateSaveFileDialogRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_path\0\u{3}default_directory\0\u{3}default_filename\0\u{1}timeout\0\u{3}confirm_overwrite\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultDirectory) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultFilename) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.timeout) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.confirmOverwrite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 2)
    }
    if !self.defaultDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultDirectory, fieldNumber: 3)
    }
    if !self.defaultFilename.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultFilename, fieldNumber: 4)
    }
    if self.timeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 5)
    }
    if self.confirmOverwrite != false {
      try visitor.visitSingularBoolField(value: self.confirmOverwrite, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_AutomateSaveFileDialogRequest, rhs: Macosusesdk_V1_AutomateSaveFileDialogRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.defaultDirectory != rhs.defaultDirectory {return false}
    if lhs.defaultFilename != rhs.defaultFilename {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.confirmOverwrite != rhs.confirmOverwrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_AutomateSaveFileDialogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutomateSaveFileDialogResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}saved_path\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.savedPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.savedPath.isEmpty {
      try visitor.visitSingularStringField(value: self.savedPath, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_AutomateSaveFileDialogResponse, rhs: Macosusesdk_V1_AutomateSaveFileDialogResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.savedPath != rhs.savedPath {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_SelectFileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelectFileRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_path\0\u{3}reveal_finder\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.revealFinder) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 2)
    }
    if self.revealFinder != false {
      try visitor.visitSingularBoolField(value: self.revealFinder, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_SelectFileRequest, rhs: Macosusesdk_V1_SelectFileRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.revealFinder != rhs.revealFinder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_SelectFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelectFileResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}selected_path\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.selectedPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.selectedPath.isEmpty {
      try visitor.visitSingularStringField(value: self.selectedPath, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_SelectFileResponse, rhs: Macosusesdk_V1_SelectFileResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.selectedPath != rhs.selectedPath {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_SelectDirectoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelectDirectoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}directory_path\0\u{3}create_missing\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.directoryPath) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.createMissing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.directoryPath.isEmpty {
      try visitor.visitSingularStringField(value: self.directoryPath, fieldNumber: 2)
    }
    if self.createMissing != false {
      try visitor.visitSingularBoolField(value: self.createMissing, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_SelectDirectoryRequest, rhs: Macosusesdk_V1_SelectDirectoryRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.directoryPath != rhs.directoryPath {return false}
    if lhs.createMissing != rhs.createMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_SelectDirectoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelectDirectoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}selected_path\0\u{1}created\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.selectedPath) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.created) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.selectedPath.isEmpty {
      try visitor.visitSingularStringField(value: self.selectedPath, fieldNumber: 2)
    }
    if self.created != false {
      try visitor.visitSingularBoolField(value: self.created, fieldNumber: 3)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_SelectDirectoryResponse, rhs: Macosusesdk_V1_SelectDirectoryResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.selectedPath != rhs.selectedPath {return false}
    if lhs.created != rhs.created {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_DragFilesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DragFilesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}application\0\u{3}file_paths\0\u{3}target_element_id\0\u{1}duration\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.application) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.filePaths) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetElementID) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.application.isEmpty {
      try visitor.visitSingularStringField(value: self.application, fieldNumber: 1)
    }
    if !self.filePaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filePaths, fieldNumber: 2)
    }
    if !self.targetElementID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetElementID, fieldNumber: 3)
    }
    if self.duration.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_DragFilesRequest, rhs: Macosusesdk_V1_DragFilesRequest) -> Bool {
    if lhs.application != rhs.application {return false}
    if lhs.filePaths != rhs.filePaths {return false}
    if lhs.targetElementID != rhs.targetElementID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_DragFilesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DragFilesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}files_dropped\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.filesDropped) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if self.filesDropped != 0 {
      try visitor.visitSingularInt32Field(value: self.filesDropped, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_DragFilesResponse, rhs: Macosusesdk_V1_DragFilesResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.filesDropped != rhs.filesDropped {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
