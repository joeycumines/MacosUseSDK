// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/element_methods.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 MacosUseSDK
//
// Element query and interaction methods

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to find elements matching a selector.
public struct Macosusesdk_V1_FindElementsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent context. Either:
  /// - "applications/{application}" to search within an app
  /// - "applications/{application}/windows/{window}" to search within a window
  public var parent: String = String()

  /// Selector for finding elements.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {return _selector ?? Macosusesdk_Type_ElementSelector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  public var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  public mutating func clearSelector() {self._selector = nil}

  /// Maximum number of elements to return.
  public var pageSize: Int32 = 0

  /// Page token from a previous FindElements call.
  public var pageToken: String = String()

  /// Whether to search only visible elements.
  public var visibleOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selector: Macosusesdk_Type_ElementSelector? = nil
}

/// Response from finding elements.
public struct Macosusesdk_V1_FindElementsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Elements matching the selector.
  public var elements: [Macosusesdk_Type_Element] = []

  /// Token to retrieve the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to find elements within a screen region.
public struct Macosusesdk_V1_FindRegionElementsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent context (same as FindElementsRequest).
  public var parent: String = String()

  /// Region to search within (screen coordinates).
  public var region: Macosusesdk_V1_Region {
    get {return _region ?? Macosusesdk_V1_Region()}
    set {_region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  public var hasRegion: Bool {return self._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  public mutating func clearRegion() {self._region = nil}

  /// Optional selector for additional filtering.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {return _selector ?? Macosusesdk_Type_ElementSelector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  public var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  public mutating func clearSelector() {self._selector = nil}

  /// Maximum number of elements to return.
  public var pageSize: Int32 = 0

  /// Page token from a previous call.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _region: Macosusesdk_V1_Region? = nil
  fileprivate var _selector: Macosusesdk_Type_ElementSelector? = nil
}

/// Response from finding elements in a region.
public struct Macosusesdk_V1_FindRegionElementsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Elements within the region.
  public var elements: [Macosusesdk_Type_Element] = []

  /// Token to retrieve the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get a specific element by its resource name.
public struct Macosusesdk_V1_GetElementRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the element to retrieve.
  /// Format: applications/{application}/elements/{element}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to click an element.
public struct Macosusesdk_V1_ClickElementRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent context.
  public var parent: String = String()

  /// Element ID or selector.
  public var target: Macosusesdk_V1_ClickElementRequest.OneOf_Target? = nil

  /// Element ID to click.
  public var elementID: String {
    get {
      if case .elementID(let v)? = target {return v}
      return String()
    }
    set {target = .elementID(newValue)}
  }

  /// Selector to find element to click.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {
      if case .selector(let v)? = target {return v}
      return Macosusesdk_Type_ElementSelector()
    }
    set {target = .selector(newValue)}
  }

  /// Click type (single, double, right-click).
  public var clickType: Macosusesdk_V1_ClickElementRequest.ClickType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Element ID or selector.
  public enum OneOf_Target: Equatable, Sendable {
    /// Element ID to click.
    case elementID(String)
    /// Selector to find element to click.
    case selector(Macosusesdk_Type_ElementSelector)

  }

  /// Click type enumeration.
  public enum ClickType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Default single click.
    case unspecified // = 0

    /// Single left-click.
    case single // = 1

    /// Double-click.
    case double // = 2

    /// Right-click.
    case right // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .single
      case 2: self = .double
      case 3: self = .right
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .single: return 1
      case .double: return 2
      case .right: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Macosusesdk_V1_ClickElementRequest.ClickType] = [
      .unspecified,
      .single,
      .double,
      .right,
    ]

  }

  public init() {}
}

/// Response from clicking an element.
public struct Macosusesdk_V1_ClickElementResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the click was successful.
  public var success: Bool = false

  /// The element that was clicked.
  public var element: Macosusesdk_Type_Element {
    get {return _element ?? Macosusesdk_Type_Element()}
    set {_element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  public var hasElement: Bool {return self._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  public mutating func clearElement() {self._element = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _element: Macosusesdk_Type_Element? = nil
}

/// Request to write an element's value.
public struct Macosusesdk_V1_WriteElementValueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent context.
  public var parent: String = String()

  /// Element ID or selector.
  public var target: Macosusesdk_V1_WriteElementValueRequest.OneOf_Target? = nil

  /// Element ID to modify.
  public var elementID: String {
    get {
      if case .elementID(let v)? = target {return v}
      return String()
    }
    set {target = .elementID(newValue)}
  }

  /// Selector to find element to modify.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {
      if case .selector(let v)? = target {return v}
      return Macosusesdk_Type_ElementSelector()
    }
    set {target = .selector(newValue)}
  }

  /// Value to write.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Element ID or selector.
  public enum OneOf_Target: Equatable, Sendable {
    /// Element ID to modify.
    case elementID(String)
    /// Selector to find element to modify.
    case selector(Macosusesdk_Type_ElementSelector)

  }

  public init() {}
}

/// Response from writing an element's value.
public struct Macosusesdk_V1_WriteElementValueResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the operation was successful.
  public var success: Bool = false

  /// The element that was modified.
  public var element: Macosusesdk_Type_Element {
    get {return _element ?? Macosusesdk_Type_Element()}
    set {_element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  public var hasElement: Bool {return self._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  public mutating func clearElement() {self._element = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _element: Macosusesdk_Type_Element? = nil
}

/// Request to get available actions for an element.
public struct Macosusesdk_V1_GetElementActionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the element to get actions for.
  /// Format: applications/{application}/elements/{element}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Available actions for an element.
public struct Macosusesdk_V1_ElementActions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Available action names.
  public var actions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to perform an accessibility action on an element.
public struct Macosusesdk_V1_PerformElementActionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent context.
  public var parent: String = String()

  /// Element ID or selector.
  public var target: Macosusesdk_V1_PerformElementActionRequest.OneOf_Target? = nil

  /// Element ID.
  public var elementID: String {
    get {
      if case .elementID(let v)? = target {return v}
      return String()
    }
    set {target = .elementID(newValue)}
  }

  /// Selector to find element.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {
      if case .selector(let v)? = target {return v}
      return Macosusesdk_Type_ElementSelector()
    }
    set {target = .selector(newValue)}
  }

  /// Action name to perform.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Element ID or selector.
  public enum OneOf_Target: Equatable, Sendable {
    /// Element ID.
    case elementID(String)
    /// Selector to find element.
    case selector(Macosusesdk_Type_ElementSelector)

  }

  public init() {}
}

/// Response from performing an element action.
public struct Macosusesdk_V1_PerformElementActionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the action was successful.
  public var success: Bool = false

  /// The element.
  public var element: Macosusesdk_Type_Element {
    get {return _element ?? Macosusesdk_Type_Element()}
    set {_element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  public var hasElement: Bool {return self._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  public mutating func clearElement() {self._element = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _element: Macosusesdk_Type_Element? = nil
}

/// Request to wait for an element to appear (long-running operation).
public struct Macosusesdk_V1_WaitElementRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent context.
  public var parent: String = String()

  /// Selector for the element to wait for.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {return _selector ?? Macosusesdk_Type_ElementSelector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  public var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  public mutating func clearSelector() {self._selector = nil}

  /// Maximum time to wait in seconds (default: 30).
  public var timeout: Double = 0

  /// Poll interval in seconds (default: 0.5).
  public var pollInterval: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selector: Macosusesdk_Type_ElementSelector? = nil
}

/// Response from waiting for an element.
public struct Macosusesdk_V1_WaitElementResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The element that appeared.
  public var element: Macosusesdk_Type_Element {
    get {return _element ?? Macosusesdk_Type_Element()}
    set {_element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  public var hasElement: Bool {return self._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  public mutating func clearElement() {self._element = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _element: Macosusesdk_Type_Element? = nil
}

/// Metadata for WaitElement long-running operation.
public struct Macosusesdk_V1_WaitElementMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The selector being waited for.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {return _selector ?? Macosusesdk_Type_ElementSelector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  public var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  public mutating func clearSelector() {self._selector = nil}

  /// Number of poll attempts so far.
  public var attempts: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _selector: Macosusesdk_Type_ElementSelector? = nil
}

/// Request to wait for an element to reach a specific state.
public struct Macosusesdk_V1_WaitElementStateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parent context.
  public var parent: String = String()

  /// Element ID or selector.
  public var target: Macosusesdk_V1_WaitElementStateRequest.OneOf_Target? = nil

  /// Element ID.
  public var elementID: String {
    get {
      if case .elementID(let v)? = target {return v}
      return String()
    }
    set {target = .elementID(newValue)}
  }

  /// Selector to find element.
  public var selector: Macosusesdk_Type_ElementSelector {
    get {
      if case .selector(let v)? = target {return v}
      return Macosusesdk_Type_ElementSelector()
    }
    set {target = .selector(newValue)}
  }

  /// State condition to wait for.
  public var condition: Macosusesdk_V1_StateCondition {
    get {return _condition ?? Macosusesdk_V1_StateCondition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  /// Maximum time to wait in seconds (default: 30).
  public var timeout: Double = 0

  /// Poll interval in seconds (default: 0.5).
  public var pollInterval: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Element ID or selector.
  public enum OneOf_Target: Equatable, Sendable {
    /// Element ID.
    case elementID(String)
    /// Selector to find element.
    case selector(Macosusesdk_Type_ElementSelector)

  }

  public init() {}

  fileprivate var _condition: Macosusesdk_V1_StateCondition? = nil
}

/// State condition for waiting.
public struct Macosusesdk_V1_StateCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Condition type.
  public var condition: Macosusesdk_V1_StateCondition.OneOf_Condition? = nil

  /// Wait for element to be enabled.
  public var enabled: Bool {
    get {
      if case .enabled(let v)? = condition {return v}
      return false
    }
    set {condition = .enabled(newValue)}
  }

  /// Wait for element to be focused.
  public var focused: Bool {
    get {
      if case .focused(let v)? = condition {return v}
      return false
    }
    set {condition = .focused(newValue)}
  }

  /// Wait for element text to match.
  public var textEquals: String {
    get {
      if case .textEquals(let v)? = condition {return v}
      return String()
    }
    set {condition = .textEquals(newValue)}
  }

  /// Wait for element text to contain substring.
  public var textContains: String {
    get {
      if case .textContains(let v)? = condition {return v}
      return String()
    }
    set {condition = .textContains(newValue)}
  }

  /// Wait for element to have specific attribute value.
  public var attribute: Macosusesdk_V1_AttributeCondition {
    get {
      if case .attribute(let v)? = condition {return v}
      return Macosusesdk_V1_AttributeCondition()
    }
    set {condition = .attribute(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Condition type.
  public enum OneOf_Condition: Equatable, Sendable {
    /// Wait for element to be enabled.
    case enabled(Bool)
    /// Wait for element to be focused.
    case focused(Bool)
    /// Wait for element text to match.
    case textEquals(String)
    /// Wait for element text to contain substring.
    case textContains(String)
    /// Wait for element to have specific attribute value.
    case attribute(Macosusesdk_V1_AttributeCondition)

  }

  public init() {}
}

/// Attribute condition for waiting.
public struct Macosusesdk_V1_AttributeCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name.
  public var name: String = String()

  /// Attribute name.
  public var attribute: String = String()

  /// Expected attribute value.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from waiting for element state.
public struct Macosusesdk_V1_WaitElementStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The element in the expected state.
  public var element: Macosusesdk_Type_Element {
    get {return _element ?? Macosusesdk_Type_Element()}
    set {_element = newValue}
  }
  /// Returns true if `element` has been explicitly set.
  public var hasElement: Bool {return self._element != nil}
  /// Clears the value of `element`. Subsequent reads from it will return its default value.
  public mutating func clearElement() {self._element = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _element: Macosusesdk_Type_Element? = nil
}

/// Metadata for WaitElementState operation.
public struct Macosusesdk_V1_WaitElementStateMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The condition being waited for.
  public var condition: Macosusesdk_V1_StateCondition {
    get {return _condition ?? Macosusesdk_V1_StateCondition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  /// Number of poll attempts so far.
  public var attempts: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _condition: Macosusesdk_V1_StateCondition? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_FindElementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindElementsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}selector\0\u{3}page_size\0\u{3}page_token\0\u{3}visible_only\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.visibleOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if self.visibleOnly != false {
      try visitor.visitSingularBoolField(value: self.visibleOnly, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_FindElementsRequest, rhs: Macosusesdk_V1_FindElementsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.visibleOnly != rhs.visibleOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_FindElementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindElementsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}elements\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_FindElementsResponse, rhs: Macosusesdk_V1_FindElementsResponse) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_FindRegionElementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindRegionElementsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}region\0\u{1}selector\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._region) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._region {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_FindRegionElementsRequest, rhs: Macosusesdk_V1_FindRegionElementsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._region != rhs._region {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_FindRegionElementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FindRegionElementsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}elements\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_FindRegionElementsResponse, rhs: Macosusesdk_V1_FindRegionElementsResponse) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_GetElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetElementRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_GetElementRequest, rhs: Macosusesdk_V1_GetElementRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ClickElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClickElementRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{3}click_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .elementID(v)
        }
      }()
      case 3: try {
        var v: Macosusesdk_Type_ElementSelector?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .selector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .selector(v)
        }
      }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.clickType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    switch self.target {
    case .elementID?: try {
      guard case .elementID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .selector?: try {
      guard case .selector(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.clickType != .unspecified {
      try visitor.visitSingularEnumField(value: self.clickType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ClickElementRequest, rhs: Macosusesdk_V1_ClickElementRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.target != rhs.target {return false}
    if lhs.clickType != rhs.clickType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ClickElementRequest.ClickType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CLICK_TYPE_UNSPECIFIED\0\u{1}CLICK_TYPE_SINGLE\0\u{1}CLICK_TYPE_DOUBLE\0\u{1}CLICK_TYPE_RIGHT\0")
}

extension Macosusesdk_V1_ClickElementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClickElementResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}element\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ClickElementResponse, rhs: Macosusesdk_V1_ClickElementResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WriteElementValueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteElementValueRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .elementID(v)
        }
      }()
      case 3: try {
        var v: Macosusesdk_Type_ElementSelector?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .selector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .selector(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    switch self.target {
    case .elementID?: try {
      guard case .elementID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .selector?: try {
      guard case .selector(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WriteElementValueRequest, rhs: Macosusesdk_V1_WriteElementValueRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.target != rhs.target {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WriteElementValueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteElementValueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}element\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WriteElementValueResponse, rhs: Macosusesdk_V1_WriteElementValueResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_GetElementActionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetElementActionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_GetElementActionsRequest, rhs: Macosusesdk_V1_GetElementActionsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ElementActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ElementActions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}actions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.actions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ElementActions, rhs: Macosusesdk_V1_ElementActions) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_PerformElementActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PerformElementActionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{1}action\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .elementID(v)
        }
      }()
      case 3: try {
        var v: Macosusesdk_Type_ElementSelector?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .selector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .selector(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    switch self.target {
    case .elementID?: try {
      guard case .elementID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .selector?: try {
      guard case .selector(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_PerformElementActionRequest, rhs: Macosusesdk_V1_PerformElementActionRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.target != rhs.target {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_PerformElementActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PerformElementActionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}element\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_PerformElementActionResponse, rhs: Macosusesdk_V1_PerformElementActionResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitElementRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{1}selector\0\u{1}timeout\0\u{3}poll_interval\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.timeout) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.pollInterval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 3)
    }
    if self.pollInterval.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.pollInterval, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitElementRequest, rhs: Macosusesdk_V1_WaitElementRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.pollInterval != rhs.pollInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitElementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitElementResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}element\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitElementResponse, rhs: Macosusesdk_V1_WaitElementResponse) -> Bool {
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitElementMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitElementMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}selector\0\u{1}attempts\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.attempts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.attempts != 0 {
      try visitor.visitSingularInt32Field(value: self.attempts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitElementMetadata, rhs: Macosusesdk_V1_WaitElementMetadata) -> Bool {
    if lhs._selector != rhs._selector {return false}
    if lhs.attempts != rhs.attempts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitElementStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitElementStateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}parent\0\u{3}element_id\0\u{1}selector\0\u{1}condition\0\u{1}timeout\0\u{3}poll_interval\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .elementID(v)
        }
      }()
      case 3: try {
        var v: Macosusesdk_Type_ElementSelector?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .selector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .selector(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.timeout) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.pollInterval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    switch self.target {
    case .elementID?: try {
      guard case .elementID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .selector?: try {
      guard case .selector(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.timeout.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 5)
    }
    if self.pollInterval.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.pollInterval, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitElementStateRequest, rhs: Macosusesdk_V1_WaitElementStateRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.target != rhs.target {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.pollInterval != rhs.pollInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_StateCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}focused\0\u{3}text_equals\0\u{3}text_contains\0\u{1}attribute\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .enabled(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .focused(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .textEquals(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.condition != nil {try decoder.handleConflictingOneOf()}
          self.condition = .textContains(v)
        }
      }()
      case 5: try {
        var v: Macosusesdk_V1_AttributeCondition?
        var hadOneofValue = false
        if let current = self.condition {
          hadOneofValue = true
          if case .attribute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.condition = .attribute(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.condition {
    case .enabled?: try {
      guard case .enabled(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .focused?: try {
      guard case .focused(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .textEquals?: try {
      guard case .textEquals(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .textContains?: try {
      guard case .textContains(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .attribute?: try {
      guard case .attribute(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_StateCondition, rhs: Macosusesdk_V1_StateCondition) -> Bool {
    if lhs.condition != rhs.condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_AttributeCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeCondition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}attribute\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attribute) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.attribute.isEmpty {
      try visitor.visitSingularStringField(value: self.attribute, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_AttributeCondition, rhs: Macosusesdk_V1_AttributeCondition) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitElementStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitElementStateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}element\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._element) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._element {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitElementStateResponse, rhs: Macosusesdk_V1_WaitElementStateResponse) -> Bool {
    if lhs._element != rhs._element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_WaitElementStateMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WaitElementStateMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}condition\0\u{1}attempts\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.attempts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.attempts != 0 {
      try visitor.visitSingularInt32Field(value: self.attempts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_WaitElementStateMetadata, rhs: Macosusesdk_V1_WaitElementStateMetadata) -> Bool {
    if lhs._condition != rhs._condition {return false}
    if lhs.attempts != rhs.attempts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
