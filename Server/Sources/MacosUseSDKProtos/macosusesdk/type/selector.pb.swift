// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/type/selector.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 Joseph Cumines
//
// Element selector types for querying UI elements

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// Selector for finding UI elements in the accessibility tree.
///
/// SELECTOR GRAMMAR AND SEMANTICS:
///
/// 1. SIMPLE SELECTORS (all fully implemented):
///    - role: "button"                     → Match by AXRole (case-sensitive)
///    - text: "Submit"                     → Exact text match (AXValue or AXTitle)
///    - text_contains: "Submit"            → Substring match (case-sensitive)
///    - text_regex: "^Submit.*"            → Regex match using NSRegularExpression
///    - position: {x: 100, y: 200, tol: 5} → Match element at screen coordinates ±tolerance
///    - attributes: {"AXEnabled": "1"}     → Match custom accessibility attributes (all must match)
///
/// 2. COMPOUND SELECTORS (fully implemented):
///    - OPERATOR_AND: All sub-selectors must match
///    - OPERATOR_OR:  At least one sub-selector must match
///    - OPERATOR_NOT: Single sub-selector must NOT match (requires exactly 1 selector)
///
/// 3. EMPTY SELECTOR:
///    - criteria unset → matches ALL elements (use with caution, can return many results)
///
/// 4. VALIDATION RULES (enforced by SelectorParser):
///    - role: cannot be empty string
///    - text_contains: cannot be empty string
///    - text_regex: must be valid NSRegularExpression pattern
///    - position: tolerance cannot be negative
///    - attributes: must have at least one key-value pair
///    - compound: must have at least one selector; NOT requires exactly one
///
/// 5. MATCHING SEMANTICS:
///    - text/text_contains/text_regex: Check AXValue first, fall back to AXTitle
///    - role: Exact match against AXRole (e.g., "AXButton", "AXTextField")
///    - position: Element bounds must contain point (x,y) within tolerance
///    - attributes: All specified attributes must match element's accessibility attributes
///
/// 6. PERFORMANCE CONSIDERATIONS:
///    - Simple selectors (role, text, text_contains, position) are optimized
///    - Regex and attribute selectors require full tree traversal
///    - Compound selectors with AND can short-circuit on first failure
///
/// EXAMPLES:
///
///   // Find button with text "Submit"
///   { role: "AXButton", text: "Submit" }  // INVALID: can't mix criteria in oneof
///   { compound: { operator: AND, selectors: [
///       { role: "AXButton" },
///       { text: "Submit" }
///   ]}}
///
///   // Find any button OR link
///   { compound: { operator: OR, selectors: [
///       { role: "AXButton" },
///       { role: "AXLink" }
///   ]}}
///
///   // Find elements NOT containing "Error"
///   { compound: { operator: NOT, selectors: [
///       { text_contains: "Error" }
///   ]}}
///
///   // Find element at screen position (100, 200) with 10px tolerance
///   { position: { x: 100, y: 200, tolerance: 10 }}
///
/// FILES:
///   - Implementation: Server/Sources/MacosUseServer/SelectorParser.swift
///   - Matching logic: Server/Sources/MacosUseServer/ElementLocator.swift
public struct Macosusesdk_Type_ElementSelector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Selector criteria (at least one must be specified).
    public var criteria: Macosusesdk_Type_ElementSelector.OneOf_Criteria?

    /// Select by role (e.g., "button", "textField").
    public var role: String {
        get {
            if case let .role(v)? = criteria { return v }
            return String()
        }
        set { criteria = .role(newValue) }
    }

    /// Select by text content (exact match).
    public var text: String {
        get {
            if case let .text(v)? = criteria { return v }
            return String()
        }
        set { criteria = .text(newValue) }
    }

    /// Select by text containing a substring.
    public var textContains: String {
        get {
            if case let .textContains(v)? = criteria { return v }
            return String()
        }
        set { criteria = .textContains(newValue) }
    }

    /// Select by text matching a regular expression.
    public var textRegex: String {
        get {
            if case let .textRegex(v)? = criteria { return v }
            return String()
        }
        set { criteria = .textRegex(newValue) }
    }

    /// Select by position on screen.
    public var position: Macosusesdk_Type_PositionSelector {
        get {
            if case let .position(v)? = criteria { return v }
            return Macosusesdk_Type_PositionSelector()
        }
        set { criteria = .position(newValue) }
    }

    /// Select by attributes.
    public var attributes: Macosusesdk_Type_AttributeSelector {
        get {
            if case let .attributes(v)? = criteria { return v }
            return Macosusesdk_Type_AttributeSelector()
        }
        set { criteria = .attributes(newValue) }
    }

    /// Compound selector (combine multiple criteria).
    public var compound: Macosusesdk_Type_CompoundSelector {
        get {
            if case let .compound(v)? = criteria { return v }
            return Macosusesdk_Type_CompoundSelector()
        }
        set { criteria = .compound(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Selector criteria (at least one must be specified).
    public enum OneOf_Criteria: Equatable, Sendable {
        /// Select by role (e.g., "button", "textField").
        case role(String)
        /// Select by text content (exact match).
        case text(String)
        /// Select by text containing a substring.
        case textContains(String)
        /// Select by text matching a regular expression.
        case textRegex(String)
        /// Select by position on screen.
        case position(Macosusesdk_Type_PositionSelector)
        /// Select by attributes.
        case attributes(Macosusesdk_Type_AttributeSelector)
        /// Compound selector (combine multiple criteria).
        case compound(Macosusesdk_Type_CompoundSelector)
    }

    public init() {}
}

/// Select element by screen position.
public struct Macosusesdk_Type_PositionSelector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// X coordinate (screen coordinates).
    public var x: Double = 0

    /// Y coordinate (screen coordinates).
    public var y: Double = 0

    /// Tolerance for matching position (in pixels).
    public var tolerance: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Select element by accessibility attributes.
public struct Macosusesdk_Type_AttributeSelector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Attributes to match (all must match).
    public var attributes: [String: String] = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// Compound selector combining multiple criteria.
public struct Macosusesdk_Type_CompoundSelector: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Operator for combining selectors.
    public var `operator`: Macosusesdk_Type_CompoundSelector.Operator = .unspecified

    /// Selectors to combine.
    public var selectors: [Macosusesdk_Type_ElementSelector] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Operator for combining selectors.
    public enum Operator: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// Default unspecified operator.
        case unspecified // = 0

        /// All selectors must match (AND).
        case and // = 1

        /// At least one selector must match (OR).
        case or // = 2

        /// Selector must not match (NOT - only valid with single selector).
        case not // = 3
        case UNRECOGNIZED(Int)

        public init() {
            self = .unspecified
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unspecified
            case 1: self = .and
            case 2: self = .or
            case 3: self = .not
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .unspecified: 0
            case .and: 1
            case .or: 2
            case .not: 3
            case let .UNRECOGNIZED(i): i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Macosusesdk_Type_CompoundSelector.Operator] = [
            .unspecified,
            .and,
            .or,
            .not,
        ]
    }

    public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "macosusesdk.type"

extension Macosusesdk_Type_ElementSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ElementSelector"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}role\0\u{1}text\0\u{3}text_contains\0\u{3}text_regex\0\u{1}position\0\u{1}attributes\0\u{1}compound\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.criteria != nil { try decoder.handleConflictingOneOf() }
                        self.criteria = .role(v)
                    }
                }()
            case 2: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.criteria != nil { try decoder.handleConflictingOneOf() }
                        self.criteria = .text(v)
                    }
                }()
            case 3: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.criteria != nil { try decoder.handleConflictingOneOf() }
                        self.criteria = .textContains(v)
                    }
                }()
            case 4: try {
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v {
                        if self.criteria != nil { try decoder.handleConflictingOneOf() }
                        self.criteria = .textRegex(v)
                    }
                }()
            case 5: try {
                    var v: Macosusesdk_Type_PositionSelector?
                    var hadOneofValue = false
                    if let current = self.criteria {
                        hadOneofValue = true
                        if case let .position(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.criteria = .position(v)
                    }
                }()
            case 6: try {
                    var v: Macosusesdk_Type_AttributeSelector?
                    var hadOneofValue = false
                    if let current = self.criteria {
                        hadOneofValue = true
                        if case let .attributes(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.criteria = .attributes(v)
                    }
                }()
            case 7: try {
                    var v: Macosusesdk_Type_CompoundSelector?
                    var hadOneofValue = false
                    if let current = self.criteria {
                        hadOneofValue = true
                        if case let .compound(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.criteria = .compound(v)
                    }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch criteria {
        case .role?: try {
                guard case let .role(v)? = self.criteria else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 1)
            }()
        case .text?: try {
                guard case let .text(v)? = self.criteria else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case .textContains?: try {
                guard case let .textContains(v)? = self.criteria else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 3)
            }()
        case .textRegex?: try {
                guard case let .textRegex(v)? = self.criteria else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 4)
            }()
        case .position?: try {
                guard case let .position(v)? = self.criteria else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case .attributes?: try {
                guard case let .attributes(v)? = self.criteria else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .compound?: try {
                guard case let .compound(v)? = self.criteria else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_Type_ElementSelector, rhs: Macosusesdk_Type_ElementSelector) -> Bool {
        if lhs.criteria != rhs.criteria { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_Type_PositionSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PositionSelector"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{1}tolerance\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularDoubleField(value: &x)
            case 2: try decoder.decodeSingularDoubleField(value: &y)
            case 3: try decoder.decodeSingularDoubleField(value: &tolerance)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if x.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: x, fieldNumber: 1)
        }
        if y.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: y, fieldNumber: 2)
        }
        if tolerance.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: tolerance, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_Type_PositionSelector, rhs: Macosusesdk_Type_PositionSelector) -> Bool {
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.tolerance != rhs.tolerance { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_Type_AttributeSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AttributeSelector"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}attributes\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: &attributes)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !attributes.isEmpty {
            try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self, value: attributes, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_Type_AttributeSelector, rhs: Macosusesdk_Type_AttributeSelector) -> Bool {
        if lhs.attributes != rhs.attributes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_Type_CompoundSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".CompoundSelector"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}operator\0\u{1}selectors\0")

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &self.operator)
            case 2: try decoder.decodeRepeatedMessageField(value: &selectors)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if self.operator != .unspecified {
            try visitor.visitSingularEnumField(value: self.operator, fieldNumber: 1)
        }
        if !selectors.isEmpty {
            try visitor.visitRepeatedMessageField(value: selectors, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: Macosusesdk_Type_CompoundSelector, rhs: Macosusesdk_Type_CompoundSelector) -> Bool {
        if lhs.operator != rhs.operator { return false }
        if lhs.selectors != rhs.selectors { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Macosusesdk_Type_CompoundSelector.Operator: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OPERATOR_UNSPECIFIED\0\u{1}OPERATOR_AND\0\u{1}OPERATOR_OR\0\u{1}OPERATOR_NOT\0")
}
