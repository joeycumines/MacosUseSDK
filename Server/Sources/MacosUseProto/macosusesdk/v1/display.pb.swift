// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: macosusesdk/v1/display.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 Joseph Cumines
//
// Display resource and listing RPCs

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A physical display/screen attached to the system.
public struct Macosusesdk_V1_Display: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Display ID (CGDirectDisplayID). Treated as opaque by clients.
  public var displayID: Int64 = 0

  /// Display frame in Global Display Coordinates (top-left origin).
  public var frame: Macosusesdk_Type_Region {
    get {return _frame ?? Macosusesdk_Type_Region()}
    set {_frame = newValue}
  }
  /// Returns true if `frame` has been explicitly set.
  public var hasFrame: Bool {return self._frame != nil}
  /// Clears the value of `frame`. Subsequent reads from it will return its default value.
  public mutating func clearFrame() {self._frame = nil}

  /// Visible frame (excluding menu bar and dock) in Global Display Coordinates (top-left origin).
  public var visibleFrame: Macosusesdk_Type_Region {
    get {return _visibleFrame ?? Macosusesdk_Type_Region()}
    set {_visibleFrame = newValue}
  }
  /// Returns true if `visibleFrame` has been explicitly set.
  public var hasVisibleFrame: Bool {return self._visibleFrame != nil}
  /// Clears the value of `visibleFrame`. Subsequent reads from it will return its default value.
  public mutating func clearVisibleFrame() {self._visibleFrame = nil}

  /// True if this is the main (primary) display.
  public var isMain: Bool = false

  /// Scale factor (backingScaleFactor). For Retina displays this is typically 2.0.
  public var scale: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _frame: Macosusesdk_Type_Region? = nil
  fileprivate var _visibleFrame: Macosusesdk_Type_Region? = nil
}

/// Request to list displays.
public struct Macosusesdk_V1_ListDisplaysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Maximum number of displays to return.
  public var pageSize: Int32 = 0

  /// Page token from a previous ListDisplays call.
  /// This token is opaque and its structure must not be relied upon by clients.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response from listing displays.
public struct Macosusesdk_V1_ListDisplaysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The displays in arbitrary order. For stable ordering use the display_id.
  public var displays: [Macosusesdk_V1_Display] = []

  /// Token to retrieve the next page of results. This token is opaque and its structure must
  /// not be relied upon by clients. An empty value indicates no more results are available.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "macosusesdk.v1"

extension Macosusesdk_V1_Display: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Display"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}display_id\0\u{1}frame\0\u{3}visible_frame\0\u{3}is_main\0\u{1}scale\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.displayID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._frame) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._visibleFrame) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMain) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.scale) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.displayID != 0 {
      try visitor.visitSingularInt64Field(value: self.displayID, fieldNumber: 1)
    }
    try { if let v = self._frame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._visibleFrame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.isMain != false {
      try visitor.visitSingularBoolField(value: self.isMain, fieldNumber: 4)
    }
    if self.scale.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.scale, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_Display, rhs: Macosusesdk_V1_Display) -> Bool {
    if lhs.displayID != rhs.displayID {return false}
    if lhs._frame != rhs._frame {return false}
    if lhs._visibleFrame != rhs._visibleFrame {return false}
    if lhs.isMain != rhs.isMain {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ListDisplaysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDisplaysRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ListDisplaysRequest, rhs: Macosusesdk_V1_ListDisplaysRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Macosusesdk_V1_ListDisplaysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDisplaysResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}displays\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.displays) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displays.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.displays, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Macosusesdk_V1_ListDisplaysResponse, rhs: Macosusesdk_V1_ListDisplaysResponse) -> Bool {
    if lhs.displays != rhs.displays {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
