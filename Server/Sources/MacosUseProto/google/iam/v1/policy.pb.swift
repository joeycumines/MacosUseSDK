// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/iam/v1/policy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role.
///
/// For some types of Google Cloud resources, a `binding` can also specify a
/// `condition`, which is a logical expression that allows access to a resource
/// only if the expression evaluates to `true`. A condition can add constraints
/// based on attributes of the request, the resource, or both. To learn which
/// resources support conditions in their IAM policies, see the
/// [IAM
/// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
///
/// **JSON example:**
///
/// ```
///     {
///       "bindings": [
///         {
///           "role": "roles/resourcemanager.organizationAdmin",
///           "members": [
///             "user:mike@example.com",
///             "group:admins@example.com",
///             "domain:google.com",
///             "serviceAccount:my-project-id@appspot.gserviceaccount.com"
///           ]
///         },
///         {
///           "role": "roles/resourcemanager.organizationViewer",
///           "members": [
///             "user:eve@example.com"
///           ],
///           "condition": {
///             "title": "expirable access",
///             "description": "Does not grant access after Sep 2020",
///             "expression": "request.time <
///             timestamp('2020-10-01T00:00:00.000Z')",
///           }
///         }
///       ],
///       "etag": "BwWWja0YfJA=",
///       "version": 3
///     }
/// ```
///
/// **YAML example:**
///
/// ```
///     bindings:
///     - members:
///       - user:mike@example.com
///       - group:admins@example.com
///       - domain:google.com
///       - serviceAccount:my-project-id@appspot.gserviceaccount.com
///       role: roles/resourcemanager.organizationAdmin
///     - members:
///       - user:eve@example.com
///       role: roles/resourcemanager.organizationViewer
///       condition:
///         title: expirable access
///         description: Does not grant access after Sep 2020
///         expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
///     etag: BwWWja0YfJA=
///     version: 3
/// ```
///
/// For a description of IAM and its features, see the
/// [IAM documentation](https://cloud.google.com/iam/docs/).
public struct Google_Iam_V1_Policy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected.
  ///
  /// Any operation that affects conditional role bindings must specify version
  /// `3`. This requirement applies to the following operations:
  ///
  /// * Getting a policy that includes a conditional role binding
  /// * Adding a conditional role binding to a policy
  /// * Changing a conditional role binding in a policy
  /// * Removing any role binding, with or without a condition, from a policy
  ///   that includes conditions
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag` field
  /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
  /// you to overwrite a version `3` policy with a version `1` policy, and all of
  /// the conditions in the version `3` policy are lost.
  ///
  /// If a policy does not include any conditions, operations on that policy may
  /// specify any valid version or leave the field unset.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  public var version: Int32 = 0

  /// Associates a list of `members`, or principals, with a `role`. Optionally,
  /// may specify a `condition` that determines how and when the `bindings` are
  /// applied. Each of the `bindings` must contain at least one principal.
  ///
  /// The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
  /// of these principals can be Google groups. Each occurrence of a principal
  /// counts towards these limits. For example, if the `bindings` grant 50
  /// different roles to `user:alice@example.com`, and not to any other
  /// principal, then you can add another 1,450 principals to the `bindings` in
  /// the `Policy`.
  public var bindings: [Google_Iam_V1_Binding] = []

  /// Specifies cloud audit logging configuration for this policy.
  public var auditConfigs: [Google_Iam_V1_AuditConfig] = []

  /// `etag` is used for optimistic concurrency control as a way to help
  /// prevent simultaneous updates of a policy from overwriting each other.
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the policy.
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag` field
  /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
  /// you to overwrite a version `3` policy with a version `1` policy, and all of
  /// the conditions in the version `3` policy are lost.
  public var etag: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Associates `members`, or principals, with a `role`.
public struct Google_Iam_V1_Binding: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Role that is assigned to the list of `members`, or principals.
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  public var role: String = String()

  /// Specifies the principals requesting access for a Google Cloud resource.
  /// `members` can have the following values:
  ///
  /// * `allUsers`: A special identifier that represents anyone who is
  ///    on the internet; with or without a Google account.
  ///
  /// * `allAuthenticatedUsers`: A special identifier that represents anyone
  ///    who is authenticated with a Google account or a service account.
  ///
  /// * `user:{emailid}`: An email address that represents a specific Google
  ///    account. For example, `alice@example.com` .
  ///
  ///
  /// * `serviceAccount:{emailid}`: An email address that represents a service
  ///    account. For example, `my-other-app@appspot.gserviceaccount.com`.
  ///
  /// * `group:{emailid}`: An email address that represents a Google group.
  ///    For example, `admins@example.com`.
  ///
  /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  ///    identifier) representing a user that has been recently deleted. For
  ///    example, `alice@example.com?uid=123456789012345678901`. If the user is
  ///    recovered, this value reverts to `user:{emailid}` and the recovered user
  ///    retains the role in the binding.
  ///
  /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
  ///    unique identifier) representing a service account that has been recently
  ///    deleted. For example,
  ///    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
  ///    If the service account is undeleted, this value reverts to
  ///    `serviceAccount:{emailid}` and the undeleted service account retains the
  ///    role in the binding.
  ///
  /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
  ///    identifier) representing a Google group that has been recently
  ///    deleted. For example, `admins@example.com?uid=123456789012345678901`. If
  ///    the group is recovered, this value reverts to `group:{emailid}` and the
  ///    recovered group retains the role in the binding.
  ///
  ///
  /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
  ///    users of that domain. For example, `google.com` or `example.com`.
  public var members: [String] = []

  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request.
  ///
  /// If the condition evaluates to `false`, then this binding does not apply to
  /// the current request. However, a different role binding might grant the same
  /// role to one or more of the principals in this binding.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  public var condition: Google_Type_Expr {
    get {return _condition ?? Google_Type_Expr()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _condition: Google_Type_Expr? = nil
}

/// Specifies the audit configuration for a service.
/// The configuration determines which permission types are logged, and what
/// identities, if any, are exempted from logging.
/// An AuditConfig must have one or more AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service,
/// the union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
///     {
///       "audit_configs": [
///         {
///           "service": "allServices",
///           "audit_log_configs": [
///             {
///               "log_type": "DATA_READ",
///               "exempted_members": [
///                 "user:jose@example.com"
///               ]
///             },
///             {
///               "log_type": "DATA_WRITE"
///             },
///             {
///               "log_type": "ADMIN_READ"
///             }
///           ]
///         },
///         {
///           "service": "sampleservice.googleapis.com",
///           "audit_log_configs": [
///             {
///               "log_type": "DATA_READ"
///             },
///             {
///               "log_type": "DATA_WRITE",
///               "exempted_members": [
///                 "user:aliya@example.com"
///               ]
///             }
///           ]
///         }
///       ]
///     }
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts `jose@example.com` from DATA_READ logging, and
/// `aliya@example.com` from DATA_WRITE logging.
public struct Google_Iam_V1_AuditConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies a service that will be enabled for audit logging.
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  public var service: String = String()

  /// The configuration for logging of each type of permission.
  public var auditLogConfigs: [Google_Iam_V1_AuditLogConfig] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Provides the configuration for logging a type of permissions.
/// Example:
///
///     {
///       "audit_log_configs": [
///         {
///           "log_type": "DATA_READ",
///           "exempted_members": [
///             "user:jose@example.com"
///           ]
///         },
///         {
///           "log_type": "DATA_WRITE"
///         }
///       ]
///     }
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
public struct Google_Iam_V1_AuditLogConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The log type that this config enables.
  public var logType: Google_Iam_V1_AuditLogConfig.LogType = .unspecified

  /// Specifies the identities that do not cause logging for this type of
  /// permission.
  /// Follows the same format of
  /// [Binding.members][google.iam.v1.Binding.members].
  public var exemptedMembers: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The list of valid permission types for which logging can be configured.
  /// Admin writes are always logged, and are not configurable.
  public enum LogType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Default case. Should never be this.
    case unspecified // = 0

    /// Admin reads. Example: CloudIAM getIamPolicy
    case adminRead // = 1

    /// Data writes. Example: CloudSQL Users create
    case dataWrite // = 2

    /// Data reads. Example: CloudSQL Users list
    case dataRead // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .adminRead
      case 2: self = .dataWrite
      case 3: self = .dataRead
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .adminRead: return 1
      case .dataWrite: return 2
      case .dataRead: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Iam_V1_AuditLogConfig.LogType] = [
      .unspecified,
      .adminRead,
      .dataWrite,
      .dataRead,
    ]

  }

  public init() {}
}

/// The difference delta between two policies.
public struct Google_Iam_V1_PolicyDelta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The delta for Bindings between two policies.
  public var bindingDeltas: [Google_Iam_V1_BindingDelta] = []

  /// The delta for AuditConfigs between two policies.
  public var auditConfigDeltas: [Google_Iam_V1_AuditConfigDelta] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// One delta entry for Binding. Each individual change (only one member in each
/// entry) to a binding will be a separate entry.
public struct Google_Iam_V1_BindingDelta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action that was performed on a Binding.
  /// Required
  public var action: Google_Iam_V1_BindingDelta.Action = .unspecified

  /// Role that is assigned to `members`.
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  /// Required
  public var role: String = String()

  /// A single identity requesting access for a Google Cloud resource.
  /// Follows the same format of Binding.members.
  /// Required
  public var member: String = String()

  /// The condition that is associated with this binding.
  public var condition: Google_Type_Expr {
    get {return _condition ?? Google_Type_Expr()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of action performed on a Binding in a policy.
  public enum Action: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Addition of a Binding.
    case add // = 1

    /// Removal of a Binding.
    case remove // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .add
      case 2: self = .remove
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .add: return 1
      case .remove: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Iam_V1_BindingDelta.Action] = [
      .unspecified,
      .add,
      .remove,
    ]

  }

  public init() {}

  fileprivate var _condition: Google_Type_Expr? = nil
}

/// One delta entry for AuditConfig. Each individual change (only one
/// exempted_member in each entry) to a AuditConfig will be a separate entry.
public struct Google_Iam_V1_AuditConfigDelta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action that was performed on an audit configuration in a policy.
  /// Required
  public var action: Google_Iam_V1_AuditConfigDelta.Action = .unspecified

  /// Specifies a service that was configured for Cloud Audit Logging.
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  /// Required
  public var service: String = String()

  /// A single identity that is exempted from "data access" audit
  /// logging for the `service` specified above.
  /// Follows the same format of Binding.members.
  public var exemptedMember: String = String()

  /// Specifies the log_type that was be enabled. ADMIN_ACTIVITY is always
  /// enabled, and cannot be configured.
  /// Required
  public var logType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of action performed on an audit configuration in a policy.
  public enum Action: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Addition of an audit configuration.
    case add // = 1

    /// Removal of an audit configuration.
    case remove // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .add
      case 2: self = .remove
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .add: return 1
      case .remove: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Google_Iam_V1_AuditConfigDelta.Action] = [
      .unspecified,
      .add,
      .remove,
    ]

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.iam.v1"

extension Google_Iam_V1_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{2}\u{2}etag\0\u{1}bindings\0\u{4}\u{2}audit_configs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.etag) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bindings) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.auditConfigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularBytesField(value: self.etag, fieldNumber: 3)
    }
    if !self.bindings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bindings, fieldNumber: 4)
    }
    if !self.auditConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auditConfigs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1_Policy, rhs: Google_Iam_V1_Policy) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.bindings != rhs.bindings {return false}
    if lhs.auditConfigs != rhs.auditConfigs {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1_Binding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Binding"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}role\0\u{1}members\0\u{1}condition\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 2)
    }
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1_Binding, rhs: Google_Iam_V1_Binding) -> Bool {
    if lhs.role != rhs.role {return false}
    if lhs.members != rhs.members {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1_AuditConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}service\0\u{4}\u{2}audit_log_configs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.auditLogConfigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if !self.auditLogConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auditLogConfigs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1_AuditConfig, rhs: Google_Iam_V1_AuditConfig) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.auditLogConfigs != rhs.auditLogConfigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1_AuditLogConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditLogConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}log_type\0\u{3}exempted_members\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.logType) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.exemptedMembers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logType != .unspecified {
      try visitor.visitSingularEnumField(value: self.logType, fieldNumber: 1)
    }
    if !self.exemptedMembers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exemptedMembers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1_AuditLogConfig, rhs: Google_Iam_V1_AuditLogConfig) -> Bool {
    if lhs.logType != rhs.logType {return false}
    if lhs.exemptedMembers != rhs.exemptedMembers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1_AuditLogConfig.LogType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0LOG_TYPE_UNSPECIFIED\0\u{1}ADMIN_READ\0\u{1}DATA_WRITE\0\u{1}DATA_READ\0")
}

extension Google_Iam_V1_PolicyDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolicyDelta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}binding_deltas\0\u{3}audit_config_deltas\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.bindingDeltas) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.auditConfigDeltas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bindingDeltas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bindingDeltas, fieldNumber: 1)
    }
    if !self.auditConfigDeltas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auditConfigDeltas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1_PolicyDelta, rhs: Google_Iam_V1_PolicyDelta) -> Bool {
    if lhs.bindingDeltas != rhs.bindingDeltas {return false}
    if lhs.auditConfigDeltas != rhs.auditConfigDeltas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1_BindingDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindingDelta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}action\0\u{1}role\0\u{1}member\0\u{1}condition\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.member) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .unspecified {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if !self.member.isEmpty {
      try visitor.visitSingularStringField(value: self.member, fieldNumber: 3)
    }
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1_BindingDelta, rhs: Google_Iam_V1_BindingDelta) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.role != rhs.role {return false}
    if lhs.member != rhs.member {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1_BindingDelta.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ACTION_UNSPECIFIED\0\u{1}ADD\0\u{1}REMOVE\0")
}

extension Google_Iam_V1_AuditConfigDelta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuditConfigDelta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}action\0\u{1}service\0\u{3}exempted_member\0\u{3}log_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.exemptedMember) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.logType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .unspecified {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 2)
    }
    if !self.exemptedMember.isEmpty {
      try visitor.visitSingularStringField(value: self.exemptedMember, fieldNumber: 3)
    }
    if !self.logType.isEmpty {
      try visitor.visitSingularStringField(value: self.logType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1_AuditConfigDelta, rhs: Google_Iam_V1_AuditConfigDelta) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.service != rhs.service {return false}
    if lhs.exemptedMember != rhs.exemptedMember {return false}
    if lhs.logType != rhs.logType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1_AuditConfigDelta.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ACTION_UNSPECIFIED\0\u{1}ADD\0\u{1}REMOVE\0")
}
