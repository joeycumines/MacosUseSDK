// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/api/expr/v1beta1/value.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents a CEL value.
///
/// This is similar to `google.protobuf.Value`, but can represent CEL's full
/// range of values.
public struct Google_Api_Expr_V1beta1_Value: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The valid kinds of values.
  public var kind: Google_Api_Expr_V1beta1_Value.OneOf_Kind? = nil

  /// Null value.
  public var nullValue: SwiftProtobuf.Google_Protobuf_NullValue {
    get {
      if case .nullValue(let v)? = kind {return v}
      return .nullValue
    }
    set {kind = .nullValue(newValue)}
  }

  /// Boolean value.
  public var boolValue: Bool {
    get {
      if case .boolValue(let v)? = kind {return v}
      return false
    }
    set {kind = .boolValue(newValue)}
  }

  /// Signed integer value.
  public var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = kind {return v}
      return 0
    }
    set {kind = .int64Value(newValue)}
  }

  /// Unsigned integer value.
  public var uint64Value: UInt64 {
    get {
      if case .uint64Value(let v)? = kind {return v}
      return 0
    }
    set {kind = .uint64Value(newValue)}
  }

  /// Floating point value.
  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = kind {return v}
      return 0
    }
    set {kind = .doubleValue(newValue)}
  }

  /// UTF-8 string value.
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = kind {return v}
      return String()
    }
    set {kind = .stringValue(newValue)}
  }

  /// Byte string value.
  public var bytesValue: Data {
    get {
      if case .bytesValue(let v)? = kind {return v}
      return Data()
    }
    set {kind = .bytesValue(newValue)}
  }

  /// An enum value.
  public var enumValue: Google_Api_Expr_V1beta1_EnumValue {
    get {
      if case .enumValue(let v)? = kind {return v}
      return Google_Api_Expr_V1beta1_EnumValue()
    }
    set {kind = .enumValue(newValue)}
  }

  /// The proto message backing an object value.
  public var objectValue: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .objectValue(let v)? = kind {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {kind = .objectValue(newValue)}
  }

  /// Map value.
  public var mapValue: Google_Api_Expr_V1beta1_MapValue {
    get {
      if case .mapValue(let v)? = kind {return v}
      return Google_Api_Expr_V1beta1_MapValue()
    }
    set {kind = .mapValue(newValue)}
  }

  /// List value.
  public var listValue: Google_Api_Expr_V1beta1_ListValue {
    get {
      if case .listValue(let v)? = kind {return v}
      return Google_Api_Expr_V1beta1_ListValue()
    }
    set {kind = .listValue(newValue)}
  }

  /// A Type value represented by the fully qualified name of the type.
  public var typeValue: String {
    get {
      if case .typeValue(let v)? = kind {return v}
      return String()
    }
    set {kind = .typeValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The valid kinds of values.
  public enum OneOf_Kind: Equatable, Sendable {
    /// Null value.
    case nullValue(SwiftProtobuf.Google_Protobuf_NullValue)
    /// Boolean value.
    case boolValue(Bool)
    /// Signed integer value.
    case int64Value(Int64)
    /// Unsigned integer value.
    case uint64Value(UInt64)
    /// Floating point value.
    case doubleValue(Double)
    /// UTF-8 string value.
    case stringValue(String)
    /// Byte string value.
    case bytesValue(Data)
    /// An enum value.
    case enumValue(Google_Api_Expr_V1beta1_EnumValue)
    /// The proto message backing an object value.
    case objectValue(SwiftProtobuf.Google_Protobuf_Any)
    /// Map value.
    case mapValue(Google_Api_Expr_V1beta1_MapValue)
    /// List value.
    case listValue(Google_Api_Expr_V1beta1_ListValue)
    /// A Type value represented by the fully qualified name of the type.
    case typeValue(String)

  }

  public init() {}
}

/// An enum value.
public struct Google_Api_Expr_V1beta1_EnumValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully qualified name of the enum type.
  public var type: String = String()

  /// The value of the enum.
  public var value: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A list.
///
/// Wrapped in a message so 'not set' and empty can be differentiated, which is
/// required for use in a 'oneof'.
public struct Google_Api_Expr_V1beta1_ListValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ordered values in the list.
  public var values: [Google_Api_Expr_V1beta1_Value] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A map.
///
/// Wrapped in a message so 'not set' and empty can be differentiated, which is
/// required for use in a 'oneof'.
public struct Google_Api_Expr_V1beta1_MapValue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of map entries.
  ///
  /// CEL has fewer restrictions on keys, so a protobuf map represenation
  /// cannot be used.
  public var entries: [Google_Api_Expr_V1beta1_MapValue.Entry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An entry in the map.
  public struct Entry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key.
    ///
    /// Must be unique with in the map.
    /// Currently only boolean, int, uint, and string values can be keys.
    public var key: Google_Api_Expr_V1beta1_Value {
      get {return _key ?? Google_Api_Expr_V1beta1_Value()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {self._key = nil}

    /// The value.
    public var value: Google_Api_Expr_V1beta1_Value {
      get {return _value ?? Google_Api_Expr_V1beta1_Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _key: Google_Api_Expr_V1beta1_Value? = nil
    fileprivate var _value: Google_Api_Expr_V1beta1_Value? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.api.expr.v1beta1"

extension Google_Api_Expr_V1beta1_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Value"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}null_value\0\u{3}bool_value\0\u{3}int64_value\0\u{3}uint64_value\0\u{3}double_value\0\u{3}string_value\0\u{3}bytes_value\0\u{4}\u{2}enum_value\0\u{3}object_value\0\u{3}map_value\0\u{3}list_value\0\u{4}\u{3}type_value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_NullValue?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .nullValue(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .boolValue(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .int64Value(v)
        }
      }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .uint64Value(v)
        }
      }()
      case 5: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .doubleValue(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .stringValue(v)
        }
      }()
      case 7: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .bytesValue(v)
        }
      }()
      case 9: try {
        var v: Google_Api_Expr_V1beta1_EnumValue?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .enumValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .enumValue(v)
        }
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .objectValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .objectValue(v)
        }
      }()
      case 11: try {
        var v: Google_Api_Expr_V1beta1_MapValue?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .mapValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .mapValue(v)
        }
      }()
      case 12: try {
        var v: Google_Api_Expr_V1beta1_ListValue?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .listValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .listValue(v)
        }
      }()
      case 15: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .typeValue(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .nullValue?: try {
      guard case .nullValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .int64Value?: try {
      guard case .int64Value(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .uint64Value?: try {
      guard case .uint64Value(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 5)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .bytesValue?: try {
      guard case .bytesValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }()
    case .enumValue?: try {
      guard case .enumValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .objectValue?: try {
      guard case .objectValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .mapValue?: try {
      guard case .mapValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .listValue?: try {
      guard case .listValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .typeValue?: try {
      guard case .typeValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_Value, rhs: Google_Api_Expr_V1beta1_Value) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_EnumValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnumValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_EnumValue, rhs: Google_Api_Expr_V1beta1_EnumValue) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_ListValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_ListValue, rhs: Google_Api_Expr_V1beta1_ListValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_MapValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MapValue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_MapValue, rhs: Google_Api_Expr_V1beta1_MapValue) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Api_Expr_V1beta1_MapValue.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Api_Expr_V1beta1_MapValue.protoMessageName + ".Entry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Api_Expr_V1beta1_MapValue.Entry, rhs: Google_Api_Expr_V1beta1_MapValue.Entry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
