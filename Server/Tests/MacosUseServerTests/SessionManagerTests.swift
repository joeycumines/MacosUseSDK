import MacosUseProto
@testable import MacosUseServer
import XCTest

/// Unit tests for SessionManager state machine and session lifecycle.
/// These tests verify session creation, transaction management, and resource tracking.
final class SessionManagerTests: XCTestCase {
    // MARK: - SessionError Tests

    func testSessionErrorSessionNotFoundDescription() {
        let error = SessionError.sessionNotFound
        XCTAssertEqual(error.description, "Session not found")
    }

    func testSessionErrorTransactionAlreadyActiveDescription() {
        let error = SessionError.transactionAlreadyActive
        XCTAssertEqual(error.description, "Transaction already active for this session")
    }

    func testSessionErrorNoActiveTransactionDescription() {
        let error = SessionError.noActiveTransaction
        XCTAssertEqual(error.description, "No active transaction for this session")
    }

    func testSessionErrorTransactionMismatchDescription() {
        let error = SessionError.transactionMismatch
        XCTAssertEqual(error.description, "Transaction ID does not match active transaction")
    }

    func testSessionErrorInvalidSessionStateDescription() {
        let error = SessionError.invalidSessionState
        XCTAssertEqual(error.description, "Session is not in a valid state for this operation")
    }

    func testSessionErrorRevisionNotFoundDescription() {
        let error = SessionError.revisionNotFound
        XCTAssertEqual(error.description, "Revision ID not found")
    }

    func testAllSessionErrorCasesConformToCustomStringConvertible() {
        let allErrors: [SessionError] = [
            .sessionNotFound,
            .transactionAlreadyActive,
            .noActiveTransaction,
            .transactionMismatch,
            .invalidSessionState,
            .revisionNotFound,
        ]
        for error in allErrors {
            XCTAssertFalse(error.description.isEmpty)
        }
    }

    // MARK: - Session Creation Tests

    func testCreateSessionWithProvidedId() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-session-id-1",
            displayName: "Test Session",
            metadata: [:],
        )

        XCTAssertEqual(session.name, "sessions/test-session-id-1")
        XCTAssertEqual(session.displayName, "Test Session")
        XCTAssertEqual(session.state, .active)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testCreateSessionWithAutoGeneratedId() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: nil,
            displayName: "Auto ID Session",
            metadata: [:],
        )

        XCTAssertTrue(session.name.hasPrefix("sessions/"))
        XCTAssertTrue(session.name.count > "sessions/".count)
        XCTAssertEqual(session.state, .active)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testCreateSessionWithMetadata() async {
        let manager = SessionManager.shared
        let metadata = ["key1": "value1", "key2": "value2"]

        let session = await manager.createSession(
            sessionId: "test-metadata-session",
            displayName: "Metadata Session",
            metadata: metadata,
        )

        XCTAssertEqual(session.metadata["key1"], "value1")
        XCTAssertEqual(session.metadata["key2"], "value2")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testCreateSessionSetsTimestamps() async {
        let manager = SessionManager.shared
        let beforeCreate = Date()

        let session = await manager.createSession(
            sessionId: "test-timestamps",
            displayName: "Timestamp Session",
            metadata: [:],
        )

        let afterCreate = Date()
        let createTime = session.createTime.date
        let lastAccessTime = session.lastAccessTime.date
        let expireTime = session.expireTime.date

        XCTAssertGreaterThanOrEqual(createTime, beforeCreate)
        XCTAssertLessThanOrEqual(createTime, afterCreate)
        XCTAssertEqual(createTime, lastAccessTime)
        XCTAssertGreaterThan(expireTime, createTime)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Session Retrieval Tests

    func testGetSessionReturnsNilForNonExistent() async {
        let manager = SessionManager.shared

        let session = await manager.getSession(name: "sessions/nonexistent-session")
        XCTAssertNil(session)
    }

    func testGetSessionUpdatesLastAccessTime() async throws {
        let manager = SessionManager.shared

        let created = await manager.createSession(
            sessionId: "test-access-time",
            displayName: "Access Time Test",
            metadata: [:],
        )
        let initialAccessTime = created.lastAccessTime.date

        // Small delay to ensure time difference
        try? await Task.sleep(nanoseconds: 10_000_000) // 10ms

        let retrievedOptional = await manager.getSession(name: created.name)
        let retrieved = try XCTUnwrap(retrievedOptional)
        XCTAssertGreaterThanOrEqual(retrieved.lastAccessTime.date, initialAccessTime)

        // Cleanup
        _ = await manager.deleteSession(name: created.name)
    }

    // MARK: - Session Deletion Tests

    func testDeleteSessionReturnsFalseForNonExistent() async {
        let manager = SessionManager.shared

        let deleted = await manager.deleteSession(name: "sessions/nonexistent-delete")
        XCTAssertFalse(deleted)
    }

    func testDeleteSessionReturnsTrueAndRemoves() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-delete",
            displayName: "Delete Session",
            metadata: [:],
        )

        let deleted = await manager.deleteSession(name: session.name)
        XCTAssertTrue(deleted)

        let retrieved = await manager.getSession(name: session.name)
        XCTAssertNil(retrieved)
    }

    // MARK: - Session Listing Tests

    func testListSessionsEmptyResult() async {
        // Create a fresh manager context by cleaning up first
        let manager = SessionManager.shared

        // Create and immediately delete to get a clean state
        let testSession = await manager.createSession(
            sessionId: "temp-cleanup",
            displayName: "Temp",
            metadata: [:],
        )
        _ = await manager.deleteSession(name: testSession.name)

        // Note: We can't fully isolate due to shared singleton, so just verify behavior
        let (sessions, _) = await manager.listSessions(pageSize: 10, pageToken: nil)
        XCTAssertTrue(sessions.allSatisfy { $0.name.hasPrefix("sessions/") })
    }

    func testListSessionsPagination() async {
        let manager = SessionManager.shared

        // Create multiple sessions
        var createdNames: [String] = []
        for i in 0 ..< 5 {
            let session = await manager.createSession(
                sessionId: "test-pagination-\(i)",
                displayName: "Pagination \(i)",
                metadata: [:],
            )
            createdNames.append(session.name)
        }

        // Test pagination with page size of 2
        let (firstPage, _) = await manager.listSessions(pageSize: 2, pageToken: nil)
        XCTAssertLessThanOrEqual(firstPage.count, 2)
        // May have more sessions from other tests

        // Cleanup
        for name in createdNames {
            _ = await manager.deleteSession(name: name)
        }
    }

    // MARK: - Transaction Tests

    func testBeginTransactionOnNonExistentSession() async {
        let manager = SessionManager.shared

        do {
            _ = try await manager.beginTransaction(
                sessionName: "sessions/nonexistent-tx",
                isolationLevel: .readCommitted,
                timeout: 60,
            )
            XCTFail("Expected SessionError.sessionNotFound")
        } catch let error as SessionError {
            XCTAssertEqual(error.description, SessionError.sessionNotFound.description)
        } catch {
            XCTFail("Expected SessionError, got \(error)")
        }
    }

    func testBeginTransactionUpdatesSessionState() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-tx-state",
            displayName: "Transaction State Test",
            metadata: [:],
        )

        let (transactionId, updatedSession) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        XCTAssertFalse(transactionId.isEmpty)
        XCTAssertEqual(updatedSession.state, .inTransaction)
        XCTAssertEqual(updatedSession.transactionID, transactionId)

        // Cleanup - commit and delete
        _ = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: transactionId,
        )
        _ = await manager.deleteSession(name: session.name)
    }

    func testBeginTransactionTwiceThrows() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-tx-twice",
            displayName: "Double Transaction Test",
            metadata: [:],
        )

        let (transactionId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        do {
            _ = try await manager.beginTransaction(
                sessionName: session.name,
                isolationLevel: .readCommitted,
                timeout: 60,
            )
            XCTFail("Expected SessionError.transactionAlreadyActive")
        } catch let error as SessionError {
            XCTAssertEqual(error.description, SessionError.transactionAlreadyActive.description)
        }

        // Cleanup
        _ = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: transactionId,
        )
        _ = await manager.deleteSession(name: session.name)
    }

    func testCommitTransactionWithMismatchedId() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-tx-mismatch",
            displayName: "Mismatch Test",
            metadata: [:],
        )

        let (transactionId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        do {
            _ = try await manager.commitTransaction(
                sessionName: session.name,
                transactionId: "wrong-transaction-id",
            )
            XCTFail("Expected SessionError.transactionMismatch")
        } catch let error as SessionError {
            XCTAssertEqual(error.description, SessionError.transactionMismatch.description)
        }

        // Cleanup
        _ = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: transactionId,
        )
        _ = await manager.deleteSession(name: session.name)
    }

    func testCommitTransactionRestoresActiveState() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-commit-restore",
            displayName: "Commit Restore Test",
            metadata: [:],
        )

        let (txId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        let committed = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: txId,
        )

        XCTAssertEqual(committed.state, .committed)
        XCTAssertNotNil(committed.updatedSession)
        XCTAssertEqual(committed.updatedSession.state, .active)
        XCTAssertTrue(committed.updatedSession.transactionID.isEmpty)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Application Tracking Tests

    func testAddApplicationToSession() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-add-app",
            displayName: "Add App Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/12345")

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertTrue(snapshot.applications.contains("applications/12345"))

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testAddDuplicateApplicationIsIdempotent() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-dup-app",
            displayName: "Duplicate App Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/123")
        await manager.addApplication(sessionName: session.name, applicationName: "applications/123")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        let appCount = snapshot?.applications.count(where: { $0 == "applications/123" }) ?? 0
        XCTAssertEqual(appCount, 1)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRemoveApplicationFromSession() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-remove-app",
            displayName: "Remove App Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/999")
        await manager.removeApplication(sessionName: session.name, applicationName: "applications/999")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        XCTAssertFalse(snapshot?.applications.contains("applications/999") ?? true)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Observation Tracking Tests

    func testAddObservationToSession() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-add-obs",
            displayName: "Add Observation Test",
            metadata: [:],
        )

        await manager.addObservation(sessionName: session.name, observationName: "observations/abc")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        XCTAssertTrue(snapshot?.observations.contains("observations/abc") ?? false)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRemoveObservationFromSession() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-remove-obs",
            displayName: "Remove Observation Test",
            metadata: [:],
        )

        await manager.addObservation(sessionName: session.name, observationName: "observations/xyz")
        await manager.removeObservation(sessionName: session.name, observationName: "observations/xyz")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        XCTAssertFalse(snapshot?.observations.contains("observations/xyz") ?? true)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Operation Recording Tests

    func testRecordOperationAddsToHistory() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-record-op",
            displayName: "Record Operation Test",
            metadata: [:],
        )

        await manager.recordOperation(
            sessionName: session.name,
            operationType: "CreateWindow",
            resource: "windows/123",
            success: true,
            error: nil,
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertEqual(snapshot.history.count, 1)
        XCTAssertEqual(snapshot.history[0].operationType, "CreateWindow")
        XCTAssertEqual(snapshot.history[0].resource, "windows/123")
        XCTAssertTrue(snapshot.history[0].success)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRecordOperationWithError() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-record-error",
            displayName: "Record Error Test",
            metadata: [:],
        )

        await manager.recordOperation(
            sessionName: session.name,
            operationType: "DeleteWindow",
            resource: "windows/456",
            success: false,
            error: "Window not found",
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertFalse(snapshot.history[0].success)
        XCTAssertEqual(snapshot.history[0].error, "Window not found")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Session Snapshot Tests

    func testGetSessionSnapshotReturnsNilForNonExistent() async {
        let manager = SessionManager.shared

        let snapshot = await manager.getSessionSnapshot(sessionName: "sessions/nonexistent-snapshot")
        XCTAssertNil(snapshot)
    }

    func testGetSessionSnapshotContainsAllFields() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-full-snapshot",
            displayName: "Full Snapshot Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/111")
        await manager.addObservation(sessionName: session.name, observationName: "observations/222")
        await manager.recordOperation(
            sessionName: session.name,
            operationType: "TestOp",
            resource: "test/resource",
            success: true,
            error: nil,
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertEqual(snapshot.session.name, session.name)
        XCTAssertTrue(snapshot.applications.contains("applications/111"))
        XCTAssertTrue(snapshot.observations.contains("observations/222"))
        XCTAssertEqual(snapshot.history.count, 1)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }
}
