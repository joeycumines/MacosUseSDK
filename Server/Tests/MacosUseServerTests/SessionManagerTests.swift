import MacosUseProto
@testable import MacosUseServer
import XCTest

/// Unit tests for SessionManager state machine and session lifecycle.
/// These tests verify session creation, transaction management, and resource tracking.
final class SessionManagerTests: XCTestCase {
    // MARK: - SessionError Tests

    func testSessionErrorSessionNotFoundDescription() {
        let error = SessionError.sessionNotFound
        XCTAssertEqual(error.description, "Session not found")
    }

    func testSessionErrorTransactionAlreadyActiveDescription() {
        let error = SessionError.transactionAlreadyActive
        XCTAssertEqual(error.description, "Transaction already active for this session")
    }

    func testSessionErrorNoActiveTransactionDescription() {
        let error = SessionError.noActiveTransaction
        XCTAssertEqual(error.description, "No active transaction for this session")
    }

    func testSessionErrorTransactionMismatchDescription() {
        let error = SessionError.transactionMismatch
        XCTAssertEqual(error.description, "Transaction ID does not match active transaction")
    }

    func testSessionErrorInvalidSessionStateDescription() {
        let error = SessionError.invalidSessionState
        XCTAssertEqual(error.description, "Session is not in a valid state for this operation")
    }

    func testSessionErrorRevisionNotFoundDescription() {
        let error = SessionError.revisionNotFound
        XCTAssertEqual(error.description, "Revision ID not found")
    }

    func testAllSessionErrorCasesConformToCustomStringConvertible() {
        let allErrors: [SessionError] = [
            .sessionNotFound,
            .transactionAlreadyActive,
            .noActiveTransaction,
            .transactionMismatch,
            .invalidSessionState,
            .revisionNotFound,
        ]
        for error in allErrors {
            XCTAssertFalse(error.description.isEmpty)
        }
    }

    // MARK: - Session Creation Tests

    func testCreateSessionWithProvidedId() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-session-id-1",
            displayName: "Test Session",
            metadata: [:],
        )

        XCTAssertEqual(session.name, "sessions/test-session-id-1")
        XCTAssertEqual(session.displayName, "Test Session")
        XCTAssertEqual(session.state, .active)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testCreateSessionWithAutoGeneratedId() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: nil,
            displayName: "Auto ID Session",
            metadata: [:],
        )

        XCTAssertTrue(session.name.hasPrefix("sessions/"))
        XCTAssertTrue(session.name.count > "sessions/".count)
        XCTAssertEqual(session.state, .active)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testCreateSessionWithMetadata() async {
        let manager = SessionManager.shared
        let metadata = ["key1": "value1", "key2": "value2"]

        let session = await manager.createSession(
            sessionId: "test-metadata-session",
            displayName: "Metadata Session",
            metadata: metadata,
        )

        XCTAssertEqual(session.metadata["key1"], "value1")
        XCTAssertEqual(session.metadata["key2"], "value2")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testCreateSessionSetsTimestamps() async {
        let manager = SessionManager.shared
        let beforeCreate = Date()

        let session = await manager.createSession(
            sessionId: "test-timestamps",
            displayName: "Timestamp Session",
            metadata: [:],
        )

        let afterCreate = Date()
        let createTime = session.createTime.date
        let lastAccessTime = session.lastAccessTime.date
        let expireTime = session.expireTime.date

        XCTAssertGreaterThanOrEqual(createTime, beforeCreate)
        XCTAssertLessThanOrEqual(createTime, afterCreate)
        XCTAssertEqual(createTime, lastAccessTime)
        XCTAssertGreaterThan(expireTime, createTime)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Session Retrieval Tests

    func testGetSessionReturnsNilForNonExistent() async {
        let manager = SessionManager.shared

        let session = await manager.getSession(name: "sessions/nonexistent-session")
        XCTAssertNil(session)
    }

    func testGetSessionUpdatesLastAccessTime() async throws {
        let manager = SessionManager.shared

        let created = await manager.createSession(
            sessionId: "test-access-time",
            displayName: "Access Time Test",
            metadata: [:],
        )
        let initialAccessTime = created.lastAccessTime.date

        let retrievedOptional = await manager.getSession(name: created.name)
        let retrieved = try XCTUnwrap(retrievedOptional)
        XCTAssertGreaterThanOrEqual(retrieved.lastAccessTime.date, initialAccessTime)

        // Cleanup
        _ = await manager.deleteSession(name: created.name)
    }

    // MARK: - Session Deletion Tests

    func testDeleteSessionReturnsFalseForNonExistent() async {
        let manager = SessionManager.shared

        let deleted = await manager.deleteSession(name: "sessions/nonexistent-delete")
        XCTAssertFalse(deleted)
    }

    func testDeleteSessionReturnsTrueAndRemoves() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-delete",
            displayName: "Delete Session",
            metadata: [:],
        )

        let deleted = await manager.deleteSession(name: session.name)
        XCTAssertTrue(deleted)

        let retrieved = await manager.getSession(name: session.name)
        XCTAssertNil(retrieved)
    }

    // MARK: - Session Listing Tests

    func testListSessionsEmptyResult() async {
        // Create a fresh manager context by cleaning up first
        let manager = SessionManager.shared

        // Create and immediately delete to get a clean state
        let testSession = await manager.createSession(
            sessionId: "temp-cleanup",
            displayName: "Temp",
            metadata: [:],
        )
        _ = await manager.deleteSession(name: testSession.name)

        // Note: We can't fully isolate due to shared singleton, so just verify behavior
        let (sessions, _) = await manager.listSessions(pageSize: 10, pageToken: nil)
        XCTAssertTrue(sessions.allSatisfy { $0.name.hasPrefix("sessions/") })
    }

    func testListSessionsPagination() async {
        let manager = SessionManager.shared

        // Create multiple sessions
        var createdNames: [String] = []
        for i in 0 ..< 5 {
            let session = await manager.createSession(
                sessionId: "test-pagination-\(i)",
                displayName: "Pagination \(i)",
                metadata: [:],
            )
            createdNames.append(session.name)
        }

        // Test pagination with page size of 2
        let (firstPage, _) = await manager.listSessions(pageSize: 2, pageToken: nil)
        XCTAssertLessThanOrEqual(firstPage.count, 2)
        // May have more sessions from other tests

        // Cleanup
        for name in createdNames {
            _ = await manager.deleteSession(name: name)
        }
    }

    // MARK: - Transaction Tests

    func testBeginTransactionOnNonExistentSession() async {
        let manager = SessionManager.shared

        do {
            _ = try await manager.beginTransaction(
                sessionName: "sessions/nonexistent-tx",
                isolationLevel: .readCommitted,
                timeout: 60,
            )
            XCTFail("Expected SessionError.sessionNotFound")
        } catch let error as SessionError {
            XCTAssertEqual(error.description, SessionError.sessionNotFound.description)
        } catch {
            XCTFail("Expected SessionError, got \(error)")
        }
    }

    func testBeginTransactionUpdatesSessionState() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-tx-state",
            displayName: "Transaction State Test",
            metadata: [:],
        )

        let (transactionId, updatedSession) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        XCTAssertFalse(transactionId.isEmpty)
        XCTAssertEqual(updatedSession.state, .inTransaction)
        XCTAssertEqual(updatedSession.transactionID, transactionId)

        // Cleanup - commit and delete
        _ = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: transactionId,
        )
        _ = await manager.deleteSession(name: session.name)
    }

    func testBeginTransactionTwiceThrows() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-tx-twice",
            displayName: "Double Transaction Test",
            metadata: [:],
        )

        let (transactionId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        do {
            _ = try await manager.beginTransaction(
                sessionName: session.name,
                isolationLevel: .readCommitted,
                timeout: 60,
            )
            XCTFail("Expected SessionError.transactionAlreadyActive")
        } catch let error as SessionError {
            XCTAssertEqual(error.description, SessionError.transactionAlreadyActive.description)
        }

        // Cleanup
        _ = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: transactionId,
        )
        _ = await manager.deleteSession(name: session.name)
    }

    func testCommitTransactionWithMismatchedId() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-tx-mismatch",
            displayName: "Mismatch Test",
            metadata: [:],
        )

        let (transactionId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        do {
            _ = try await manager.commitTransaction(
                sessionName: session.name,
                transactionId: "wrong-transaction-id",
            )
            XCTFail("Expected SessionError.transactionMismatch")
        } catch let error as SessionError {
            XCTAssertEqual(error.description, SessionError.transactionMismatch.description)
        }

        // Cleanup
        _ = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: transactionId,
        )
        _ = await manager.deleteSession(name: session.name)
    }

    func testCommitTransactionRestoresActiveState() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-commit-restore",
            displayName: "Commit Restore Test",
            metadata: [:],
        )

        let (txId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .readCommitted,
            timeout: 60,
        )

        let committed = try await manager.commitTransaction(
            sessionName: session.name,
            transactionId: txId,
        )

        XCTAssertEqual(committed.state, .committed)
        XCTAssertNotNil(committed.updatedSession)
        XCTAssertEqual(committed.updatedSession.state, .active)
        XCTAssertTrue(committed.updatedSession.transactionID.isEmpty)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Application Tracking Tests

    func testAddApplicationToSession() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-add-app",
            displayName: "Add App Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/12345")

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertTrue(snapshot.applications.contains("applications/12345"))

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testAddDuplicateApplicationIsIdempotent() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-dup-app",
            displayName: "Duplicate App Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/123")
        await manager.addApplication(sessionName: session.name, applicationName: "applications/123")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        let appCount = snapshot?.applications.count(where: { $0 == "applications/123" }) ?? 0
        XCTAssertEqual(appCount, 1)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRemoveApplicationFromSession() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-remove-app",
            displayName: "Remove App Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/999")
        await manager.removeApplication(sessionName: session.name, applicationName: "applications/999")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        XCTAssertFalse(snapshot?.applications.contains("applications/999") ?? true)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Observation Tracking Tests

    func testAddObservationToSession() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-add-obs",
            displayName: "Add Observation Test",
            metadata: [:],
        )

        await manager.addObservation(sessionName: session.name, observationName: "observations/abc")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        XCTAssertTrue(snapshot?.observations.contains("observations/abc") ?? false)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRemoveObservationFromSession() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-remove-obs",
            displayName: "Remove Observation Test",
            metadata: [:],
        )

        await manager.addObservation(sessionName: session.name, observationName: "observations/xyz")
        await manager.removeObservation(sessionName: session.name, observationName: "observations/xyz")

        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        XCTAssertFalse(snapshot?.observations.contains("observations/xyz") ?? true)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Operation Recording Tests

    func testRecordOperationAddsToHistory() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-record-op",
            displayName: "Record Operation Test",
            metadata: [:],
        )

        await manager.recordOperation(
            sessionName: session.name,
            operationType: "CreateWindow",
            resource: "windows/123",
            success: true,
            error: nil,
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertEqual(snapshot.history.count, 1)
        XCTAssertEqual(snapshot.history[0].operationType, "CreateWindow")
        XCTAssertEqual(snapshot.history[0].resource, "windows/123")
        XCTAssertTrue(snapshot.history[0].success)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRecordOperationWithError() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-record-error",
            displayName: "Record Error Test",
            metadata: [:],
        )

        await manager.recordOperation(
            sessionName: session.name,
            operationType: "DeleteWindow",
            resource: "windows/456",
            success: false,
            error: "Window not found",
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertFalse(snapshot.history[0].success)
        XCTAssertEqual(snapshot.history[0].error, "Window not found")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Session Snapshot Tests

    func testGetSessionSnapshotReturnsNilForNonExistent() async {
        let manager = SessionManager.shared

        let snapshot = await manager.getSessionSnapshot(sessionName: "sessions/nonexistent-snapshot")
        XCTAssertNil(snapshot)
    }

    func testGetSessionSnapshotContainsAllFields() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-full-snapshot",
            displayName: "Full Snapshot Test",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/111")
        await manager.addObservation(sessionName: session.name, observationName: "observations/222")
        await manager.recordOperation(
            sessionName: session.name,
            operationType: "TestOp",
            resource: "test/resource",
            success: true,
            error: nil,
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertEqual(snapshot.session.name, session.name)
        XCTAssertTrue(snapshot.applications.contains("applications/111"))
        XCTAssertTrue(snapshot.observations.contains("observations/222"))
        XCTAssertEqual(snapshot.history.count, 1)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Task 45: Session Expiration Tests

    func testSessionHasExpireTime() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-expire-time",
            displayName: "Expire Time Test",
            metadata: [:],
        )

        // Verify expire time is set
        XCTAssertTrue(session.hasExpireTime, "Session should have expire time")
        XCTAssertGreaterThan(session.expireTime.seconds, session.createTime.seconds, "Expire time should be after create time")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testSessionExpireTimeIs1HourFromCreate() async {
        let manager = SessionManager.shared

        let beforeCreate = Date()
        let session = await manager.createSession(
            sessionId: "test-expire-1h",
            displayName: "1 Hour Expire Test",
            metadata: [:],
        )
        let afterCreate = Date()

        let createTime = session.createTime.date
        let expireTime = session.expireTime.date
        let expectedDuration: TimeInterval = 3600 // 1 hour

        // Verify expire time is approximately 1 hour from create
        let actualDuration = expireTime.timeIntervalSince(createTime)
        XCTAssertEqual(actualDuration, expectedDuration, accuracy: 5.0, "Expire time should be ~1 hour from create")

        // Also verify create time is within bounds
        XCTAssertGreaterThanOrEqual(createTime, beforeCreate)
        XCTAssertLessThanOrEqual(createTime, afterCreate)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Task 45: Concurrent Session Operations Tests

    func testConcurrentSessionCreation() async {
        let manager = SessionManager.shared
        var createdNames: [String] = []
        let count = 20

        // Create sessions concurrently
        await withTaskGroup(of: Macosusesdk_V1_Session.self) { group in
            for i in 0 ..< count {
                group.addTask {
                    await manager.createSession(
                        sessionId: "concurrent-create-\(i)",
                        displayName: "Concurrent \(i)",
                        metadata: [:],
                    )
                }
            }

            for await session in group {
                createdNames.append(session.name)
            }
        }

        // Verify all sessions were created with unique names
        XCTAssertEqual(createdNames.count, count, "Should create all sessions")
        XCTAssertEqual(Set(createdNames).count, count, "All session names should be unique")

        // Cleanup
        for name in createdNames {
            _ = await manager.deleteSession(name: name)
        }
    }

    func testConcurrentSessionDeletion() async {
        let manager = SessionManager.shared
        var createdNames: [String] = []

        // Create sessions first
        for i in 0 ..< 10 {
            let session = await manager.createSession(
                sessionId: "concurrent-delete-\(i)",
                displayName: "To Delete \(i)",
                metadata: [:],
            )
            createdNames.append(session.name)
        }

        // Delete all concurrently
        var deleteResults: [Bool] = []
        await withTaskGroup(of: Bool.self) { group in
            for name in createdNames {
                group.addTask {
                    await manager.deleteSession(name: name)
                }
            }

            for await result in group {
                deleteResults.append(result)
            }
        }

        // All should report success
        XCTAssertEqual(deleteResults.count(where: { $0 }), createdNames.count, "All deletes should succeed")

        // Verify all are gone
        for name in createdNames {
            let session = await manager.getSession(name: name)
            XCTAssertNil(session, "Session should be deleted")
        }
    }

    func testConcurrentSessionAccess() async {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "concurrent-access",
            displayName: "Concurrent Access Test",
            metadata: [:],
        )

        // Concurrent reads and application adds
        await withTaskGroup(of: Void.self) { group in
            // Readers
            for _ in 0 ..< 10 {
                group.addTask {
                    _ = await manager.getSession(name: session.name)
                }
            }

            // Application adders
            for i in 0 ..< 10 {
                group.addTask {
                    await manager.addApplication(sessionName: session.name, applicationName: "applications/app\(i)")
                }
            }

            // Observation adders
            for i in 0 ..< 10 {
                group.addTask {
                    await manager.addObservation(sessionName: session.name, observationName: "observations/obs\(i)")
                }
            }
        }

        // Verify session is still valid
        let finalSession = await manager.getSession(name: session.name)
        XCTAssertNotNil(finalSession, "Session should still exist")

        // Verify snapshot has data
        let snapshot = await manager.getSessionSnapshot(sessionName: session.name)
        XCTAssertNotNil(snapshot, "Snapshot should exist")
        XCTAssertEqual(snapshot?.applications.count, 10, "Should have 10 applications")
        XCTAssertEqual(snapshot?.observations.count, 10, "Should have 10 observations")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Task 45: Additional Application/Observation Tracking Tests

    func testAddMultipleApplications() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-multi-apps",
            displayName: "Multi Apps Test",
            metadata: [:],
        )

        // Add multiple applications
        for i in 0 ..< 5 {
            await manager.addApplication(sessionName: session.name, applicationName: "applications/app-\(i)")
        }

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertEqual(snapshot.applications.count, 5, "Should have 5 applications")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRemoveNonExistentApplicationIsNoOp() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-remove-nonexist-app",
            displayName: "Remove Nonexistent App",
            metadata: [:],
        )

        await manager.addApplication(sessionName: session.name, applicationName: "applications/real-app")
        await manager.removeApplication(sessionName: session.name, applicationName: "applications/fake-app")

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        XCTAssertEqual(snapshot.applications.count, 1, "Should still have the real app")
        XCTAssertTrue(snapshot.applications.contains("applications/real-app"))

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testAddObservationToNonexistentSessionIsNoOp() async {
        let manager = SessionManager.shared

        // Should not crash
        await manager.addObservation(sessionName: "sessions/does-not-exist", observationName: "observations/test")

        // Verify it didn't create a session
        let session = await manager.getSession(name: "sessions/does-not-exist")
        XCTAssertNil(session)
    }

    func testRemoveObservationFromNonexistentSessionIsNoOp() async {
        let manager = SessionManager.shared

        // Should not crash
        await manager.removeObservation(sessionName: "sessions/does-not-exist", observationName: "observations/test")

        // Verify nothing happened
        let session = await manager.getSession(name: "sessions/does-not-exist")
        XCTAssertNil(session)
    }

    func testAddDuplicateObservationIsIdempotent() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-dup-obs",
            displayName: "Duplicate Observation Test",
            metadata: [:],
        )

        await manager.addObservation(sessionName: session.name, observationName: "observations/dup")
        await manager.addObservation(sessionName: session.name, observationName: "observations/dup")
        await manager.addObservation(sessionName: session.name, observationName: "observations/dup")

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)
        let obsCount = snapshot.observations.count(where: { $0 == "observations/dup" })
        XCTAssertEqual(obsCount, 1, "Should only have one instance")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Task 45: Session Snapshot Comprehensive Tests

    func testGetSessionSnapshotIncludesSessionObject() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-snapshot-session",
            displayName: "Snapshot Session Test",
            metadata: ["key": "value"],
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)

        // Verify session object is complete
        XCTAssertEqual(snapshot.session.name, session.name)
        XCTAssertEqual(snapshot.session.displayName, "Snapshot Session Test")
        XCTAssertEqual(snapshot.session.metadata["key"], "value")
        XCTAssertEqual(snapshot.session.state, .active)

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testGetSessionSnapshotIncludesEmptyCollections() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-snapshot-empty",
            displayName: "Empty Snapshot Test",
            metadata: [:],
        )

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)

        // Empty collections should be present but empty
        XCTAssertTrue(snapshot.applications.isEmpty, "Applications should be empty")
        XCTAssertTrue(snapshot.observations.isEmpty, "Observations should be empty")
        XCTAssertTrue(snapshot.history.isEmpty, "History should be empty")

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testGetSessionSnapshotIncludesOperationHistory() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-snapshot-history",
            displayName: "History Snapshot Test",
            metadata: [:],
        )

        // Add multiple operations
        for i in 0 ..< 5 {
            await manager.recordOperation(
                sessionName: session.name,
                operationType: "Operation\(i)",
                resource: "resource/\(i)",
                success: i % 2 == 0,
                error: i % 2 == 0 ? nil : "Error \(i)",
            )
        }

        let snapshotOptional = await manager.getSessionSnapshot(sessionName: session.name)
        let snapshot = try XCTUnwrap(snapshotOptional)

        XCTAssertEqual(snapshot.history.count, 5, "Should have 5 operations")

        // Verify operations are in order (timestamp ordering)
        for (idx, op) in snapshot.history.enumerated() {
            XCTAssertEqual(op.operationType, "Operation\(idx)")
            XCTAssertEqual(op.resource, "resource/\(idx)")
        }

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Task 45: Transaction with Rollback Tests

    func testRollbackTransactionWithSerializableIsolation() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-rollback-serializable",
            displayName: "Rollback Test",
            metadata: [:],
        )

        // Begin transaction with SERIALIZABLE isolation (creates snapshot)
        let (txId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .serializable,
            timeout: 60,
        )

        // Record some operations
        await manager.recordOperation(
            sessionName: session.name,
            operationType: "OpInTransaction",
            resource: "resource/tx",
            success: true,
            error: nil,
        )

        // Rollback - need to find the revision ID
        // For SERIALIZABLE, a snapshot is created with revisionId = "snapshot-{txId}"
        let revisionId = "snapshot-\(txId)"

        do {
            let rolledBack = try await manager.rollbackTransaction(
                sessionName: session.name,
                transactionId: txId,
                revisionId: revisionId,
            )
            XCTAssertEqual(rolledBack.state, .rolledBack)
            XCTAssertEqual(rolledBack.updatedSession.state, .active)
        } catch {
            // Rollback failed - may not be a test failure, depends on implementation
            XCTFail("Rollback should succeed: \(error)")
        }

        // Cleanup
        _ = await manager.deleteSession(name: session.name)
    }

    func testRollbackWithInvalidRevisionThrows() async throws {
        let manager = SessionManager.shared

        let session = await manager.createSession(
            sessionId: "test-rollback-invalid",
            displayName: "Invalid Rollback Test",
            metadata: [:],
        )

        let (txId, _) = try await manager.beginTransaction(
            sessionName: session.name,
            isolationLevel: .serializable,
            timeout: 60,
        )

        do {
            _ = try await manager.rollbackTransaction(
                sessionName: session.name,
                transactionId: txId,
                revisionId: "invalid-revision-id",
            )
            XCTFail("Should throw for invalid revision ID")
        } catch let error as SessionError {
            XCTAssertEqual(error.description, SessionError.revisionNotFound.description)
        }

        // Cleanup - commit the transaction first
        _ = try await manager.commitTransaction(sessionName: session.name, transactionId: txId)
        _ = await manager.deleteSession(name: session.name)
    }

    // MARK: - Task 45: invalidateAllSessions Tests

    func testInvalidateAllSessionsReturnsCount() async {
        let manager = SessionManager.shared

        // Create a few sessions
        var createdNames: [String] = []
        for i in 0 ..< 3 {
            let s = await manager.createSession(
                sessionId: "test-invalidate-all-\(i)",
                displayName: "Invalidate \(i)",
                metadata: [:],
            )
            createdNames.append(s.name)
        }

        // Invalidate all
        let count = await manager.invalidateAllSessions()

        // Should have invalidated at least the 3 we created (may be more from other tests)
        XCTAssertGreaterThanOrEqual(count, 3, "Should invalidate at least our 3 sessions")

        // Sessions should be gone
        for name in createdNames {
            let session = await manager.getSession(name: name)
            XCTAssertNil(session, "Session should be invalidated and removed")
        }
    }

    func testInvalidateAllSessionsIsIdempotent() async {
        let manager = SessionManager.shared

        // Create and invalidate
        let s = await manager.createSession(sessionId: "test-idempotent-invalidate", displayName: "Test", metadata: [:])

        let firstCount = await manager.invalidateAllSessions()
        XCTAssertGreaterThanOrEqual(firstCount, 1)

        // Second invalidate should return 0 (nothing left)
        let secondCount = await manager.invalidateAllSessions()
        XCTAssertEqual(secondCount, 0, "Second invalidate should find nothing to invalidate")

        // Session should still be gone
        let session = await manager.getSession(name: s.name)
        XCTAssertNil(session)
    }
}
